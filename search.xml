<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Dart学习笔记（一）</title>
      <link href="/2022/04/12/Dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/04/12/Dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>Dart学习笔记（一）</h1><p>作为编写<code>Flutter</code>应用的工具语言，当然还是还是跑不掉的</p><blockquote><p>Dart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和sound type system 。                                                                                 ——百度百科</p></blockquote><p>由Google开发，<code>Flutter</code>基于<code>Dart</code>开发，并且在2018年，<code>Dart2</code>成为强类型语言，总的来说，它还比较新，目前对于它的了解仍停留在其是<code>Flutter</code>的**“工具语言”**</p><h2 id="1-程序的入口"><a class="header-anchor" href="#1-程序的入口">¶</a>1. 程序的入口</h2><p>至关重要的一点，程序的入口，与其他编程语言一样，<code>Dart</code>老实本分地遵循着传统，以<code>main()</code>作为起点</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="comment">// 或者void main表示没有返回值</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Hello Dart&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以直接写成<code>main()</code>或者前面加上<code>void</code>表明其没有返回值</p><h2 id="2-注释"><a class="header-anchor" href="#2-注释">¶</a>2. 注释</h2><p>良好的注释对于所有程序员都很重要，包括自己</p><p><code>Dart</code>中支持单行注释、多行注释以及文档注释</p><h3 id="2-1-单行注释"><a class="header-anchor" href="#2-1-单行注释">¶</a>2.1. 单行注释</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释</span></span><br></pre></td></tr></table></figure><p>这个用的最为频繁，对于各种方法、变量、语句都很适用，就像读书时加批注一样</p><h3 id="2-2-多行注释"><a class="header-anchor" href="#2-2-多行注释">¶</a>2.2. 多行注释</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个无非是多注释几行，如果需要描述的内容多一些可以用这个</p><h3 id="2-3-文档注释"><a class="header-anchor" href="#2-3-文档注释">¶</a>2.3. 文档注释</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file</span></span><br><span class="line"><span class="comment">// for details. All rights reserved. Use of this source code is governed by a</span></span><br><span class="line"><span class="comment">// BSD-style license that can be found in the LICENSE file.</span></span><br></pre></td></tr></table></figure><p>像这个注释就比较规范了，通常用在声明类和文件时，总体描述作用时使用，最常见的就是在源码里面</p><p>总之，如果不确定在哪里用什么样的注释，源码总是最好的参考</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img202204102325039.png" alt="image-20220410232524898" style="zoom:67%;" /><h2 id="3-变量"><a class="header-anchor" href="#3-变量">¶</a>3. 变量</h2><p>变量可以使用<code>var</code>进行定义</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 类型推断</span></span><br></pre></td></tr></table></figure><p>编译器会根据初始化的值进行<code>类型推断</code>，这里会被推断为<code>String</code></p><p>除此以外，也可以<strong>使用指定的类型进行声明</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> s = <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>直接使用指定的类型声明为该类型的变量</p><h2 id="4-常量"><a class="header-anchor" href="#4-常量">¶</a>4. 常量</h2><p>在<code>Dart</code>中，常量通常使用<code>const</code>和<code>final</code>声明</p><p>使用<code>const</code>表示，可以直接替代<code>var</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>; <span class="comment">// 类型推导</span></span><br></pre></td></tr></table></figure><p>直接使用<code>const</code>，编译器可以根据赋值进行类型推导</p><p>也可以直接加上具体类型</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">String</span> DATE_FORMAT = <span class="string">&#x27;yyyy-MM-dd&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>const</code>声明的是<strong>编译期</strong>常量，即在程序开始运行之前，就进行赋值</p><p><code>final</code>的使用方面同样也有两种</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> now = <span class="keyword">new</span> <span class="built_in">DateTime</span>.now();  <span class="comment">// 惰性初始化</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">int</span> length = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>但是尤其需要主要的是，<code>final</code>声明的常量可以接受函数调用，只有它可以获取运行时的量进行赋值，这也是其与<code>const</code>最大的不同</p><h2 id="5-数据类型"><a class="header-anchor" href="#5-数据类型">¶</a>5. 数据类型</h2><p>与其他各类编程语言如出一辙，<code>Dart</code>也需要丰富的数据类型给处理的数据分分类</p><h3 id="5-1-字符串"><a class="header-anchor" href="#5-1-字符串">¶</a>5.1. 字符串</h3><p>这绝对是最最最常用到的类型了</p><p><code>String</code>用来表示字符串，直接可以使用<code>String</code>声明该类型的变量</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> s2 = <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><p>单引号、双引号都可以，保持一种习惯较好</p><p>不过声明更加推荐的方式还是直接进行<strong>类型推导</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>除此以外，<code>Dart</code>还提供了使用<code>'''</code>或<code>&quot;&quot;&quot;</code>括起来的写法，用来输出带有格式的字符串</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">String</span> s3 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  Hello, </span></span><br><span class="line"><span class="string">    World!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(s3);</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img202204112310753.png" alt="image-20220411231011454" style="zoom:100%;" /><p>和预览的效果完全一致</p><p>字符串的拼接有两种，一种使用<code>+</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s4 = <span class="string">&#x27;Happy&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s5 = <span class="string">&#x27; Birthday!&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(s4 + s5);</span><br></pre></td></tr></table></figure><p>而另一种使用的是<strong>模板占位</strong>，运用<code>$</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$s4</span><span class="subst">$s5</span>&#x27;</span>);</span><br></pre></td></tr></table></figure><p>使用这种方式先占位，程序会替换，与<code>Kotlin</code>的模板字符串完全一致，非常舒适</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img202204112317308.png" alt="image-20220411231715184"></p><h3 id="5-2-数值类型"><a class="header-anchor" href="#5-2-数值类型">¶</a>5.2. 数值类型</h3><p>主要分为整数与浮点</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值类型</span></span><br><span class="line"><span class="built_in">int</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">double</span> b = <span class="number">12.56</span>;</span><br></pre></td></tr></table></figure><p>整数使用<code>int</code>，小数使用<code>double</code>，简单粗暴，当然，同样推荐使用类型推导</p><p>另外，<code>int</code>可以直接赋值给<code>double</code>，反之不可</p><h3 id="5-3-布尔类型"><a class="header-anchor" href="#5-3-布尔类型">¶</a>5.3. 布尔类型</h3><p>没有太多可说的，<code>bool</code>定义，总共两个值：true和false</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">var</span> mFlag = <span class="keyword">false</span>;  <span class="comment">// 推导</span></span><br></pre></td></tr></table></figure><h3 id="5-4-List（数组-集合）"><a class="header-anchor" href="#5-4-List（数组-集合）">¶</a>5.4. List（数组/集合）</h3><p><code>[]</code>可以声明一个<code>List</code>，没有指定类型的情况下什么都可以往里放</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list1 = [<span class="string">&#x27;呱太&#x27;</span>, <span class="number">666</span>, <span class="keyword">false</span>];</span><br><span class="line"><span class="built_in">print</span>(list1);</span><br></pre></td></tr></table></figure><p>并且<code>List</code>的<code>length</code>属性可以获取长度</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;长度=<span class="subst">$&#123;list1.length&#125;</span>&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如果想要访问<code>List</code>中的元素，可以通过<code>索引</code>进行获取</p><blockquote><p>和其他语言一样，索引从0开始</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(list1[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>可以使用<code>&lt;T&gt;</code>的方式为<code>List</code>中的元素限定类型</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list2 = &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;阿凡提&#x27;</span>, <span class="string">&#x27;钢铁侠&#x27;</span>, <span class="string">&#x27;皮卡丘&#x27;</span>];</span><br><span class="line"><span class="built_in">print</span>(list2);</span><br></pre></td></tr></table></figure><p>这就不能自由发挥了，必须按照规矩办事</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list3 = []; <span class="comment">// 空List</span></span><br><span class="line">list3.add(<span class="string">&#x27;Van&#x27;</span>); <span class="comment">// 增加数据</span></span><br></pre></td></tr></table></figure><p>也可以先创建空的<code>List</code>，然后调用<code>add()</code>向其中填充元素，构建一个完整的<code>List</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个固定长度的集合</span></span><br><span class="line"><span class="keyword">var</span> list4 = <span class="built_in">List</span>.filled(<span class="number">3</span>, <span class="number">1</span>); <span class="comment">// growable属性为false，不可add，显示标明true可以add</span></span><br><span class="line">  <span class="comment">// list4.add(5);</span></span><br><span class="line"><span class="built_in">print</span>(list4);</span><br></pre></td></tr></table></figure><p>在<code>Java</code>中，集合是可以动态增长的，而数组则是在声明时给定了容量</p><p><code>List</code>的<code>filled(length, element)</code>方法会初始化指定长度<code>length</code>的数组，里面的元素使用给定的<code>element</code></p><blockquote><p>这个方法返回的<code>List</code>是默认growable为false，也就是不可增长的</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">external</span> <span class="keyword">factory</span> <span class="built_in">List</span>.filled(<span class="built_in">int</span> length, E fill, &#123;<span class="built_in">bool</span> growable = <span class="keyword">false</span>&#125;);</span><br></pre></td></tr></table></figure><p>源码里能看到<code>growable</code>，如果显示设置为true，就会转变为先前几个<code>List</code>那样，可以动态增长，当然，不能增长，你猜<code>add（）</code>会不会报错😏</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改非定长的集合的长度</span></span><br><span class="line">list1.length = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>直接修改<code>length</code>默认会<code>set</code>（当然<code>List</code>得是能变的那种）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">注释的解释 如果新的长度更大，新元素会赋值null，注意当前类型是否允许空值</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">The list must be growable.</span></span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img202204112348039.png" alt="image-20220411234824911"></p><h3 id="5-5-Map（字典-映射表）"><a class="header-anchor" href="#5-5-Map（字典-映射表）">¶</a>5.5. Map（字典/映射表）</h3><p><code>Map</code>常用于二级列表</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map 定义，类似于Json数据</span></span><br><span class="line">  <span class="keyword">var</span> map1 = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;minos&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&#x27;hobbies&#x27;</span>: [<span class="string">&#x27;唱&#x27;</span>, <span class="string">&#x27;跳&#x27;</span>, <span class="string">&#x27;rap&#x27;</span>, <span class="string">&#x27;魁地奇&#x27;</span>]</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>定义似乎和JS中的对象差不多，<code>key</code>和<code>value</code>可以指定任意类型，但<code>key</code>通常使用<code>String</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据访问</span></span><br><span class="line"><span class="built_in">print</span>(map1[<span class="string">&#x27;name&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>通过<code>key</code>来获取<code>Map</code>对象中与之对应的<code>value</code></p><p>当一个<code>key</code>对应多个<code>value</code>就会产生分组的形式，也就二级列表</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建空的map并向其中添加元素</span></span><br><span class="line"><span class="keyword">var</span> map2 = <span class="built_in">Map</span>();</span><br><span class="line">map2[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;伏地魔&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(map2);</span><br></pre></td></tr></table></figure><p>另外，调用<code>Map()</code>会创建一个空的<code>Map</code>实例，<code>Dart2</code>中省去了<code>new</code>关键字</p><p>直接通过给<code>key</code>赋值，就能添加对应数据，对应到<code>key</code>和<code>value</code>的关联关系</p><h2 id="6-类型判断"><a class="header-anchor" href="#6-类型判断">¶</a>6. 类型判断</h2><p>在编写代码时，有的时候只需要<strong>对关注的特定类型</strong>进行处理</p><p>这个时候就需要<code>is</code>来帮忙筛选一下</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用is关键字判断类型</span></span><br><span class="line"> <span class="comment">// 尤其是服务器返回</span></span><br><span class="line"> <span class="keyword">var</span> params = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"> <span class="keyword">if</span> (params <span class="keyword">is</span> <span class="built_in">String</span>) &#123;  <span class="comment">// 所期望的</span></span><br><span class="line">   <span class="built_in">print</span>(params.length);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params <span class="keyword">is</span> <span class="built_in">int</span>) &#123;</span><br><span class="line">   <span class="comment">// int处理</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们没有把握，或者担心出错，可以保险一点，取数据时添加上类型判断，仅处理需要的，防止返回了意料之外的内容</p><p><strong>只拿需要的，和考虑各种以外情况相比，自然是前者更简单</strong></p>]]></content>
      
      
      <categories>
          
          <category> Dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter学习笔记（四）</title>
      <link href="/2022/04/09/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2022/04/09/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>Flutter学习笔记（四）</h1><h2 id="1-列表组件"><a class="header-anchor" href="#1-列表组件">¶</a>1. 列表组件</h2><p>在实际的应用中，经常会有需要向用户提供大量数据进行阅读的场景，这就需要使用到列表组件展示数据</p><h3 id="1-1-ListView"><a class="header-anchor" href="#1-1-ListView">¶</a>1.1. ListView</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListView(</span><br><span class="line">          children: [</span><br><span class="line">            Text(<span class="string">&#x27;内容&#x27;</span>),</span><br><span class="line">            ElevatedButton(</span><br><span class="line">                onPressed: () =&gt; &#123;&#125;,</span><br><span class="line">                child: Text(<span class="string">&#x27;按钮&#x27;</span>)</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>对于<code>ListView</code>组件而言最重要的是内容，也就是<code>children</code>属性，它所接收的是<code>Widget</code>列表，理论上只要是<code>Widget</code>就可以放</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204082343867.png" alt="image-20220408234337755" style="zoom: 50%;" /><p>通常是使用<code>ListTile</code>组件进行搭配使用</p><p><code>ListTile</code>代表的就是列表中的一项，利用其属性可以方便组合列表项的样式</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ListTile(</span><br><span class="line">              leading: Image.network(<span class="string">&#x27;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffile01.dysucai.com%2Fd%2Ffile%2Flan2018061913%2Fk0ajx12543d.jpg&amp;refer=http%3A%2F%2Ffile01.dysucai.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1651720679&amp;t=7c87729681050f86d1340f1412b7eb52&#x27;</span>),   <span class="comment">// 开头的图片</span></span><br><span class="line">              title: Text(<span class="string">&#x27;标题&#x27;</span>),  <span class="comment">// 标题</span></span><br><span class="line">              subtitle: Text(<span class="string">&#x27;二级标题&#x27;</span>),    <span class="comment">// 子标题</span></span><br><span class="line">              trailing: Icon(Icons.keyboard_arrow_right),   <span class="comment">// 结尾的图片</span></span><br><span class="line">            ),</span><br></pre></td></tr></table></figure><p>以上就是<code>ListTile</code>常用的一些属性，然后多复制几个</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204091341330.png" style="zoom: 50%;" /><p><code>ListView</code>默认是沿垂直方向滚动，可以通过<code>scrollDirection</code>属性进行修改</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListView(</span><br><span class="line">          scrollDirection: Axis.horizontal,</span><br><span class="line">          children: [</span><br><span class="line">           Container(</span><br><span class="line">             width: <span class="number">150</span>,</span><br><span class="line">             color: Colors.blueAccent,</span><br><span class="line">           ),</span><br><span class="line">            Container(</span><br><span class="line">              width: <span class="number">150</span>,</span><br><span class="line">              color: Colors.yellowAccent,</span><br><span class="line">            ),</span><br><span class="line">            Container(</span><br><span class="line">              width: <span class="number">150</span>,</span><br><span class="line">              color: Colors.orangeAccent,</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204091458840.png" alt="image-20220409145802224" style="zoom:50%;" /><blockquote><p>注意：</p><p>设置沿水平方向滚动，高度会自适应父容器；设置垂直方向滚动，宽度会自适应父容器</p></blockquote><p>也可以为列表项设置子组件为<code>ListView</code>，实现嵌套</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ListView(</span><br><span class="line">          scrollDirection: Axis.horizontal,</span><br><span class="line">          children: [</span><br><span class="line">           Container(</span><br><span class="line">             width: <span class="number">150</span>,</span><br><span class="line">             color: Colors.blueAccent,</span><br><span class="line">           ),</span><br><span class="line">            Container(</span><br><span class="line">              width: <span class="number">150</span>,</span><br><span class="line">              color: Colors.yellowAccent,</span><br><span class="line">              child: ListView(   <span class="comment">// 子组件依然是列表</span></span><br><span class="line">                children: [</span><br><span class="line">                  Container(</span><br><span class="line">                    height: <span class="number">250</span>,</span><br><span class="line">                    color: Colors.black,</span><br><span class="line">                  ),</span><br><span class="line">                  Container(</span><br><span class="line">                    height: <span class="number">250</span>,</span><br><span class="line">                    color: Colors.white,</span><br><span class="line">                  ),</span><br><span class="line">                  Container(</span><br><span class="line">                    height: <span class="number">250</span>,</span><br><span class="line">                    color: Colors.red,</span><br><span class="line">                  )</span><br><span class="line">                ],</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            Container(</span><br><span class="line">              width: <span class="number">150</span>,</span><br><span class="line">              color: Colors.orangeAccent,</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204091503414.png" alt="image-20220409150334357" style="zoom:50%;" /><h3 id="1-2-GridView"><a class="header-anchor" href="#1-2-GridView">¶</a>1.2. GridView</h3><p>用于以网格的形式呈现数据的组件，因为默认是沿垂直方向滚动的，因此垂直方向为<code>主轴</code>，水平方向便是<code>副轴</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GridView.count(</span><br><span class="line">            crossAxisCount: <span class="number">2</span>,  <span class="comment">// 列数，副轴</span></span><br><span class="line">            children: [</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.deepOrange,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.lightBlue,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.blueGrey,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.amber,</span><br><span class="line">              )</span><br><span class="line">        ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204091621467.png" alt="image-20220409162101304" style="zoom:50%;" /><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GridView.count(</span><br><span class="line">            crossAxisCount: <span class="number">2</span>,  <span class="comment">// 列数，副轴</span></span><br><span class="line">            mainAxisSpacing: <span class="number">10</span>,   <span class="comment">// 沿主轴的间隙</span></span><br><span class="line">            crossAxisSpacing: <span class="number">20</span>,   <span class="comment">// 沿副轴的间隙</span></span><br><span class="line">            children: [</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.deepOrange,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.lightBlue,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.blueGrey,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.amber,</span><br><span class="line">              )</span><br><span class="line">        ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204091623947.png" alt="image-20220409162313898" style="zoom:50%;" /><p><code>GridView</code>中的每一项都是进行自适应的，需要修改item的比例需要通过<code>childAspectRatio</code>设置</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GridView.count(</span><br><span class="line">            crossAxisCount: <span class="number">2</span>,  <span class="comment">// 列数，副轴</span></span><br><span class="line">            mainAxisSpacing: <span class="number">10</span>,   <span class="comment">// 沿主轴的间隙</span></span><br><span class="line">            crossAxisSpacing: <span class="number">20</span>,   <span class="comment">// 沿副轴的间隙</span></span><br><span class="line">            childAspectRatio: <span class="number">0.8</span>,  <span class="comment">// 子项宽高比</span></span><br><span class="line">            children: [</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.deepOrange,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.lightBlue,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.blueGrey,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.amber,</span><br><span class="line">              )</span><br><span class="line">        ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204091628375.png" alt="image-20220409162840338" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Widget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter学习笔记（三）</title>
      <link href="/2022/04/07/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2022/04/07/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>Flutter学习笔记（三）</h1><h2 id="1-内置基础组件（图文）"><a class="header-anchor" href="#1-内置基础组件（图文）">¶</a>1. 内置基础组件（图文）</h2><h3 id="1-1-Text"><a class="header-anchor" href="#1-1-Text">¶</a>1.1. Text</h3><p><code>Text</code>组件就可以当成是Android里面的<code>TextView</code>，用来显示一段文本</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(</span><br><span class="line">            <span class="string">&#x27;虚荣，是我最喜欢的原罪！&#x27;</span>,</span><br><span class="line">            textAlign: TextAlign.center,</span><br><span class="line">            overflow: TextOverflow.ellipsis,</span><br><span class="line">            style: <span class="keyword">const</span> TextStyle(fontWeight: FontWeight.bold),</span><br><span class="line">          ),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491574275681649157427277.png" alt=""></p><p>这里外面加了<code>Container</code>作为<code>Text</code>组件的父容器</p><p><code>textAlign</code>属性用于居中文本，那应当是相当于<code>Text</code>自身，那需要关注一下<code>Text</code>组件自身有没有变化，之前的<code>Align</code>组件和<code>Container</code>的<code>alignment</code>属性都是会使容器变化的</p><p>因此加上一个样式属性，查看一下组件的有效区域</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(</span><br><span class="line">            <span class="string">&#x27;虚荣，是我最喜欢的原罪！&#x27;</span>,</span><br><span class="line">            textAlign: TextAlign.center,</span><br><span class="line">            overflow: TextOverflow.ellipsis,</span><br><span class="line">            style: <span class="keyword">const</span> TextStyle(</span><br><span class="line">                fontWeight: FontWeight.bold,</span><br><span class="line">                backgroundColor: Colors.lightGreenAccent    <span class="comment">// 加上一个背景色</span></span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491580745661649158073901.png" alt=""></p><p>并没有变化，依然是&quot;<code>wrap_content</code>&quot;</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          color: Colors.lightBlue,</span><br><span class="line">          width: <span class="number">300</span>,</span><br><span class="line">          height: <span class="number">300</span>,</span><br><span class="line">          child: Text(</span><br><span class="line">            <span class="string">&#x27;虚荣，是我最喜欢的原罪！&#x27;</span>,</span><br><span class="line">            textAlign: TextAlign.center,</span><br><span class="line">            overflow: TextOverflow.ellipsis,</span><br><span class="line">            style: <span class="keyword">const</span> TextStyle(</span><br><span class="line">                fontWeight: FontWeight.bold,</span><br><span class="line">                backgroundColor: Colors.lightGreenAccent</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>这里的<code>textAlign</code>可以理解为就是文本组件对于它的容器的一种位置</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491707415731649170741232.png" alt=""></p><p>文本组件恰好包裹文字内容，但是对齐是相对于父级组件也就是<code>Container</code>的</p><p>在<code>TextAlign</code>中有一段注释</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Whether and how to align text horizontally.</span></span></span><br></pre></td></tr></table></figure><p>这里表述的是该对齐只是水平方向上的，因此上文是水平居中</p><br/><p><code>overflow</code>属性虽然设置，但此刻并未生效，需要改动一下父容器，使文字溢出</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491719935641649171993079.png" alt=""></p><p>由于父容器宽度变小了，空间显得局促，因而在显示不下时，会采用实现设置的方式对文本进行省略</p><br/><p><code>style</code>属性主要借助于<code>TextStyle</code>来实现样式的修改</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          color: Colors.lightBlue,</span><br><span class="line">          width: <span class="number">100</span>,</span><br><span class="line">          height: <span class="number">300</span>,</span><br><span class="line">          child: Text(</span><br><span class="line">            <span class="string">&#x27;虚荣，是我最喜欢的原罪！&#x27;</span>,</span><br><span class="line">            textAlign: TextAlign.center,</span><br><span class="line">            overflow: TextOverflow.ellipsis,</span><br><span class="line">            style: <span class="keyword">const</span> TextStyle(</span><br><span class="line">              color: Colors.deepOrange,  <span class="comment">// 字体颜色</span></span><br><span class="line">                fontWeight: FontWeight.bold,  <span class="comment">// 加粗</span></span><br><span class="line">                backgroundColor: Colors.lightGreenAccent,  <span class="comment">// 背景</span></span><br><span class="line">              letterSpacing: <span class="number">10</span>  <span class="comment">// 字间距</span></span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491725205651649172519942.png" alt=""></p><h3 id="1-2-Image"><a class="header-anchor" href="#1-2-Image">¶</a>1.2. Image</h3><p><code>Image</code>组件主要用来展示图片，既可以是网络图片，也可以是本地资源</p><h4 id="1-2-1-本地图片"><a class="header-anchor" href="#1-2-1-本地图片">¶</a>1.2.1. 本地图片</h4><p>使用本地图片资源首先需要进行一些配置</p><p>项目的<strong>根目录</strong>下新建文件夹<code>images</code>，以及子级目录<code>3.0x</code>、<code>2.0x</code>，系统会根据设备不同的像素密度自动加载</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16492581935801649258193278.png" alt=""></p><p>这里就随便一点了</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16492587575791649258756960.png" alt=""></p><p>然后修改配置文件<code>pubspec.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># To add assets to your application, add an assets section, like this:</span></span><br><span class="line">  <span class="attr">assets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">images/bg.jpg</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">images/2.0x/bg.jpg</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">images/3.0x/bg.jpg</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p><code>YAML</code>格式要对齐</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          color: Colors.lightBlue,</span><br><span class="line">          child: Image.asset(<span class="string">&#x27;images/bg.jpg&#x27;</span>),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>使用<code>assets</code>构造器加载</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16493438680106e05e5b6d944ca20128dcec4ab4d6774.png" alt="" style="zoom:80%;" /><h4 id="1-2-2-网络图片"><a class="header-anchor" href="#1-2-2-网络图片">¶</a>1.2.2. 网络图片</h4><p>使用<code>network</code>构造器实现网络图片加载</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          color: Colors.lightBlue,</span><br><span class="line">          width: <span class="number">300</span>,</span><br><span class="line">          height: <span class="number">300</span>,</span><br><span class="line">          child: Image.network(</span><br><span class="line">            <span class="string">&#x27;https://i0.hdslb.com/bfs/archive/ca375eb31fa90b8e23b88ed3433c2f60de1c2e6e.png&#x27;</span>,</span><br><span class="line">          ),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16492574445821649257443735.png" alt="" style="zoom:80%;" /><blockquote><p>组件还是要在具体场景使用中积累，**“每周组件”**的视频和组件API文档才是最有用的</p></blockquote><br/><p><a href="https://api.flutter.dev/flutter/widgets/widgets-library.html">Flutter组件库文档（https://api.flutter.dev/flutter/widgets/widgets-library.html）</a></p><p><a href="https://youtu.be/c1xLMaTUWCY">每日一组件（https://youtu.be/c1xLMaTUWCY）https://youtu.be/c1xLMaTUWCY）</a></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Widget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter学习笔记（二）</title>
      <link href="/2022/04/05/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/04/05/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>Flutter学习笔记（二）</h1><h2 id="1-概述"><a class="header-anchor" href="#1-概述">¶</a>1. 概述</h2><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490749945651649074994467.png" alt="" style="zoom:50%;" /><p>Flutter中其实提供很多种类的内置组件，既涉及有状态的，也涉及无状态的，使用这些组件进行组合，很快能够完成界面布局的搭建工作</p><br/><h2 id="2-容器类"><a class="header-anchor" href="#2-容器类">¶</a>2. 容器类</h2><p>容器自然是要可以将其他组件放在自己的内部的，有点像Android里面的<code>ViewGroup</code>或者HTML里面的<code>&lt;div&gt;</code></p><h3 id="2-1-Container"><a class="header-anchor" href="#2-1-Container">¶</a>2.1. Container</h3><p><code>Container</code>组件的主要作用是将其他组件<strong>打包</strong>，以便于整体进行修饰或定位</p><p>可以将这里的<code>Container</code>看做是Android里的某一种布局</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          color: Colors.greenAccent,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490838940271649083893967.png" alt=""></p><p>这里只包含一个<code>Text</code>组件，并且设置了容器的背景色，在默认情况下，<code>Container</code>的大小会根据内容的大小自适应，可以看做是Android中的<code>wrap_content</code></p><br/><p>当然，内边距的<code>padding</code>的效果也别无二致</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          color: Colors.greenAccent,</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">20.0</span>),   <span class="comment">// 添加内边距</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490841665651649084166405.png" alt=""></p><p><code>EdgeInsets.all()</code>从外表大致能猜出来是四周都设置为相同的指定边距</p><br/><p>使用<code>margin</code>属性无疑是添加组件四周的外边距的设置</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          color: Colors.greenAccent,</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">          margin: EdgeInsets.all(<span class="number">10.0</span>),    <span class="comment">// 添加外边距，当然，这里也是四周一起加了</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490843445651649084343570.png" alt=""></p><br/><p><strong>装饰器</strong>可以用来在容器内部添加一个图形</p><blockquote><p>注意：</p><p>装饰器不可与color属性共存</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">          margin: EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">          decoration: BoxDecoration(      <span class="comment">// 添加装饰器，同时去掉color属性，否则会报错</span></span><br><span class="line">            shape: BoxShape.circle,</span><br><span class="line">            color: Colors.lightBlueAccent</span><br><span class="line">          ),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490848415681649084840871.png" alt=""></p><p>这样看起来显然不好看，<strong>装饰器的大小默认受制于整个容器的大小</strong>，而容器的大小又是被内部的子组件撑起来的，那么在有限的空间里只能允许这么大的圆</p><p>因为装饰器在<code>Container</code>内部，因此只要增加一些<code>padding</code>，这样就有更多空间“发育”</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490855485651649085547838.png" alt=""></p><br/><p><strong>对齐属性</strong>，作用于<code>Container</code>的子级组件</p><blockquote><p>注意：</p><p>该属性直接设置后当前容器会直接铺满父容器，感觉这一点很奇怪，可能是因为本身默认情况下自适应，没有办法体现该属性的效果吧，但这就改变自己用于体现这种效果吗，这个组件的表现欲也太强了😂</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          color: Colors.amber,</span><br><span class="line">          alignment: Alignment.topLeft,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490867335671649086732861.png" alt=""></p><p>当然，也可以通过指定宽高或者进行布局约束覆盖该效果</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          color: Colors.amber,</span><br><span class="line">          alignment: Alignment.topLeft,</span><br><span class="line">          width: <span class="number">200</span>,</span><br><span class="line">          height: <span class="number">100</span>,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490869365741649086936336.png" alt=""></p><h3 id="2-2-Padding"><a class="header-anchor" href="#2-2-Padding">¶</a>2.2. Padding</h3><p>注意，这里的<code>Padding</code>不是一个属性，而是一个组件</p><br/><p>简单了解一下之前提到的<code>EdgeInsets</code></p><p>它是抽象类<code>EdgeInsetsGeometry</code>的子类，可以用来描述组件各个方向上的距离</p><br/><p><code>Padding</code>组件实际上与<code>Container</code>的<code>padding</code>属性差不多，但是更加<strong>专一和轻量</strong></p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491234345651649123433576.png" alt="" style="zoom:70%;" /><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Padding(</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">          child: Container(</span><br><span class="line">            color: Colors.deepPurple,</span><br><span class="line">            child: Text(<span class="string">&#x27;一切皆为组件&#x27;</span>),</span><br><span class="line">          )</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491233175681649123317120.png" alt=""></p><h3 id="2-3-Align"><a class="header-anchor" href="#2-3-Align">¶</a>2.3. Align</h3><p><code>Align</code>组件重点描述的是父子组件之间的关系，<strong>子组件相对于父组件的位置</strong></p><blockquote><p>注意：</p><p>这里在使用<code>Align</code>组件时和之前<code>Container</code>的<code>alignment</code>属性有相似之处，父级都会自己扩展范围</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">         color: Colors.lightBlue,</span><br><span class="line">         child: Align(</span><br><span class="line">           alignment: Alignment.topLeft,</span><br><span class="line">           child: Text(<span class="string">&#x27;一切皆组件&#x27;</span>),</span><br><span class="line">         ),</span><br><span class="line">       )</span><br></pre></td></tr></table></figure><p>这里设置文本组件位于父级组件的左上角，可以想象父级组件会默认为父级的大小，然后将子级组件放到左上角（因为没有指定大小）</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491240515661649124051139.png" alt=""></p><p>除了代码枚举的几个预设的位置，还可以通过<strong>校准值</strong>进行指定</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491242135651649124213167.png" alt="" style="zoom:50%;" /><p><code>Align</code>组件在定义中将一个组件在水平方向和垂直方向，水平方向上组件从左至划分为为-1 ~ 1，垂直方向上组件从上到下划分为-1 ~ 1</p><p>当然，范围可以超出，只是不在组件范围内了</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          color: Colors.lightBlue,</span><br><span class="line">          child: Align(</span><br><span class="line">            alignment: Alignment(<span class="number">0.5</span>, <span class="number">0.5</span>),</span><br><span class="line">            child: Text(<span class="string">&#x27;一切皆组件&#x27;</span>),</span><br><span class="line">          )</span><br></pre></td></tr></table></figure><p>这样可以将对齐控制得更加精确</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491253045671649125303770.png" alt="" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NDK（入门）</title>
      <link href="/2022/04/04/NDK%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/"/>
      <url>/2022/04/04/NDK%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>NDK（入门）</h1><h2 id="1-使用目的"><a class="header-anchor" href="#1-使用目的">¶</a>1. 使用目的</h2><ul><li>进一步提升设备性能，以降低延迟或运行游戏或物理模拟等计算密集型应用</li><li>重复使用您自己或其他开发者的 C 或 C++ 库</li></ul><p>Android Studio原生库编译默认使用<code>CMake</code>，同时也支持<code>ndk-build</code></p><h2 id="2-准备工作"><a class="header-anchor" href="#2-准备工作">¶</a>2. 准备工作</h2><ul><li>NDK：允许在Android中使用C/C++</li><li>CMake：外部构建工具，如果使用<code>ndk-build</code>，可以不需要</li><li>LLDB：原生代码调试工具，默认AS自带</li></ul><p>先进到<code>SDK Manager</code>准备一下对应的工具</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490380341231649038033292.png" alt="" style="zoom:70%;" /><br/><h2 id="3-添加原生代码"><a class="header-anchor" href="#3-添加原生代码">¶</a>3. 添加原生代码</h2><h3 id="3-1-创建原生源代码文件"><a class="header-anchor" href="#3-1-创建原生源代码文件">¶</a>3.1. 创建原生源代码文件</h3><p>首先，创建项目时选择<code>Native C++</code>类型</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490391141311649039113214.png" alt="" style="zoom:70%;" /><p>选择默认的工具链，这样可以使用默认的<code>CMake</code>配置</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490392661221649039265481.png" alt="" style="zoom:70%;" /><p>新的项目创建完成后，使用Android视图查看一下项目文件结构，会发现出现了一个<code>cpp</code>目录，<code>CMakeLists.txt</code>代表<code>CMake</code>的构建脚本，而另一个.cpp文件是示例代码</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490400261281649040025617.png" alt=""></p><blockquote><p><strong>简要分析示例</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_minos_nativedemo_MainActivity_stringFromJNI(</span><br><span class="line">        JNIEnv* env,</span><br><span class="line">        jobject /* this */) &#123;</span><br><span class="line">    std::string hello = &quot;Hello from C++&quot;;</span><br><span class="line">    return env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是示例.cpp的代码，可以看到顶部包含了<code>jni</code>框架的头文件，下面声明的就是<code>stringFromJNI()</code>函数，大致的意思就是将该函数对外暴露，提供给Java调用</p><br/><p>再看下<code>CMakeLists.txt</code>中的内容</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Creates and names a library, sets it as either STATIC</span><br><span class="line"># or SHARED, and provides the relative paths to its source code.</span><br><span class="line"># You can define multiple libraries, and CMake builds them for you.</span><br><span class="line"># Gradle automatically packages shared libraries with your APK.</span><br><span class="line"></span><br><span class="line">add_library( # Sets the name of the library.</span><br><span class="line">        nativedemo</span><br><span class="line"></span><br><span class="line">        # Sets the library as a shared library.</span><br><span class="line">        SHARED</span><br><span class="line"></span><br><span class="line">        # Provides a relative path to your source file(s).</span><br><span class="line">        native-lib.cpp)</span><br></pre></td></tr></table></figure><p>就像注释里描述的那样，根据源文件的路径生成库，Gradle自动打包时会一同放入apk中</p><br/><p>然后来看看使用的地方，在MainActivity中会使用到里面的方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="comment">// Used to load the &#x27;nativedemo&#x27; library on application startup.</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;nativedemo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是初始化，放在了Activity的初始化块中，这样在应用启动时就可以调用<code>System.loadLibrary()</code>方法根据库的名称将库加载进来</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A native method that is implemented by the &#x27;nativedemo&#x27; native library,</span></span><br><span class="line"><span class="comment"> * which is packaged with this application.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">external</span> <span class="function"><span class="keyword">fun</span> <span class="title">stringFromJNI</span><span class="params">()</span></span>: String</span><br></pre></td></tr></table></figure><p>这里是对于<code>JNI</code>方法的声明，在加载完库之后，就可以从中取它了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">    binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example of a call to a native method</span></span><br><span class="line">        binding.sampleText.text = stringFromJNI()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用<code>ViewBinding</code>进行布局元素的操作，调用<code>stringFromJNI()</code>返回字符串，然后将内容显示到布局上</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490541765681649054175831.png" alt="" style="zoom:50%;" /><br/><p>整体流程大致是：</p><ul><li>Gradle调用<code>CMakeLists.txt</code></li><li><code>CMake</code>按照构建脚本中的命令将.cpp编译到共享对象库中，并命名为<code>xxx.so</code>，Gradle之后会将其一同打包到apk中（包分析器可以看到）</li></ul><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490545195721649054519114.png" alt="" style="zoom:70%;" /><ul><li>运行时，MainActivity调用<code>System.loadLibrary()</code>加载原生库</li><li>在<code>onCreate()</code>中MainActivity调用<code>stringFromJNI()</code></li></ul><br/><blockquote><p>开始自定义</p></blockquote><p>首先需要在当前模块下有一个专门的cpp目录</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490550415661649055041171.png" alt="" style="zoom:70%;" /><p>大概是这样的层次结构，模块 &gt; src &gt; main &gt; <strong>cpp</strong></p><br/><p>然后在该目录下放置C++的源代码文件</p><p>接下来就是代码逻辑的编写，去实现我们需要的功能</p><br/><h3 id="3-2-配置CMake"><a class="header-anchor" href="#3-2-配置CMake">¶</a>3.2. 配置CMake</h3><p><code>CMake</code>的构建脚本文件<code>CMakeLists.txt</code>是一个<strong>纯文本文件</strong>，并且使用它必须指定文件的名称为<strong>CMakeLists.txt</strong></p><br/><p>然后需要向其中添加一些需要用到的命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10.2)</span><br></pre></td></tr></table></figure><p>这个命令是设置了构建的最小版本，也就是下限</p><br/><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_library(</span><br><span class="line">  nativedemo</span><br><span class="line">  SHARED</span><br><span class="line">  native-lib.cpp)</span><br></pre></td></tr></table></figure><p>这里给出库的名称、类型、对应的源文件路径</p><blockquote><p><strong>注意</strong></p><p>so库的名称总是以lib&lt;CMake中定义的库名称&gt;.so出现，但是使用System.loadLibrary()时还是使用CMake中定义的名称</p></blockquote><br/><h3 id="3-3-提供CMake脚本文件的路径配置Gradle"><a class="header-anchor" href="#3-3-提供CMake脚本文件的路径配置Gradle">¶</a>3.3. 提供CMake脚本文件的路径配置Gradle</h3><p>实现Gradle关联<code>CMake</code>打包，需要在当前模块的<code>build.gradle</code>中进行一些配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">··android &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        externalNativeBuild &#123;</span><br><span class="line">            cmake &#123;</span><br><span class="line">                cppFlags <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            path file(<span class="string">&#x27;src/main/cpp/CMakeLists.txt&#x27;</span>)</span><br><span class="line">            version <span class="string">&#x27;3.10.2&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到需要<code>externalNativeBuild</code>块进行相关配置</p><br/><p>外层的主要用于与Gradle建立连接，而<code>defaultConfog</code>块内层的则进行一些可选的配置项</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter学习笔记（一）</title>
      <link href="/2022/04/03/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/04/03/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>Flutter学习笔记（一）</h1><p>Flutter的官方文档提供了一个理念——<strong>“一切皆为Widget”</strong></p><p>由此可以看得出来<code>Widget</code>在Flutter中的重要地位</p><h2 id="1-Widget是什么？"><a class="header-anchor" href="#1-Widget是什么？">¶</a>1. Widget是什么？</h2><p><code>Widget</code>我们将其理解为<strong>组件</strong>，一个应用的界面往往都比较丰富，上面会有各式各样的组件，像图片、按钮、播放器这些都可以称为组件。</p><p>由于之前自己接触过<code>React</code>的开发，因此我认为，这里的组件就相当于程序中的一个对象，它具有<strong>专门</strong>的功能，与用户进行交互，处理相应的数据，就像你打开<code>Material Design</code>组件库一样，里面各个组件都扮演着特定的角色，为了某一种特定的功能而存在。</p><p>打个更加贴近生活的比方，我们刚搬进新家，而空荡荡的屋子就是我们原始的空白界面，然而我们的日常生活总是需要各种工具或者是家具来满足我们的需要，那么这种需要就相当于是组件所需要具备的功能，每个工具或者家具只是<strong>专门负责某一方面的功能</strong>，此时，在我看来，就可以将家具或工具理解为程序意义上的组件，同时，这些组件的摆放和搭配也形成了界面上丰富多彩的布局。</p><h2 id="2-Widget有哪些？"><a class="header-anchor" href="#2-Widget有哪些？">¶</a>2. Widget有哪些？</h2><ul><li>无状态组件（Stateless Widget）</li><li>有状态组件（Stateful Widget）</li></ul><p>可以将组件根据状态特点分为两个大类</p><h3 id="2-1-无状态组件"><a class="header-anchor" href="#2-1-无状态组件">¶</a>2.1. 无状态组件</h3><p><code>StatelessWidget</code>类直接继承于<code>Widget</code>类</p><p>无状态组件具体做些什么事呢？它的任务很简单，仅仅是将需要展示的内容进行呈现，而后就躺平了。</p><p><code>StatelessWidget</code>是一个抽象类，需要重写抽象方法<code>build()</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> TextButton(</span><br><span class="line">      onPressed: () =&gt; &#123;&#125;,</span><br><span class="line">      child: <span class="keyword">const</span> Text(<span class="string">&#x27;Flutter&#x27;</span>)</span><br><span class="line">      ,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>简单使用一个<code>TextButton</code>的内置组件构成第一个无状态组件的内容，在<code>build</code>方法中返回需要展示的<code>Widget</code>对象</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204031715214.png" alt="image-20220403171552181" style="zoom:40%;" /><h3 id="2-2-有状态组件"><a class="header-anchor" href="#2-2-有状态组件">¶</a>2.2. 有状态组件</h3><p>无状态组件似乎看起来挺简单的，接下来关注一下有状态组件，它能够实现组件状态的切换。</p><p>有状态组件需要继承自<code>StatefulWidget</code>类，另外，由于其需要对状态进行操作，还会涉及到<code>State</code>类</p><p>首先，先定义一个继承于<code>StatefulWidget</code>类的组件，并且重写<code>createState()</code>方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> text = <span class="string">&#x27;空空如也&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _AnotherWidgetState createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _AnotherWidgetState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给出text作为一个组件的属性，用于显示文本</p><p><code>State</code>类是一个抽象类，<code>createState()</code>需要返回一个状态，因此，专门为该组件设置一个状态类</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnotherWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnotherWidget</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> textState = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化状态</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    textState = widget.text;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定义一个函数来更新状态</span></span><br><span class="line">  <span class="keyword">void</span> _changeText(<span class="built_in">String</span> s) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      textState = s;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> TextButton(</span><br><span class="line">        onPressed: () =&gt; _changeText(<span class="string">&#x27;内有玄机&#x27;</span>),</span><br><span class="line">        child: Text(textState)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义该组件的状态，让其继承<code>State</code>类，使用泛型让它和对应的组件间建立联系</p><p>而后对应的泛型会被赋给<code>State</code>的成员<code>widget</code>上，通过该成员便可以获取之前定义的组件上的text属性</p><p>重写<code>initState()</code>方法对状态进行初始化的赋值操作，这里使用textState记录状态</p><p><code>setState()</code>则是用来更新状态的，在这里就是将变量进行修改</p><p><code>build()</code>就像之前无状态组件里的一样，用于呈现组件，利用其<code>onPressed</code>属性，监听点击，触发状态修改</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204032037870.png" alt="image-20220403203721828" style="zoom:50%;" /><img src="/Users/shenzhisheng/Library/Application Support/typora-user-images/image-20220403203810971.png" alt="image-20220403203810971" style="zoom:50%;" /></p><p>这样，通过对于变量textState的修改，更新了UI的文本显示</p><h2 id="3-几个重要的方法"><a class="header-anchor" href="#3-几个重要的方法">¶</a>3. 几个重要的方法</h2><h3 id="3-1-setState"><a class="header-anchor" href="#3-1-setState">¶</a>3.1. setState()</h3><p>在有状态组件中，通过数据的变更来触发UI的改变，<code>setState()</code>方法就是用来操作状态的，它所起到的作用就是<strong>触发组件树的重建，并且将新的状态数据更新到组件上</strong></p><p>基于上面的代码，也就是说，按下按钮触发<code>_changeText(String s)</code>方法，从而调用内部的`setState() 通知关联的组件进行重建，以呈现新的状态</p><h3 id="3-2-initState"><a class="header-anchor" href="#3-2-initState">¶</a>3.2. initState()</h3><p>这是组件状态对象中第一个被调用的方法，正如其名字一样，主要进行一些状态初始化的操作，属于状态生命周期里的内容</p><h2 id="3-3-dispose"><a class="header-anchor" href="#3-3-dispose">¶</a>3.3. dispose()</h2><p>与<code>initState()</code>相对应，在状态生命周期结束前调用，主要用于释放资源</p><h2 id="3-4-build"><a class="header-anchor" href="#3-4-build">¶</a>3.4. build()</h2><p>在无状态组件和有状态组件的状态类中都有它的踪影</p><p>组件通过组合往往会形成更加复杂的组件，将组件呈现出来的过程总是离不开“套娃”。其实这也是对应了<strong>组件树</strong>的概念</p><p><code>build()</code>返回的<code>Widget</code>其实是最外层的组件，因为将里面的内容相当于打了个包，这样便将整个需要显示的内容都准备好了</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>视图绑定</title>
      <link href="/2022/04/02/%E8%A7%86%E5%9B%BE%E7%BB%91%E5%AE%9A/"/>
      <url>/2022/04/02/%E8%A7%86%E5%9B%BE%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h1>ViewBinding</h1><h2 id="1-准备工作"><a class="header-anchor" href="#1-准备工作">¶</a>1. 准备工作</h2><p>首先需要在模块中启用“视图绑定”，在模块对应的<code>build.gradle</code>中添加配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdk <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    viewBinding &#123;</span><br><span class="line">        enabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后项目就下载了对应依赖</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/WechatIMG9.png" alt="WechatIMG9"></p><p>启用完成后，系统会为该模块下的所有布局XML文件生成一个<strong>与之对应的绑定类</strong></p><br/><h2 id="2-绑定类"><a class="header-anchor" href="#2-绑定类">¶</a>2. 绑定类</h2><p>布局XML中会有一些组件设置id属性，这些属性在对应的绑定类中可以直接通过id来获取，这些控件相当于类的成员，根组件和其他有id的组件的引用都包含其实例之中</p><br/><h3 id="2-1-命名方式"><a class="header-anchor" href="#2-1-命名方式">¶</a>2.1. 命名方式</h3><p>绑定类会以“Binding”结尾，采用大驼峰</p><h3 id="2-2-根视图"><a class="header-anchor" href="#2-2-根视图">¶</a>2.2. 根视图</h3><p>可以通过<code>getRoot()</code>获取对于布局文件中根视图的引用</p><br/><h2 id="3-使用"><a class="header-anchor" href="#3-使用">¶</a>3. 使用</h2><h3 id="3-1-Activity中"><a class="header-anchor" href="#3-1-Activity中">¶</a>3.1. Activity中</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="comment">// 调用绑定类的inflate静态方法，对象实例化</span></span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        <span class="comment">// 获取根布局</span></span><br><span class="line">        <span class="keyword">val</span> view = binding.root</span><br><span class="line">        setContentView(view)</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure><p>然后就可以通过绑定类的实例去操作布局文件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">binding.run &#123;</span><br><span class="line">            ivLogo.setImageResource(R.drawable.ic_launcher_background)</span><br><span class="line">            tvContent.setText(R.string.app_name)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-Fragment中"><a class="header-anchor" href="#3-2-Fragment中">¶</a>3.2. Fragment中</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: FragmentBlankBinding</span><br><span class="line"></span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View &#123;</span><br><span class="line">        binding = FragmentBlankBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> binding.root</span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure><p>同样得到了布局文件绑定类的实例，然后可以使用其中的引用去操作布局中的组件</p><p><strong>在Fragment中，由于其视图的生命周期短于Fragment自身的生命周期，因此需要在<code>onDestroyView()</code>中清除对绑定类实例的引用</strong></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/29/hello-world/"/>
      <url>/2022/03/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2><h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
