<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Flutter学习笔记（二）</title>
      <link href="/2022/04/05/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/04/05/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Flutter学习笔记（二）"><a href="#Flutter学习笔记（二）" class="headerlink" title="Flutter学习笔记（二）"></a>Flutter学习笔记（二）</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490749945651649074994467.png" alt="" style="zoom:50%;" /><p>Flutter中其实提供很多种类的内置组件，既涉及有状态的，也涉及无状态的，使用这些组件进行组合，很快能够完成界面布局的搭建工作</p><br/><h2 id="2-容器类"><a href="#2-容器类" class="headerlink" title="2. 容器类"></a>2. 容器类</h2><p>容器自然是要可以将其他组件放在自己的内部的，有点像Android里面的<code>ViewGroup</code>或者HTML里面的<code>&lt;div&gt;</code></p><h3 id="2-1-Container"><a href="#2-1-Container" class="headerlink" title="2.1. Container"></a>2.1. Container</h3><p><code>Container</code>组件的主要作用是将其他组件<strong>打包</strong>，以便于整体进行修饰或定位</p><p>可以将这里的<code>Container</code>看做是Android里的某一种布局</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          color: Colors.greenAccent,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490838940271649083893967.png"></p><p>这里只包含一个<code>Text</code>组件，并且设置了容器的背景色，在默认情况下，<code>Container</code>的大小会根据内容的大小自适应，可以看做是Android中的<code>wrap_content</code></p><br/><p>当然，内边距的<code>padding</code>的效果也别无二致</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          color: Colors.greenAccent,</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">20.0</span>),   <span class="comment">// 添加内边距</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490841665651649084166405.png"></p><p><code>EdgeInsets.all()</code>从外表大致能猜出来是四周都设置为相同的指定边距</p><br/><p>使用<code>margin</code>属性无疑是添加组件四周的外边距的设置</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          color: Colors.greenAccent,</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">          margin: EdgeInsets.all(<span class="number">10.0</span>),    <span class="comment">// 添加外边距，当然，这里也是四周一起加了</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490843445651649084343570.png"></p><br/><p><strong>装饰器</strong>可以用来在容器内部添加一个图形</p><blockquote><p>注意：</p><p>装饰器不可与color属性共存</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">          margin: EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">          decoration: BoxDecoration(      <span class="comment">// 添加装饰器，同时去掉color属性，否则会报错</span></span><br><span class="line">            shape: BoxShape.circle,</span><br><span class="line">            color: Colors.lightBlueAccent</span><br><span class="line">          ),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490848415681649084840871.png"></p><p>这样看起来显然不好看，<strong>装饰器的大小默认受制于整个容器的大小</strong>，而容器的大小又是被内部的子组件撑起来的，那么在有限的空间里只能允许这么大的圆</p><p>因为装饰器在<code>Container</code>内部，因此只要增加一些<code>padding</code>，这样就有更多空间“发育”</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490855485651649085547838.png"></p><br/><p><strong>对齐属性</strong>，作用于<code>Container</code>的子级组件</p><blockquote><p>注意：</p><p>该属性直接设置后当前容器会直接铺满父容器，感觉这一点很奇怪，可能是因为本身默认情况下自适应，没有办法体现该属性的效果吧，但这就改变自己用于体现这种效果吗，这个组件的表现欲也太强了:joy:</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          color: Colors.amber,</span><br><span class="line">          alignment: Alignment.topLeft,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490867335671649086732861.png"></p><p>当然，也可以通过指定宽高或者进行布局约束覆盖该效果</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          color: Colors.amber,</span><br><span class="line">          alignment: Alignment.topLeft,</span><br><span class="line">          width: <span class="number">200</span>,</span><br><span class="line">          height: <span class="number">100</span>,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490869365741649086936336.png"></p><h3 id="2-2-Padding"><a href="#2-2-Padding" class="headerlink" title="2.2. Padding"></a>2.2. Padding</h3><p>注意，这里的<code>Padding</code>不是一个属性，而是一个组件</p><br/><p>简单了解一下之前提到的<code>EdgeInsets</code></p><p>它是抽象类<code>EdgeInsetsGeometry</code>的子类，可以用来描述组件各个方向上的距离</p><br/><p><code>Padding</code>组件实际上与<code>Container</code>的<code>padding</code>属性差不多，但是更加<strong>专一和轻量</strong></p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491234345651649123433576.png" alt="" style="zoom:70%;" /><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Padding(</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">          child: Container(</span><br><span class="line">            color: Colors.deepPurple,</span><br><span class="line">            child: Text(<span class="string">&#x27;一切皆为组件&#x27;</span>),</span><br><span class="line">          )</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491233175681649123317120.png"></p><h3 id="2-3-Align"><a href="#2-3-Align" class="headerlink" title="2.3. Align"></a>2.3. Align</h3><p><code>Align</code>组件重点描述的是父子组件之间的关系，<strong>子组件相对于父组件的位置</strong></p><blockquote><p>注意：</p><p>这里在使用<code>Align</code>组件时和之前<code>Container</code>的<code>alignment</code>属性有相似之处，父级都会自己扩展范围</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">         color: Colors.lightBlue,</span><br><span class="line">         child: Align(</span><br><span class="line">           alignment: Alignment.topLeft,</span><br><span class="line">           child: Text(<span class="string">&#x27;一切皆组件&#x27;</span>),</span><br><span class="line">         ),</span><br><span class="line">       )</span><br></pre></td></tr></table></figure><p>这里设置文本组件位于父级组件的左上角，可以想象父级组件会默认为父级的大小，然后将子级组件放到左上角（因为没有指定大小）</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491240515661649124051139.png"></p><p>除了代码枚举的几个预设的位置，还可以通过<strong>校准值</strong>进行指定</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491242135651649124213167.png" alt="" style="zoom:50%;" /><p><code>Align</code>组件在定义中将一个组件在水平方向和垂直方向，水平方向上组件从左至划分为为-1 ~ 1，垂直方向上组件从上到下划分为-1 ~ 1</p><p>当然，范围可以超出，只是不在组件范围内了</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          color: Colors.lightBlue,</span><br><span class="line">          child: Align(</span><br><span class="line">            alignment: Alignment(<span class="number">0.5</span>, <span class="number">0.5</span>),</span><br><span class="line">            child: Text(<span class="string">&#x27;一切皆组件&#x27;</span>),</span><br><span class="line">          )</span><br></pre></td></tr></table></figure><p>这样可以将对齐控制得更加精确</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491253045671649125303770.png" alt="" style="zoom:50%;" />]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NDK（入门）</title>
      <link href="/2022/04/04/NDK%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/"/>
      <url>/2022/04/04/NDK%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="NDK（入门）"><a href="#NDK（入门）" class="headerlink" title="NDK（入门）"></a>NDK（入门）</h1><h2 id="1-使用目的"><a href="#1-使用目的" class="headerlink" title="1. 使用目的"></a>1. 使用目的</h2><ul><li>进一步提升设备性能，以降低延迟或运行游戏或物理模拟等计算密集型应用</li><li>重复使用您自己或其他开发者的 C 或 C++ 库</li></ul><p>Android Studio原生库编译默认使用<code>CMake</code>，同时也支持<code>ndk-build</code></p><h2 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h2><ul><li>NDK：允许在Android中使用C&#x2F;C++</li><li>CMake：外部构建工具，如果使用<code>ndk-build</code>，可以不需要</li><li>LLDB：原生代码调试工具，默认AS自带</li></ul><p>先进到<code>SDK Manager</code>准备一下对应的工具</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490380341231649038033292.png" alt="" style="zoom:70%;" /><br/><h2 id="3-添加原生代码"><a href="#3-添加原生代码" class="headerlink" title="3. 添加原生代码"></a>3. 添加原生代码</h2><h3 id="3-1-创建原生源代码文件"><a href="#3-1-创建原生源代码文件" class="headerlink" title="3.1. 创建原生源代码文件"></a>3.1. 创建原生源代码文件</h3><p>首先，创建项目时选择<code>Native C++</code>类型</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490391141311649039113214.png" alt="" style="zoom:70%;" /><p>选择默认的工具链，这样可以使用默认的<code>CMake</code>配置</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490392661221649039265481.png" alt="" style="zoom:70%;" /><p>新的项目创建完成后，使用Android视图查看一下项目文件结构，会发现出现了一个<code>cpp</code>目录，<code>CMakeLists.txt</code>代表<code>CMake</code>的构建脚本，而另一个.cpp文件是示例代码</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490400261281649040025617.png"></p><blockquote><p><strong>简要分析示例</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_minos_nativedemo_MainActivity_stringFromJNI(</span><br><span class="line">        JNIEnv* env,</span><br><span class="line">        jobject /* this */) &#123;</span><br><span class="line">    std::string hello = &quot;Hello from C++&quot;;</span><br><span class="line">    return env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是示例.cpp的代码，可以看到顶部包含了<code>jni</code>框架的头文件，下面声明的就是<code>stringFromJNI()</code>函数，大致的意思就是将该函数对外暴露，提供给Java调用</p><br/><p>再看下<code>CMakeLists.txt</code>中的内容</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Creates and names a library, sets it as either STATIC</span><br><span class="line"># or SHARED, and provides the relative paths to its source code.</span><br><span class="line"># You can define multiple libraries, and CMake builds them for you.</span><br><span class="line"># Gradle automatically packages shared libraries with your APK.</span><br><span class="line"></span><br><span class="line">add_library( # Sets the name of the library.</span><br><span class="line">        nativedemo</span><br><span class="line"></span><br><span class="line">        # Sets the library as a shared library.</span><br><span class="line">        SHARED</span><br><span class="line"></span><br><span class="line">        # Provides a relative path to your source file(s).</span><br><span class="line">        native-lib.cpp)</span><br></pre></td></tr></table></figure><p>就像注释里描述的那样，根据源文件的路径生成库，Gradle自动打包时会一同放入apk中</p><br/><p>然后来看看使用的地方，在MainActivity中会使用到里面的方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="comment">// Used to load the &#x27;nativedemo&#x27; library on application startup.</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;nativedemo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是初始化，放在了Activity的初始化块中，这样在应用启动时就可以调用<code>System.loadLibrary()</code>方法根据库的名称将库加载进来</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A native method that is implemented by the &#x27;nativedemo&#x27; native library,</span></span><br><span class="line"><span class="comment"> * which is packaged with this application.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">external</span> <span class="function"><span class="keyword">fun</span> <span class="title">stringFromJNI</span><span class="params">()</span></span>: String</span><br></pre></td></tr></table></figure><p>这里是对于<code>JNI</code>方法的声明，在加载完库之后，就可以从中取它了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">    binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example of a call to a native method</span></span><br><span class="line">        binding.sampleText.text = stringFromJNI()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用<code>ViewBinding</code>进行布局元素的操作，调用<code>stringFromJNI()</code>返回字符串，然后将内容显示到布局上</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490541765681649054175831.png" alt="" style="zoom:50%;" /><br/><p>整体流程大致是：</p><ul><li>Gradle调用<code>CMakeLists.txt</code></li><li><code>CMake</code>按照构建脚本中的命令将.cpp编译到共享对象库中，并命名为<code>xxx.so</code>，Gradle之后会将其一同打包到apk中（包分析器可以看到）</li></ul><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490545195721649054519114.png" alt="" style="zoom:70%;" /><ul><li>运行时，MainActivity调用<code>System.loadLibrary()</code>加载原生库</li><li>在<code>onCreate()</code>中MainActivity调用<code>stringFromJNI()</code></li></ul><br/><blockquote><p>开始自定义</p></blockquote><p>首先需要在当前模块下有一个专门的cpp目录</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490550415661649055041171.png" alt="" style="zoom:70%;" /><p>大概是这样的层次结构，模块 &gt; src &gt; main &gt; <strong>cpp</strong></p><br/><p>然后在该目录下放置C++的源代码文件</p><p>接下来就是代码逻辑的编写，去实现我们需要的功能</p><br/><h3 id="3-2-配置CMake"><a href="#3-2-配置CMake" class="headerlink" title="3.2. 配置CMake"></a>3.2. 配置CMake</h3><p><code>CMake</code>的构建脚本文件<code>CMakeLists.txt</code>是一个<strong>纯文本文件</strong>，并且使用它必须指定文件的名称为<strong>CMakeLists.txt</strong></p><br/><p>然后需要向其中添加一些需要用到的命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10.2)</span><br></pre></td></tr></table></figure><p>这个命令是设置了构建的最小版本，也就是下限</p><br/><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_library(</span><br><span class="line">  nativedemo</span><br><span class="line">  SHARED</span><br><span class="line">  native-lib.cpp)</span><br></pre></td></tr></table></figure><p>这里给出库的名称、类型、对应的源文件路径</p><blockquote><p><strong>注意</strong></p><p>so库的名称总是以lib&lt;CMake中定义的库名称&gt;.so出现，但是使用System.loadLibrary()时还是使用CMake中定义的名称</p></blockquote><br/><h3 id="3-3-提供CMake脚本文件的路径配置Gradle"><a href="#3-3-提供CMake脚本文件的路径配置Gradle" class="headerlink" title="3.3. 提供CMake脚本文件的路径配置Gradle"></a>3.3. 提供CMake脚本文件的路径配置Gradle</h3><p>实现Gradle关联<code>CMake</code>打包，需要在当前模块的<code>build.gradle</code>中进行一些配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">··android &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        externalNativeBuild &#123;</span><br><span class="line">            cmake &#123;</span><br><span class="line">                cppFlags <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            path file(<span class="string">&#x27;src/main/cpp/CMakeLists.txt&#x27;</span>)</span><br><span class="line">            version <span class="string">&#x27;3.10.2&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到需要<code>externalNativeBuild</code>块进行相关配置</p><br/><p>外层的主要用于与Gradle建立连接，而<code>defaultConfog</code>块内层的则进行一些可选的配置项</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Flutter学习笔记（一）</title>
      <link href="/2022/04/03/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/04/03/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Flutter学习笔记（一）"><a href="#Flutter学习笔记（一）" class="headerlink" title="Flutter学习笔记（一）"></a>Flutter学习笔记（一）</h1><p>Flutter的官方文档提供了一个理念——<strong>“一切皆为Widget”</strong></p><p>由此可以看得出来<code>Widget</code>在Flutter中的重要地位</p><h2 id="1-Widget是什么？"><a href="#1-Widget是什么？" class="headerlink" title="1. Widget是什么？"></a>1. Widget是什么？</h2><p><code>Widget</code>我们将其理解为<strong>组件</strong>，一个应用的界面往往都比较丰富，上面会有各式各样的组件，像图片、按钮、播放器这些都可以称为组件。</p><p>由于之前自己接触过<code>React</code>的开发，因此我认为，这里的组件就相当于程序中的一个对象，它具有<strong>专门</strong>的功能，与用户进行交互，处理相应的数据，就像你打开<code>Material Design</code>组件库一样，里面各个组件都扮演着特定的角色，为了某一种特定的功能而存在。</p><p>打个更加贴近生活的比方，我们刚搬进新家，而空荡荡的屋子就是我们原始的空白界面，然而我们的日常生活总是需要各种工具或者是家具来满足我们的需要，那么这种需要就相当于是组件所需要具备的功能，每个工具或者家具只是<strong>专门负责某一方面的功能</strong>，此时，在我看来，就可以将家具或工具理解为程序意义上的组件，同时，这些组件的摆放和搭配也形成了界面上丰富多彩的布局。</p><h2 id="2-Widget有哪些？"><a href="#2-Widget有哪些？" class="headerlink" title="2. Widget有哪些？"></a>2. Widget有哪些？</h2><ul><li>无状态组件（Stateless Widget）</li><li>有状态组件（Stateful Widget）</li></ul><p>可以将组件根据状态特点分为两个大类</p><h3 id="2-1-无状态组件"><a href="#2-1-无状态组件" class="headerlink" title="2.1. 无状态组件"></a>2.1. 无状态组件</h3><p><code>StatelessWidget</code>类直接继承于<code>Widget</code>类</p><p>无状态组件具体做些什么事呢？它的任务很简单，仅仅是将需要展示的内容进行呈现，而后就躺平了。</p><p><code>StatelessWidget</code>是一个抽象类，需要重写抽象方法<code>build()</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> TextButton(</span><br><span class="line">      onPressed: () =&gt; &#123;&#125;,</span><br><span class="line">      child: <span class="keyword">const</span> Text(<span class="string">&#x27;Flutter&#x27;</span>)</span><br><span class="line">      ,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>简单使用一个<code>TextButton</code>的内置组件构成第一个无状态组件的内容，在<code>build</code>方法中返回需要展示的<code>Widget</code>对象</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204031715214.png" alt="image-20220403171552181" style="zoom:40%;" /><h3 id="2-2-有状态组件"><a href="#2-2-有状态组件" class="headerlink" title="2.2. 有状态组件"></a>2.2. 有状态组件</h3><p>无状态组件似乎看起来挺简单的，接下来关注一下有状态组件，它能够实现组件状态的切换。</p><p>有状态组件需要继承自<code>StatefulWidget</code>类，另外，由于其需要对状态进行操作，还会涉及到<code>State</code>类</p><p>首先，先定义一个继承于<code>StatefulWidget</code>类的组件，并且重写<code>createState()</code>方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> text = <span class="string">&#x27;空空如也&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _AnotherWidgetState createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _AnotherWidgetState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给出text作为一个组件的属性，用于显示文本</p><p><code>State</code>类是一个抽象类，<code>createState()</code>需要返回一个状态，因此，专门为该组件设置一个状态类</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnotherWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnotherWidget</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> textState = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化状态</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    textState = widget.text;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定义一个函数来更新状态</span></span><br><span class="line">  <span class="keyword">void</span> _changeText(<span class="built_in">String</span> s) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      textState = s;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> TextButton(</span><br><span class="line">        onPressed: () =&gt; _changeText(<span class="string">&#x27;内有玄机&#x27;</span>),</span><br><span class="line">        child: Text(textState)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义该组件的状态，让其继承<code>State</code>类，使用泛型让它和对应的组件间建立联系</p><p>而后对应的泛型会被赋给<code>State</code>的成员<code>widget</code>上，通过该成员便可以获取之前定义的组件上的text属性</p><p>重写<code>initState()</code>方法对状态进行初始化的赋值操作，这里使用textState记录状态</p><p><code>setState()</code>则是用来更新状态的，在这里就是将变量进行修改</p><p><code>build()</code>就像之前无状态组件里的一样，用于呈现组件，利用其<code>onPressed</code>属性，监听点击，触发状态修改</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204032037870.png" alt="image-20220403203721828" style="zoom:50%;" /><img src="/Users/shenzhisheng/Library/Application Support/typora-user-images/image-20220403203810971.png" alt="image-20220403203810971" style="zoom:50%;" /></p><p>这样，通过对于变量textState的修改，更新了UI的文本显示</p><h2 id="3-几个重要的方法"><a href="#3-几个重要的方法" class="headerlink" title="3. 几个重要的方法"></a>3. 几个重要的方法</h2><h3 id="3-1-setState"><a href="#3-1-setState" class="headerlink" title="3.1. setState()"></a>3.1. setState()</h3><p>在有状态组件中，通过数据的变更来触发UI的改变，<code>setState()</code>方法就是用来操作状态的，它所起到的作用就是<strong>触发组件树的重建，并且将新的状态数据更新到组件上</strong></p><p>基于上面的代码，也就是说，按下按钮触发<code>_changeText(String s)</code>方法，从而调用内部的&#96;setState() 通知关联的组件进行重建，以呈现新的状态</p><h3 id="3-2-initState"><a href="#3-2-initState" class="headerlink" title="3.2. initState()"></a>3.2. initState()</h3><p>这是组件状态对象中第一个被调用的方法，正如其名字一样，主要进行一些状态初始化的操作，属于状态生命周期里的内容</p><h2 id="3-3-dispose"><a href="#3-3-dispose" class="headerlink" title="3.3. dispose()"></a>3.3. dispose()</h2><p>与<code>initState()</code>相对应，在状态生命周期结束前调用，主要用于释放资源</p><h2 id="3-4-build"><a href="#3-4-build" class="headerlink" title="3.4. build()"></a>3.4. build()</h2><p>在无状态组件和有状态组件的状态类中都有它的踪影</p><p>组件通过组合往往会形成更加复杂的组件，将组件呈现出来的过程总是离不开“套娃”。其实这也是对应了<strong>组件树</strong>的概念</p><p><code>build()</code>返回的<code>Widget</code>其实是最外层的组件，因为将里面的内容相当于打了个包，这样便将整个需要显示的内容都准备好了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>视图绑定</title>
      <link href="/2022/04/02/%E8%A7%86%E5%9B%BE%E7%BB%91%E5%AE%9A/"/>
      <url>/2022/04/02/%E8%A7%86%E5%9B%BE%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="ViewBinding"><a href="#ViewBinding" class="headerlink" title="ViewBinding"></a>ViewBinding</h1><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>首先需要在模块中启用“视图绑定”，在模块对应的<code>build.gradle</code>中添加配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdk <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    viewBinding &#123;</span><br><span class="line">        enabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后项目就下载了对应依赖</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/WechatIMG9.png" alt="WechatIMG9"></p><p>启用完成后，系统会为该模块下的所有布局XML文件生成一个<strong>与之对应的绑定类</strong></p><br/><h2 id="2-绑定类"><a href="#2-绑定类" class="headerlink" title="2. 绑定类"></a>2. 绑定类</h2><p>布局XML中会有一些组件设置id属性，这些属性在对应的绑定类中可以直接通过id来获取，这些控件相当于类的成员，根组件和其他有id的组件的引用都包含其实例之中</p><br/><h3 id="2-1-命名方式"><a href="#2-1-命名方式" class="headerlink" title="2.1. 命名方式"></a>2.1. 命名方式</h3><p>绑定类会以“Binding”结尾，采用大驼峰</p><h3 id="2-2-根视图"><a href="#2-2-根视图" class="headerlink" title="2.2. 根视图"></a>2.2. 根视图</h3><p>可以通过<code>getRoot()</code>获取对于布局文件中根视图的引用</p><br/><h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h2><h3 id="3-1-Activity中"><a href="#3-1-Activity中" class="headerlink" title="3.1. Activity中"></a>3.1. Activity中</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="comment">// 调用绑定类的inflate静态方法，对象实例化</span></span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        <span class="comment">// 获取根布局</span></span><br><span class="line">        <span class="keyword">val</span> view = binding.root</span><br><span class="line">        setContentView(view)</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure><p>然后就可以通过绑定类的实例去操作布局文件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">binding.run &#123;</span><br><span class="line">            ivLogo.setImageResource(R.drawable.ic_launcher_background)</span><br><span class="line">            tvContent.setText(R.string.app_name)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-Fragment中"><a href="#3-2-Fragment中" class="headerlink" title="3.2. Fragment中"></a>3.2. Fragment中</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: FragmentBlankBinding</span><br><span class="line"></span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View &#123;</span><br><span class="line">        binding = FragmentBlankBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> binding.root</span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure><p>同样得到了布局文件绑定类的实例，然后可以使用其中的引用去操作布局中的组件</p><p><strong>在Fragment中，由于其视图的生命周期短于Fragment自身的生命周期，因此需要在<code>onDestroyView()</code>中清除对绑定类实例的引用</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/29/hello-world/"/>
      <url>/2022/03/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
