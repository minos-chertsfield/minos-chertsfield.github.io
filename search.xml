<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM学习——Java内存区域与内存溢出异常</title>
      <link href="/2023/03/11/JVM%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
      <url>/2023/03/11/JVM%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1>JVM学习——Java内存区域与内存溢出异常</h1><h2 id="1-简介"><a class="header-anchor" href="#1-简介">¶</a>1. 简介</h2><p>在C/C++当中，内存的管理需要由程序员<strong>手动</strong>操作，使用<code>malloc</code>或<code>new</code>创建对象，然后再相对应地调用<code>free</code>或<code>delete</code>对先前分配出去的空间予以释放</p><p>尽管最终C/C++的<strong>执行效率比较高</strong>，但是开发起来会很头疼，因为内存的问题是绕不开的，正所谓<strong>权力越大，责任越大</strong>，内存的操作可得谨慎地多想想</p><p>而在Java当中，<strong>内存的管理交由虚拟机</strong>，也就是JVM负责，而程序员可以好好关注业务逻辑，GC会对空间进行释放，虽然会牺牲一部分性能，但是开发效率提升了很多，而性能方面也可以借助硬件往上怼</p><h2 id="2-运行时数据区域"><a class="header-anchor" href="#2-运行时数据区域">¶</a>2. 运行时数据区域</h2><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202302191721766.webp" alt="img"></p><h3 id="2-1-程序计数器"><a class="header-anchor" href="#2-1-程序计数器">¶</a>2.1. 程序计数器</h3><p><strong>程序计数器</strong>简称<strong>PC</strong>（Program Counter），是一块<strong>较小的内存空间</strong>，将其看做是当前程序所执行的字节码的行号指示器</p><h4 id="2-1-1-作用"><a class="header-anchor" href="#2-1-1-作用">¶</a>2.1.1. 作用</h4><p>Java源文件在<strong>编译成字节码文件</strong>后，丢给JVM执行，<strong>字节码解释器</strong>通过改变PC的值，往下读指令，将指令一条条地取出来执行</p><h4 id="2-1-2-多线程场景"><a class="header-anchor" href="#2-1-2-多线程场景">¶</a>2.1.2. 多线程场景</h4><p>Java在多线程的情况下，<strong>线程会轮流进行切换</strong>，根据各自被分配到的<strong>CPU时间</strong>而定</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202303111311964.png" alt="image-20230311131144297"></p><p><strong>在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令</strong></p><p>线程切换执行后还需要继续从上次的位置继续执行，那么为了能够使其恢复到正确的位置，<strong>每条线程需要独立的PC</strong>（就好像看书的时候放个书签）</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202303111308781.png" alt="image-20230311130752009"></p><p>因而各个线程间的PC是互不影响的，独立地进行存储，这类内存区域也被称为**“线程私有”内存**，就比方说你在你家里呆着，我在我家里呆着，互不影响</p><h4 id="2-1-3-特点"><a class="header-anchor" href="#2-1-3-特点">¶</a>2.1.3. 特点</h4><p>如果当前线程正在执行的是一个<strong>Java方法</strong>，那么PC记录的便是<strong>当前JVM字节码指令的地址</strong>；如果是<strong>Native方法</strong>，那么PC记录的则是<strong>空（Undefined）</strong></p><p><strong>PC是唯一一个在Java虚拟机规范当中没有规定任何OutOfMemoryError情况的内存区域</strong></p><h3 id="2-2-Java虚拟机栈"><a class="header-anchor" href="#2-2-Java虚拟机栈">¶</a>2.2. Java虚拟机栈</h3><p><strong>Java虚拟机栈</strong>（Java Virtual Machine Stacks）是<strong>线程私有</strong>的，其<strong>生命周期</strong>与线程相同</p><p>虚拟机栈描述的是<strong>Java方法执行的内存模型</strong> ：每个方法执行的同时会创建一个<strong>栈帧</strong>（平时使用IDE的断点调试应该都能够看到）</p><h4 id="2-2-1-栈帧"><a class="header-anchor" href="#2-2-1-栈帧">¶</a>2.2.1. 栈帧</h4><p>栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息</p><p>方法开始调用时，会对其入栈，也就是把对应的栈帧往栈中存放，等到方法调用完成，再将方法对应的栈帧从栈中弹出（<strong>对应于栈顶指针的下移</strong>）；因而<strong>方法的调用过程</strong>便对应一个栈帧在虚拟机栈的<strong>入栈与出栈</strong>操作</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202303111319576.png" alt="image-20230311131901681"></p><h4 id="2-2-2-内存划分"><a class="header-anchor" href="#2-2-2-内存划分">¶</a>2.2.2. 内存划分</h4><p>Java的内存远不仅仅是栈空间和堆空间，这只是由于这两块区域与编程人员关系最为密切</p><p>通常意义上所谈到的栈便是<strong>虚拟机栈</strong>，或者说是其中<strong>局部变量表</strong>的部分（开发者Debug项目代码时主要关注的部分）</p><h4 id="2-2-3-局部变量表"><a class="header-anchor" href="#2-2-3-局部变量表">¶</a>2.2.3. 局部变量表</h4><p>局部变量表存放了<strong>编译期可知</strong>的各种基本数据类型、对象引用、returnAddress类型</p><p>64位长度的为<code>long</code>和<code>double</code>类型，<strong>需要占用两个局部变量空间</strong>（Slot），其余的数据类型只占用一个</p><p><strong>局部变量表所需的内存空间在编译期已完成分配</strong>，因而在进入一个方法内部的时候，该方法对应的帧需要分配给局部变量表的空间是已经确定的，并且<strong>在方法的运行期间不会发生改变</strong></p><h4 id="2-2-4-规定异常"><a class="header-anchor" href="#2-2-4-规定异常">¶</a>2.2.4. 规定异常</h4><p><strong>栈溢出</strong>（StackOverflowError）</p><p>当<strong>线程请求的栈的深度超过了虚拟机所能允许的深度</strong>，便会抛出<code>StackOverflowError</code>异常</p><p><strong>OOM</strong>（OutOfMemoryError）</p><p>涉及到虚拟机<strong>动态扩展</strong>（大部分虚拟机都可以支持），如果在扩展的过程中无法申请到足够的内存，将会抛出<code>OutOfMemoryError</code>异常</p><h3 id="2-3-本地方法栈"><a class="header-anchor" href="#2-3-本地方法栈">¶</a>2.3. 本地方法栈</h3><p><strong>本地方法栈</strong>（Native Method Stack）与Java虚拟机栈有很多相似之处，二者主要的区别在于Java虚拟机栈的服务对象是Java方法（也就是字节码），而本地方法栈的服务对象则是<strong>Native方法</strong></p><p>虚拟机的规范中对于本地方法栈的语言、使用方式、数据结构并<strong>没有强制规定</strong>，可以由虚拟机自由实现</p><p>并且，本地方法栈和Java虚拟机栈一样，会抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常</p><h3 id="2-4-Java堆"><a class="header-anchor" href="#2-4-Java堆">¶</a>2.4. Java堆</h3><p><strong>Java堆</strong>（Java Heap）是Java虚拟机所管理的内存中<strong>最大的一块</strong>，<strong>被所有线程共享</strong>，并且<strong>在虚拟机启动的时候进行创建</strong></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202303062335603.png" alt="image-20230306233516594"></p><p>该内存区域<strong>唯一的目的就是用来存放对象实例</strong>，几乎所有的对象实例都在这里分配内存（后期由于栈上分配、标量替换优化技术导致了一些微妙的变化）</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202303062340075.png" alt="image-20230306234005845"></p><p><strong>Java堆是垃圾收集器管理的主要区域</strong>，因此有时也被称为<strong>GC堆</strong></p><p>由于现在的GC基本上采用的都是<strong>分代收集算法</strong>，因此在Java堆中可以进一步细分为<strong>新生代</strong>和<strong>老年代</strong>，也可以继续向下细分为<strong>Eden空间</strong>、<strong>From Survivor空间</strong>、<strong>To Survivor</strong>空间等</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202303062351471.png" alt="image-20230306235101585"></p><p>从内存分配的角度，线程共享的堆当中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），但是存放的东西还是实例，这一点倒是没有变的</p><p>Java堆<strong>可以是物理上不连续的空间，只要逻辑上连续即可</strong>，<strong>既可以是固定大小的，也可以是可扩展的</strong>（当前主流的虚拟机都是按照可扩展来实现的）</p><p>如果当前的堆中没有足够的空间完成实例分配，且无法扩展时，将会抛出<code>OutOfMemoryError</code>异常</p><h3 id="2-5-方法区"><a class="header-anchor" href="#2-5-方法区">¶</a>2.5. 方法区</h3><p><strong>方法区</strong>（Method Area）与Java堆一样，为<strong>各个线程共享的内存区域</strong></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202303072304257.png" alt="image-20230307230422675"></p><p>方法区用于<strong>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202303072313233.png" alt="image-20230307231331414"></p><p>在Java虚拟机的规范中把方法区<strong>描述为堆的一个逻辑部分</strong>，但是其有一个别名，称为 <strong>Non-Heap （非堆）</strong></p><blockquote><p><strong>永久代</strong>是HotSpot虚拟机团队把<strong>GC的分代收集扩展至方法区</strong>而形成方法区的内存管理实现，对其他虚拟机而言并不存在该概念</p></blockquote><p>Java虚拟机规范对方法区的限制非常宽松，<strong>不需要物理连续内存（可以固定大小或者可扩展，与堆一样），还可以选择不实现垃圾收集</strong>；内存区的垃圾收集频率是比较低的，<strong>其回收的主要目标是对常量池的回收和对类型的卸载</strong>，但是很必要</p><p>当方法区无法满足内存分配需求时，将同样抛出<code>OutOfMemoryError</code>异常</p><h3 id="2-6-运行时常量池"><a class="header-anchor" href="#2-6-运行时常量池">¶</a><strong>2.6. 运行时常量池</strong></h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分</p><p>Class文件中除了有类的版本、字段、方法、接口等描述信息，还包括了<strong>常量池</strong>（Constant Pool Table）信息，用于<strong>存放编译期生成的各种字面量和符号引用</strong>，这部分内容在<strong>类加载后会进入方法区的运行时常量池存放</strong></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202303100001569.png" alt="image-20230310000116337"></p><p>Java虚拟机对<strong>Class文件</strong>每一部分（包括常量池）的<strong>格式</strong>都有<strong>严格规定</strong>：每一个字节用于存储什么数据都需要符合规范上的要求才能够得到虚拟机的认可、装载以及执行</p><p>至于运行时常量池，Java虚拟机并<strong>没有做细节层面上的要求</strong>，各个虚拟机提供商可以根据具体的需求进行不同的实现</p><p>除了Class文件中的<strong>符号引用</strong>，还会将翻译出来的<strong>直接引用</strong>存储到<strong>运行时常量池</strong>中</p><p>相对于Class文件常量池，运行时常量池还具有<strong>动态性</strong>，<strong>常量并非仅在编译期才产生</strong>，<strong>运行期</strong>也可以将新的常量放入运行时常量池，如<code>String</code>类的<code>intern()</code></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202303110014169.png" alt="image-20230311000548539"></p><p>由于运行时常量池也还是内存的一部分，因此内存的大小依然会对其形成制约，当无法申请到内存时会抛出<code>OutOfMemoryError</code>异常</p><h3 id="2-7-直接内存"><a class="header-anchor" href="#2-7-直接内存">¶</a>2.7. 直接内存</h3><p>直接内存（Direct Memory） <strong>本身并不是虚拟机运行时数据区的一部分</strong>，也非Java虚拟机规范中定义的内存区域</p><p>但是在实际情况中，这块区域被频繁使用，也会导致<code>OutOfMemoryError</code>异常的出现</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust 探索（三）—— 通用编程概念（下）</title>
      <link href="/2023/03/05/Rust%20%E6%8E%A2%E7%B4%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2023/03/05/Rust%20%E6%8E%A2%E7%B4%A2%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>Rust 探索（三）—— 通用编程概念（下）</h1><p>上篇主要是关于类型、变量等内容的介绍，如果已经学习过其他编程语言，那么这一块并不会有太大难度，或许仅仅是一些关键字的替换</p><p>而且，在了解其中的一些概念的时候，似乎还隐隐约约能够看到一些接触过的其他编程语言的影子，就比如说元组、列表的概念与Python如出一辙，解构赋值的写法让我想到了TypeScript，区分可变、不可变变量以及类型推导的特性又让我联想到Kotlin，或许Rust也有不断地借鉴其他语言设计的优秀之处吧，亦或是这正是代表了语言演进的方向</p><h2 id="1-函数"><a class="header-anchor" href="#1-函数">¶</a>1. 函数</h2><p>函数用来对功能逻辑进行封装，能够增强复用、提高代码的可读</p><p>在Rust中，函数通过<code>fn</code>关键字进行声明，并且函数的名称遵循<strong>蛇形命名法</strong>，即名称使用小写字母进行组合，单词与单词之间使用下划线进行分割，这点倒是和Python中的函数命名相一致</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">make_money</span>() &#123;   <span class="comment">// 蛇形命名法</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;赚钱&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;   <span class="comment">// 作为入口的main()函数</span></span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="title function_ invoke__">make_money</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数名后面的括号放置参数列表、花括号中编写具体的业务逻辑，这些算得上行业通用了</p><p>函数可以先定义或后定义，只要对于使用区域可见即可</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">make_money</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 放在后面也可以</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">make_money</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;赚钱&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-函数参数"><a class="header-anchor" href="#1-1-函数参数">¶</a>1.1. 函数参数</h3><p>函数的参数可以将外部的变化灵活地告诉内部的逻辑，在框架不变的前提下随机应变，作为函数签名的一部分，就像在文档上看到的那样</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202303051003916.png" alt="image-20230305100319825"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">make_money</span>(<span class="number">3</span>);     <span class="comment">// 传入具体的参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">make_money</span>(times: <span class="type">i32</span>) &#123;    <span class="comment">// 定义可传入的参数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;赚钱&#123;&#125;次&quot;</span>, times);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义参数的目的是为了外界能够给它传值，就好像坐公交车一样，投币口是参数列表，有一个参数，是硬币（让你投的），当外界传值时（投币），根据你的输入执行（让你上车）</p><p><strong>在函数签名当中，需要显式声明每个参数的类型</strong>（Rust的设计者慎重考虑的结果），以免编译器根据其他部分的代码进行推导后能明确意图，显式地标准总好过复杂的外部情形，对吧？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">make_money</span>(<span class="number">3</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多个参数，指出类型，“,”分隔</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">make_money</span>(times: <span class="type">i32</span>, value: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;赚钱&#123;&#125;次, 每次&#123;&#125;&quot;</span>, times, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-函数体中的语句和表达式"><a class="header-anchor" href="#1-2-函数体中的语句和表达式">¶</a>1.2. 函数体中的语句和表达式</h3><p>函数体，也就是先前<code>&#123;&#125;</code>包裹的部分，其中有若干条语句组成，<strong>并且可以以一条表达式作为结尾</strong></p><h4 id="1-2-1-语句-vs-表达式"><a class="header-anchor" href="#1-2-1-语句-vs-表达式">¶</a>1.2.1. 语句 vs 表达式</h4><p><strong>语句是执行操作但是不返回值的指令</strong></p><p><strong>表达式是会进行计算并且得到一个值作为结果的指令</strong></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202303051023706.png" alt="image-20230305102340410"></p><p>绿框的部分是语句，因为它们没有返回值，只是在描述一步步地操作，但是第二条语句的右侧红框部分是一条表达式，描述了sentence变量与234比较的结果，返回了bool类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">sentence</span> = <span class="number">125</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">temp</span> = sentence / <span class="number">2</span> ;</span><br><span class="line">        temp == <span class="number">234</span>   <span class="comment">// 没有分号，用作表达式返回</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>复杂些的场景（比如套<code>&#123;&#125;</code>的多行语句），在末尾使用表达式，不带分号可以返回结果</p><h3 id="1-3-函数的返回值"><a class="header-anchor" href="#1-3-函数的返回值">¶</a>1.3. 函数的返回值</h3><p>函数的返回值也是签名的一部分，可以向调用者返回值，使用<code>-&gt;</code>，并在其后面声明其类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sum</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;   <span class="comment">// 定义类型</span></span><br><span class="line">    a + b   <span class="comment">// 表达式返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">sum</span>(<span class="number">3</span>, <span class="number">2</span>);  <span class="comment">// 返回5</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;result=&#123;&#125;&quot;</span>, result);</span><br></pre></td></tr></table></figure><p>如果为函数的表达式结果加上分号，那么就会编程语句，进而无法匹配返回值类型</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202303051040802.png" alt="image-20230305104046962"></p><p>除了使用表达式作为最后的返回，也可以采用<code>return</code>返回</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sum</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-注释"><a class="header-anchor" href="#2-注释">¶</a>2. 注释</h2><p>注释的主要作用是<strong>用于说明代码的逻辑和功能</strong>，便于自己和一起写代码其他人理解，<strong>增强代码的可读性</strong></p><p>编译器会自动忽略注释，通常<strong>单行注释</strong>使用<code>//</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算求和</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sum</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而多行注释则是单行注释的复制，在每行前面加上<code>//</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算</span></span><br><span class="line"><span class="comment">// 两数相加</span></span><br><span class="line"><span class="comment">// 之和</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sum</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-控制流"><a class="header-anchor" href="#3-控制流">¶</a>3. 控制流</h2><p>程序往往不是平铺直叙的，需要包含循环、判断等控制逻辑使其更加丰满</p><h3 id="3-1-if表达式"><a class="header-anchor" href="#3-1-if表达式">¶</a>3.1. if表达式</h3><p><code>if</code>表达式主要是根据条件选择分支，许多的编程语言中都有类似的表达</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">assets</span> = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> assets &lt; <span class="number">100</span> &#123;  <span class="comment">// 条件分支</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;穷人&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> assets &gt;= <span class="number">100</span> &amp;&amp; assets &lt; <span class="number">10_000</span> &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;普通工薪阶级&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;    <span class="comment">// 兜底</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;大佬&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if</code>会计算对应分支的条件表达式的<strong>bool值</strong>，为true则执行对应的代码块的内容，为false则将跳过整个代码块（<strong>Rust不会尝试将非布尔类型的值转换为布尔类型</strong>）</p><p>并且，<code>else if</code>和<code>else</code>总是伴随<code>if</code>，一同组成多条件的分支</p><h4 id="3-1-1-表达式"><a class="header-anchor" href="#3-1-1-表达式">¶</a>3.1.1. 表达式</h4><p>由于<code>if</code>其实是表达式，那么本身能够返回值，因此可以直接将<code>if</code>的整体判断和返回内容一同放置到值的位置上</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">assets</span> = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">identity</span> = <span class="keyword">if</span> assets &lt; <span class="number">100</span> &#123;    <span class="comment">// 表达式作为右值</span></span><br><span class="line"><span class="string">&quot;穷人&quot;</span>   <span class="comment">// 返回值</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> assets &gt;= <span class="number">100</span> &amp;&amp; assets &lt; <span class="number">10_000</span> &#123;  </span><br><span class="line"><span class="string">&quot;普通工薪阶级&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="string">&quot;大佬&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;身份=&#123;&#125;&quot;</span>, identity);    </span><br></pre></td></tr></table></figure><p><strong>所有分支返回的类型必须统一</strong></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202303051402561.png" alt="image-20230305140151090"></p><p>编译器会对分支进行检查，以免类型无法匹配</p><h3 id="3-2-循环"><a class="header-anchor" href="#3-2-循环">¶</a>3.2. 循环</h3><p>计算机很擅长做重复的工作，并且这样的工作也非常适合它们</p><p>在各种编程语言中，提供的循环的结构也都大同小异，Rust也是基于这些原型进行一些优化和改造</p><p>Rust提供了3种循环：</p><ul><li>loop</li><li>while</li><li>for</li></ul><h4 id="3-2-1-loop循环"><a class="header-anchor" href="#3-2-1-loop循环">¶</a>3.2.1. loop循环</h4><p>使用<code>loop&#123;&#125;</code>可以定义一段无限循环</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;放我出去！&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是，通常我们不会进行无意义的无限循环，还是需要满足一定的条件的时候让它处理一些事情，这个时候就需要使用<code>break</code>跳出</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">i += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">break</span> i;   <span class="comment">// 满足条件结束并返回 4</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;result=&#123;&#125;&quot;</span>, result);</span><br></pre></td></tr></table></figure><h4 id="3-2-2-while条件循环"><a class="header-anchor" href="#3-2-2-while条件循环">¶</a>3.2.2. while条件循环</h4><p><code>while</code>循环会在每次执行循环体之前判断一次条件，条件为true就执行，否则就跳出</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;倒数=&#123;&#125;&quot;</span>, num);</span><br><span class="line">num -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-3-for循环"><a class="header-anchor" href="#3-2-3-for循环">¶</a>3.2.3. for循环</h4><p>使用<code>for</code>最大的好处是<strong>可以方便地遍历数组、元组等容器里的元素</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">teams</span> = [<span class="string">&quot;姆巴佩&quot;</span>, <span class="string">&quot;哈兰德&quot;</span>, <span class="string">&quot;克瓦拉茨赫利亚&quot;</span>, <span class="string">&quot;贝林厄姆&quot;</span>, <span class="string">&quot;穆德里克&quot;</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;开始点名！&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="variable">player</span> <span class="keyword">in</span> teams.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, player);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在遍历元素方面，<code>for</code>显得更加安全简捷</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span> .. teams.<span class="title function_ invoke__">len</span>() &#123;   <span class="comment">// 也可以使用Range通过区间取出索引</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust 探索（二）—— 通用编程概念（上）</title>
      <link href="/2023/03/04/Rust%20%E6%8E%A2%E7%B4%A2%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"/>
      <url>/2023/03/04/Rust%20%E6%8E%A2%E7%B4%A2%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1>Rust 探索（二）—— 通用编程概念（上）</h1><p>Rust作为一门编程语言自然也会有与许多其他编程语言相同或者相似的概念，这也是在编程语言领域的一些<strong>通用的概念</strong>，通过了解这些概念，并且与其他自己已经熟悉的编程语言进行比较，会使得对于Rust的理念的有更深的理解，也能帮助自己更快上手</p><h2 id="1-准备工作"><a class="header-anchor" href="#1-准备工作">¶</a>1. 准备工作</h2><p>使用具体项目、案例帮助自己学习总是不失为一个好的办法，甚至可以在掌握Rust之后将其整理，用作复习和优化</p><p>因而，在开始的时候，先使用<code>Cargo</code>创建一个Rust项目</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202302250956957.png" alt="image-20230225095646337"></p><h2 id="2-变量与可变性"><a class="header-anchor" href="#2-变量与可变性">¶</a>2. 变量与可变性</h2><p>在Rust当中，变量<strong>默认是不可变的</strong></p><p>如果一个变量不可变，并且有一个值已经与其绑定（也就是进行了赋值），那么这个值便无法被改变</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202302251536242.png" alt="image-20230225153632051"></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202302251538303.png" alt="image-20230225153852396"></p><p>报错的文字提示<strong>不可变的变量被赋值了两次</strong>，因而这种写法是无法通过编译的，更不要说运行了</p><p>在编程开发的过程中熟练地运用编译器来帮助我们自己也是重要的一环，<strong>Rust的编译器能够保证那些声明为不可变的值一定不会发生改变</strong>，因而在阅读代码的时候看到某个变量默认被声明为不可变变量时，不必去追究赋值的变化</p><h3 id="2-1-可变性"><a class="header-anchor" href="#2-1-可变性">¶</a>2.1. 可变性</h3><p>尽管变量默认是不可变的，但是我们可以通过在声明变量的时候在变量的名称前添加<code>mut</code>关键字来<strong>显式地将变量声明为可变的</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">name</span> = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">name = <span class="string">&quot;Mike&quot;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;我的名字是&#123;&#125;&quot;</span>, name);</span><br></pre></td></tr></table></figure><p>像这样，使用<code>mut</code>可以告诉别人这是一个可变的变量，需要关注其变化，但上面的代码语义上有点问题，因为第一次的赋值压根用不到，但这不影响运行，编译器体贴地指出了这个问题——没用的赋值</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202302251555548.png" alt="image-20230225155557827"></p><p>在开发中，可变与不可变的使用需要根据项目的实际情况进行取舍，比如如果是重型的数据结构进行修改，那么可能直接将其声明为可变，而后重新赋值更加节省性能；而如果数据结构较为轻量时，或许重新根据需要创建一个新的变量会使得可读性更强，因此，<strong>可变与不可变的取舍也是需要根据面临的具体情况进行取舍的</strong></p><h3 id="2-2-变量与常量的区别"><a class="header-anchor" href="#2-2-变量与常量的区别">¶</a>2.2. 变量与常量的区别</h3><p>如果光是看不可变，我们很容易会联想到<strong>常量</strong>的概念，然而二者之间还是存在一些区别的</p><p>相较于不可变的变量，常量所谓的不可变<strong>不仅是默认的，而且是自始至终的</strong>，无法用<code>mut</code>关键字对其进行修饰，仅仅是使用<code>const</code>关键字就是全部了</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设声明一个游戏的满级的等级为99级</span></span><br><span class="line">    <span class="keyword">const</span> MAX_LEVEL: <span class="type">u32</span> = <span class="number">99</span>;    <span class="comment">// 使用const关键字声明，命名采用全大写字母和下划线分割，并且注意需要显式声明类型，声明的时候就需要赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如上面的常量声明，习惯性地采用<strong>全大写的字母组成有意义的单词并且使用下划线进行分割</strong>，并且需要<strong>显式地声明值的类型</strong>，比如说这里的<code>u32</code>类型，表明的99是无符号的整数类型</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202302252145088.png" alt="image-20230225214531440"></p><p>常量声明的同时就需要赋值了，可不能等一会儿，等一会就给你报错，前一句认为这至少应该有个作用域，然而<code>free constant item without body</code>，而后面想要补救，等号左边却已经被判断为一个常量表达式了，此时的赋值操作已经是非法操作了</p><p>另外，常量<strong>可以被声明在任何作用域中（就是<code>&#123;&#125;</code>包起来的那块区域），包括全局作用域</strong>，而且<strong>在整个程序的运行过程中都在自己的作用域内有效</strong>（因而可以提供给各个程序逻辑进行共享）</p><p>常量可以被绑定到常量表达式上，但是无法将函数的返回值，或者其他需要<strong>运行时</strong>进行计算的值绑定到常量上，函数通常需要运行时动态计算，而常量的确认明显要更早，就像现在我们无法决定未来一样</p><p>自行编写程序的时候需要识别那些值可以使用常量进行替换，尤其是<strong>硬编码</strong>的内容，或是一些数值，后期维护可能成为“失联”的魔值，它们也许配得上拥有姓名；因而前期应该识别到可能被重复使用的一些常量，这样可以<strong>增强代码在后期的可读性、可维护性</strong></p><h3 id="2-3-隐藏"><a class="header-anchor" href="#2-3-隐藏">¶</a>2.3. 隐藏</h3><p><strong>隐藏（Shadow）<strong>是指一个</strong>新声明的变量覆盖掉了旧的同名变量</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">version</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">version</span> = version + <span class="number">1</span>;   <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">version</span> = version + <span class="number">1</span>;   <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;当前版本=&#123;&#125;&quot;</span>, version);</span><br></pre></td></tr></table></figure><p>使用<strong>隐藏机制</strong>和将变量声明为<code>mut</code>是不同的，新的变量依然会是<strong>不可变的</strong>，只不过相当于是保存了新的内容了，并且相较于<code>mut</code>，<strong>隐藏还可以修改变量的类型</strong>（毕竟是新的变量）；在我看来，这非常适用于进行数据转换，比如说后端给了一个时间戳的长串数字，前端需要将其展示为yyyy-MM-dd的格式，那么往常我们可能再声明一个诸如formattedDate这样的量存储加工后的值，甚至有的时候会有更多步的操作，这样可能会产生很多中间变量</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">date</span> = <span class="number">1677386710000</span>;    <span class="comment">// 可能是精确到毫秒的</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">formatedDate</span> = <span class="title function_ invoke__">get_formated_date_str</span>(date, <span class="string">&quot;yyyy-MM-dd&quot;</span>);   <span class="comment">// 其实页面展示只需要用到格式化结束的字符串</span></span><br></pre></td></tr></table></figure><p>使用隐藏机制就可以将同一个或一类的内容的加工作为多个版本，最后用到的那一版作为结果</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">date</span> = <span class="number">1677386710000</span>;    <span class="comment">// 1.0版本 原材料</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">date</span> = <span class="title function_ invoke__">get_formated_date_str</span>(date);   <span class="comment">// 2.0版本 加工上市的成品</span></span><br></pre></td></tr></table></figure><p>以上代码展示的就是使用了隐藏机制后的原逻辑，后端返回的数据旨在精准、完整，但是并非最终我们需要的成品，因此需要在此基础上进行加工，但他们认识代表了同样的意义，就好像前一版的你没穿衣服，这不能让别人看到，后一版帮你隐藏，穿上衣服后再出去见人，但你还是你，这也<strong>帮忙省去了那些命名费解、存在又很尴尬的临时量，使得代码的业务逻辑主线更加清晰</strong></p><h2 id="3-数据类型"><a class="header-anchor" href="#3-数据类型">¶</a>3. 数据类型</h2><p>Rust当中的<strong>每一个值都会有与之对应的数据类型</strong>，系统根据数据类型来处理它们</p><p>Rust是一门<strong>静态类型语言</strong>，因此在其编译程序的过程中<strong>需要知道所有变量的类型</strong>，也就是需要将类型首先确定下来</p><p>编译器在大部分的情况能够进行<strong>类型推导</strong>，我们如何绑定、使用变量的值会为编译器提供线索</p><p><img src="C:/Users/Minos/AppData/Roaming/Typora/typora-user-images/image-20230226173000120.png" alt="image-20230226173000120"></p><p>比如像这里，<code>: i32</code>并非在代码中指定的类型，而是编译器根据等号右侧为变量赋的值确定的，这便是编译器进行的<strong>自动推导</strong></p><p>然而，也有少量情况，编译器无法根据线索确定类型，这个时候就需要开发者自己进行类型指定</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202302261739040.png" alt="image-20230226173901140"></p><p>比如像将字符串转成数字，如果不指定明确的类型，编译器不清楚你想要转换成什么，那么就会报错</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202302261748798.png" alt="image-20230226174803147"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">version</span>: <span class="type">f32</span> = <span class="string">&quot;0.70&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;非数字类型&quot;</span>);   <span class="comment">// 通过显式指定类型为f32，是编译器明白我们的意图</span></span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;版本号=&#123;&#125;&quot;</span>, version)</span><br></pre></td></tr></table></figure><h3 id="3-1-标量类型"><a class="header-anchor" href="#3-1-标量类型">¶</a>3.1. 标量类型</h3><p><strong>标量类型</strong>作为<strong>单个值</strong>类型的<strong>统称</strong></p><p>Rust内部定义了4种基础的标量类型</p><ul><li>整数</li><li>浮点数</li><li>布尔值</li><li>字符</li></ul><h4 id="3-1-1-整数类型"><a class="header-anchor" href="#3-1-1-整数类型">¶</a>3.1.1. 整数类型</h4><p>整数类型表示的就是不包含小数部分的整数，其中分为<strong>有符号</strong>和<strong>无符号</strong></p><p>无符号数始终不为负，开头使用<code>u</code>区别，比如<code>u32</code></p><p><strong>有符号数通过二进制补码的形式来存储</strong></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202303041402072.png" alt="image-20230304140243231"></p><p>除了直接指明描述位数的类型，像<code>i32</code>，<code>u32</code>，还有<code>isize</code>和<code>usize</code>两种特殊的类型，<strong>它们的长度取决于程序运行的目标平台</strong></p><h5 id="3-1-1-1-字面量"><a class="header-anchor" href="#3-1-1-1-字面量">¶</a>3.1.1.1. 字面量</h5><p>另外，整数的<strong>字面量</strong>也有多种形式的呈现</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202303041413041.png" alt="image-20230304141342433"></p><h5 id="3-1-1-2-整数溢出问题"><a class="header-anchor" href="#3-1-1-2-整数溢出问题">¶</a>3.1.1.2. 整数溢出问题</h5><p><strong>整数溢出</strong>主要是由于存储的数超出类型的限制，就像往桶里倒水一样</p><p>在<strong>debug</strong>模式下，发生的溢出会抛出panic</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">big</span>: <span class="type">u8</span> = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">small</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = small + big;   <span class="comment">// 会发生溢出</span></span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;结果=&#123;&#125;&quot;</span>, result)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202303041514433.png" alt="image-20230304151450548"></p><p>程序立马发现这个溢出的错误，并将其抛出，中断了执行</p><h4 id="3-1-2-浮点数类型"><a class="header-anchor" href="#3-1-2-浮点数类型">¶</a>3.1.2. 浮点数类型</h4><p>Rust提供了两种基础的浮点数类型：<code>f32</code>，<code>f64</code></p><p>在Rust中，浮点类型<strong>默认</strong>会被推导为<code>f64</code>类型，因其在现代CPU执行中相较于<code>f32</code>有更高精度，执行效率也相差无几</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202303041525733.png" alt="image-20230304152526364"></p><p>使用<code>f32</code>需要显式进行指定</p><p>Rust中的<code>f32</code>和<code>f64</code>对应的就是IEEE-754标准中的<strong>单精度浮点数</strong>和<strong>双精度浮点数</strong></p><h4 id="3-1-3-数值计算"><a class="header-anchor" href="#3-1-3-数值计算">¶</a>3.1.3. 数值计算</h4><p>Rust中的数值类型<strong>支持各种常用运算</strong>，如：加减乘除、取余等</p><h4 id="3-1-4-布尔类型"><a class="header-anchor" href="#3-1-4-布尔类型">¶</a>3.1.4. 布尔类型</h4><p>布尔类型与其他语言是一样的，也是true和false两个值，并且仅占据一个字节</p><p>在条件表达式等控制语句中会有大量的出场</p><h4 id="3-1-5-字符类型"><a class="header-anchor" href="#3-1-5-字符类型">¶</a>3.1.5. 字符类型</h4><p>字符类型用以描述单个字符</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202303041606478.png" alt="image-20230304160651047"></p><p><code>char</code>类型占4个字节的空间，并且是一个Unicode标量值</p><h3 id="3-2-复合类型"><a class="header-anchor" href="#3-2-复合类型">¶</a>3.2. 复合类型</h3><p>在Rust当中，复合类型表示将不同的类型组合为一个类型</p><p>在Rust当中，提供了两种基础的复合类型：</p><ul><li>元组（tuple）</li><li>数组（array）</li></ul><h4 id="3-2-1-元组类型"><a class="header-anchor" href="#3-2-1-元组类型">¶</a>3.2.1. 元组类型</h4><p>元组能够将多个不同类型的值组合进一个类型，但是<strong>一旦声明结束便不可修改元素的数量</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">char</span>, <span class="type">bool</span>) = (<span class="number">15</span>, <span class="string">&#x27;A&#x27;</span>, <span class="literal">false</span>);   <span class="comment">// 声明</span></span><br></pre></td></tr></table></figure><p>如果需要对于其中的元素进行访问，可以使用<strong>解构</strong>的方式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (a, b, c) = tup;    <span class="comment">// 几个变量将和里面的元素对应上  比如：a: 15, b: &#x27;A&#x27;, c: false</span></span><br></pre></td></tr></table></figure><p>除了解构的方式，元组<strong>还可以支持使用<code>.</code>配合索引的方式对元组内部的元素进行访问</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">char</span>, <span class="type">bool</span>) = (<span class="number">15</span>, <span class="string">&#x27;A&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, tup.<span class="number">1</span>);   <span class="comment">// 下标从0开始</span></span><br></pre></td></tr></table></figure><h4 id="3-2-2-数组类型"><a class="header-anchor" href="#3-2-2-数组类型">¶</a>3.2.2. 数组类型</h4><p>数组有<strong>固定的长度</strong>，而且数组中的各个元素必须为<strong>相同的类型</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">list</span>: [<span class="type">char</span>; <span class="number">3</span>] = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>];     <span class="comment">// 前面是类型，后面是长度</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">zeros</span> = [<span class="number">0</span>; <span class="number">5</span>];   <span class="comment">// 长度为5，都是0</span></span><br></pre></td></tr></table></figure><p>数组的声明可以使用<code>[]</code>根据类型和长度初始化，也可以指定默认值和长度</p><p>而<strong>数组的访问</strong>和其他语言也几乎没有什么不同</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print!</span>(<span class="string">&quot;元素2=&#123;&#125;&quot;</span>, zeros[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p><strong>数组对应的是内存栈中一块连续的内存</strong></p><p>另外，说到数组，就容易联想到一个名为<strong>数组越界</strong>的问题</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202303041640708.png" alt="image-20230304164019766"></p><p>将索引修改为一个没有的量（无法访问到），这样，在程序执行的过程中会抛出<code>panic</code>，进而中止了程序的运行</p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android底层分析（二）——WindowManager</title>
      <link href="/2022/07/24/Android%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94WindowManager/"/>
      <url>/2022/07/24/Android%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94WindowManager/</url>
      
        <content type="html"><![CDATA[<h1>Android底层分析（二）——WindowManager</h1><p>在了解<code>WindowManagerService</code>之前，先来认识一下它的其他伙伴们</p><h2 id="1-WindowManager概述"><a class="header-anchor" href="#1-WindowManager概述">¶</a>1. WindowManager概述</h2><p><em><strong>android\view\WindowManager.java</strong></em></p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723103936510.png" alt="image-20220723103936510" style="zoom: 80%;" /><p><code>WindowManager</code>本身是一个<strong>接口</strong>，并且继承自<code>ViewManager</code></p><p><code>ViewManager</code>的内容比较简单，就是<strong>三件套</strong></p><p><em><strong>android\view\ViewManager.java</strong></em></p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723104751374.png" alt="image-20220723104751374" style="zoom: 80%;" /><p>这三个方法分别对应了<code>View</code>的添加、更新和删除</p><p>并且这些方法都传入<code>View</code>作为参数，因此<code>Window</code>正是借助于<code>View</code>的形式得以展示</p><p>既然<code>WindowManager</code>继承了<code>ViewManager</code>接口，自然也就继承了这些方法，可用于对于<code>View</code>进行操作</p><p><em><strong>android\view\WindowManager.java</strong></em></p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723130309361.png" alt="image-20220723130309361" style="zoom:80%;" /><p>除此以外，基于<code>Window</code>的特性，又加入了<code>getDefaultDisplay()</code>和<code>removeViewImmediate()</code>这两个方法</p><p>第一个<code>getDefaultDisplay()</code>返回的是<code>WindowManager</code>将创建<code>Window</code>的<code>Display</code>对象</p><p>而第二个<code>removeViewImmediate()</code>则是<code>removeView()</code>的一种变体，能够在返回前立即调用给定<code>View</code>的层级的<code>View#onDetachedFromWindow()</code>方法，这不适用于正常的应用销毁流程</p><h2 id="2-Window概述"><a class="header-anchor" href="#2-Window概述">¶</a>2. Window概述</h2><p><code>Window</code>是一个<strong>抽象类</strong>，正如注释所写，它<strong>唯一的实现类</strong>是<code>PhoneWindow</code></p><p><code>Window</code>主要的职责是作为<code>View</code>的<strong>容器</strong>，以及<strong>定义标准UI的一些基础规范</strong></p><p><em><strong>android\view\Window.java</strong></em></p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723132617980.png" alt="image-20220723132617980" style="zoom:80%;" /><p>简要阐述一下<code>Window</code>在何时进行实例化</p><p>这里直接来到<code>Activity</code>的代码中，在启动<code>Activity</code>时，会调用到<code>attach()</code>，此时，<code>Window</code>对象进行<strong>实例化</strong></p><p><em><strong>android\app\Activity.java</strong></em></p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723133536559.png" alt="image-20220723133536559" style="zoom:80%;" /><p>同样在<code>attach()</code>中，下面又调用了<code>setWindowManager()</code>方法，该方法定义在<code>Window</code>中</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723133923017.png" alt="image-20220723133923017"></p><p>在<code>WindowManager</code>为空时，会调用<code>Context</code>的<code>getSystemService()</code>方法进行获取，这里传入服务名称<code>Context.WINDOW_SERVICE</code></p><p><em><strong>android\view\Window.java</strong></em></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723134334675.png" alt="image-20220723134334675"></p><p>该服务的名称就是<code>window</code></p><p><em><strong>android\content\Context.java</strong></em></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723141029044.png" alt="image-20220723141029044"></p><p><code>ContextImpl</code>覆写了<code>Context</code>的<code>getSystemService()</code>方法，这里涉及到<strong>装饰器模式</strong></p><p><em><strong>android\app\ContextImpl.java</strong></em></p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723143718291.png" alt="image-20220723143718291" style="zoom:80%;" /><p>进而，调用<code>SystemServiceRegistry</code>的<code>getSystemService()</code>，<code>SYSTEM_SERVICE_FETCHERS</code>是一个<code>ArrayMap</code>结构，从中获取对应服务的<code>ServiceFetcher</code></p><p><em><strong>android\app\SystemServiceRegistry.java</strong></em></p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723145446838.png" alt="image-20220723145446838" style="zoom:80%;" /><p><code>ServiceFetcher</code>作为<code>SystemServiceRegistry</code>的内部接口，通过<code>getService()</code>拿取服务，注意这里有<strong>缓存创建</strong>，<code>CachedServiceFetcher</code>实现了<code>ServiceFetcher</code>接口</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723150053219.png" alt="image-20220723150053219" style="zoom:80%;" /><p>继续看下面的代码，如果有对应的服务缓存，直接返回；如果是第一次，会去调用<code>createService()</code>方法</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723150549643.png" alt="image-20220723150549643" style="zoom:80%;" /><p>在<code>SystemServiceRegistry</code>类的<code>static&#123;&#125;</code>中注册了对应服务，<code>createService()</code>的抽象方法被覆写，最终作为服务返回的是<code>WindowManagerImpl</code>对象</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723151143246.png" alt="image-20220723151143246"></p><p>那么，取出的<code>WindowManagerImpl</code>被转为<code>WindowManager</code>，回到<code>Window.java</code>，下面又转回来</p><p><em><strong>android\view\Window.java</strong></em></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723152230611.png" alt="image-20220723152230611"></p><p>调用<code>createLocalWindowManager()</code>实质上是依据传入的<code>Window</code>对象<code>new</code>了一个<code>WindowManagerImpl</code>对象</p><p><em><strong>android\view\WindowManagerImpl.java</strong></em></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723152736906.png" alt="image-20220723152736906"></p><p>此时，新的<code>WindowManagerImpl</code>对象便持有了原来<code>Window</code>的引用，那么通过<code>Window#getWindowManager()</code>可以获得操作<code>Window</code>的权力，因为这正好获取了<code>Window</code>中的<strong>mWindowManager</strong>成员，实际的功能还是依赖于<code>WindowManagerImpl</code></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723153322958.png" alt="image-20220723153322958"></p><p>但是，在<code>WindowManagerImpl</code>会发现，其实<code>WindowManagerImpl</code>也是把任务交给了<strong>mGlobal</strong>来做</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723153940042.png" alt="image-20220723153940042" style="zoom:80%;" /><p><strong>mGlobal</strong>是<code>WindowManagerGlobal</code>的<strong>单例对象</strong>（<code>WindowManagerGlobal</code>进程唯一，但是<code>WindowManagerImpl</code>的实例一个进程有可能有多个），这里用到了<strong>桥接模式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723154339448.png" alt="image-20220723154339448"></p><h2 id="3-关系图"><a class="header-anchor" href="#3-关系图">¶</a>3. 关系图</h2><p>简要描述下操作<code>Window</code>前都做了些什么</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723161611799.png" alt="image-20220723161611799"></p><p>其次，看下一些主要类的层次结构关系，仅标注一些主要的内容</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723163459710.png" alt="image-20220723163459710" style="zoom:80%;" /><h2 id="4-属性"><a class="header-anchor" href="#4-属性">¶</a>4. 属性</h2><p><code>Window</code>的属性有很多种，其中最常用到的主要有三种：</p><ul><li><strong>Type</strong>（类型）</li><li><strong>Flag</strong>（标志位）</li><li><strong>SoftInputMode</strong>（软键盘模式）</li></ul><h3 id="4-1-Window的类型以及显示的次序"><a class="header-anchor" href="#4-1-Window的类型以及显示的次序">¶</a>4.1. Window的类型以及显示的次序</h3><p><code>Window</code>的主要类型有以下三种：</p><ul><li>常规的应用程序窗口</li><li>子窗口</li><li>系统专用窗口</li></ul><h4 id="4-1-1-常规的应用程序窗口"><a class="header-anchor" href="#4-1-1-常规的应用程序窗口">¶</a>4.1.1. 常规的应用程序窗口</h4><p>比如说<code>Activity</code>就属于这个范畴</p><p>对应的<code>type</code>数值为1~99</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723192143302.png" alt="image-20220723192143302" style="zoom:80%;" /><h4 id="4-1-2-子窗口"><a class="header-anchor" href="#4-1-2-子窗口">¶</a>4.1.2. 子窗口</h4><p>这种窗口类型<strong>无法独立存在</strong>，<strong>需要依附在其他窗口之上</strong></p><p>如<code>PopWindow</code>就属于该范畴</p><p>对应的<code>type</code>数值为1000~1999</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723192248088.png" alt="image-20220723192248088" style="zoom:80%;" /><h4 id="4-1-3-系统专用窗口"><a class="header-anchor" href="#4-1-3-系统专用窗口">¶</a>4.1.3. 系统专用窗口</h4><p><code>Toast</code>、软键盘、系统错误弹窗等窗口属于该范畴</p><p>系统专用窗口的类型还是比较多的，其对应<code>type</code>为2000~2999</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723194545782.png" alt="image-20220723194545782" style="zoom:80%;" /><h4 id="4-1-4-窗口显示次序"><a class="header-anchor" href="#4-1-4-窗口显示次序">¶</a>4.1.4. 窗口显示次序</h4><p>进程向<code>WMS</code>申请窗口进行显示，<code>WMS</code>为窗口确定显示的次序</p><p>正如<code>CSS</code>里面的<code>z-index</code>属性一样，在垂直于屏幕的方向上，<code>Android</code>也提供<code>Z-Order</code>的概念，用于表示<strong>页面显示层级</strong></p><p>前面提到的<code>Window</code>对应的<code>type</code>正好就是<code>Z-Order</code>进行排序的依据</p><p><strong>一般情况下</strong>，<strong><code>type</code>的值越大，那么窗口显示的层级越靠上，也就越接近用户</strong></p><h3 id="4-2-标志位"><a class="header-anchor" href="#4-2-标志位">¶</a>4.2. 标志位</h3><p><code>flag</code>的主要用途是<strong>赋予窗口某些特性</strong>，比如不可接收触摸事件、触发亮屏等</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723195820899.png" alt="image-20220723195820899" style="zoom:80%;" /><h3 id="4-3-软键盘模式"><a class="header-anchor" href="#4-3-软键盘模式">¶</a>4.3. 软键盘模式</h3><p>主要用于用户输入时，<strong>页面与软键盘弹窗叠加时的显示模式</strong>，这个很大程度上会影响用户的交互体验，现实场景中其实很重要</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723200941432.png" alt="image-20220723200941432" style="zoom:80%;" /><h2 id="5-操作"><a class="header-anchor" href="#5-操作">¶</a>5. 操作</h2><p>对于<code>Window</code>的操作可以分为两个部分：</p><ul><li><code>WindowManager</code>的处理</li><li><code>WMS</code>的处理</li></ul><h3 id="5-1-系统窗口的添加（状态栏为例）"><a class="header-anchor" href="#5-1-系统窗口的添加（状态栏为例）">¶</a>5.1. 系统窗口的添加（状态栏为例）</h3><p>在<code>StatusBar#start()</code>中，<code>createAndAddWindows()</code>所做的就是构建<code>StatusBar</code>的视图，并且将其添加到<code>WindowManager</code>上</p><p><em><strong>com\android\systemui\statusbar\phone\StatusBar.java</strong></em></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220723224625407.png" alt="image-20220723224625407"></p><p>其中，<code>makeStatusBarView()</code>所做的就是构建视图</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724081218375.png" alt="image-20220724081218375"></p><p>然后，接下来<code>StatusBarWindowController#attach()</code>将对应的视图添加到<code>WindowManager</code>上，同时也可以看到类型参数<code>TYPE_STATUS_BAR</code></p><p><em><strong>com\android\systemui\statusbar\phone\StatusBarWindowController.java</strong></em></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724081928982.png" alt="image-20220724081928982"></p><p>调用<code>addView()</code>进行添加，这还是调用了<code>WindowManagerImpl</code>的方法，传入对应<code>View</code>参数</p><p><em><strong>android\view\WindowManagerImpl.java</strong></em></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724082223760.png" alt="image-20220724082223760"></p><p>作为子窗口时，<code>adjustLayoutParamsForSubWindow()</code>调整窗口的大小，适配当前的父窗口</p><p><em><strong>android\view\WindowManagerGlobal.java</strong></em></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724082541336.png" alt="image-20220724082541336"></p><p>这里先看看类开头定义的3个参数，<code>mViews</code>、<code>mRoots</code>、<code>mParams</code>，都是<code>ArrayList</code></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724083304660.png" alt="image-20220724083304660"></p><p>随后接着看<code>addView()</code>，实例化<code>ViewRootImpl</code>对象，为<code>View</code>设置窗口参数，然后三个列表对应保存数据，然后将设置完的<code>View</code>塞给<code>ViewRootImpl</code>对象</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724082831155.png" alt="image-20220724082831155"></p><p><code>ViewRootImpl</code>承担了很多职责，比如<code>View</code>树管理，测量、布局、绘制，与<code>WMS</code>通信等</p><p>这里调用<code>addToDisplayAsUser()</code>，<code>mWindowSession</code>是一个<code>Binder</code>对象，是<code>IWindowSession</code>类型，用以进行<strong>进程间通信</strong>，<code>IWindowSession</code>是<strong>客户端代理</strong>，与之对应的服务端实现为<code>Session</code>，<code>Session</code>的<code>addToDisplayAsUser()</code>方法运行在<code>WMS</code>所在进程(<code>system_server</code>)</p><p><em><strong>android\view\ViewRootImpl.java</strong></em></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724084224999.png" alt="image-20220724084224999"></p><p>接受到通信，<code>Session</code>的<code>addToDisplayAsUser()</code>被调用，<code>Session</code>被作为参数，<code>WMS</code>调用<code>addWindow()</code>，将其传入，剩下的工作都交由<code>WMS</code>处理了</p><p><em><strong>com\android\server\wm\Session.java</strong></em></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724090051102.png" alt="image-20220724090051102"></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724092131849.png" alt="image-20220724092131849"></p><h3 id="5-2-Activity添加过程"><a class="header-anchor" href="#5-2-Activity添加过程">¶</a>5.2. Activity添加过程</h3><p><code>performResumeActivity()</code>最终会调用<code>Activity</code>的<code>onResume()</code>，然后<code>getWindowManager()</code>，这是之前的，返回的其实是<code>WindowManagerImpl</code></p><p><em><strong>android\app\ActivityThread.java</strong></em></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724092659689.png" alt="image-20220724092659689"></p><p>调用<code>addView()</code>，之后和其他的<code>Window</code>添加过程就很类似了，这里传入的是<code>DecorView</code></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724092932953.png" alt="image-20220724092932953"></p><h3 id="5-3-Window更新"><a class="header-anchor" href="#5-3-Window更新">¶</a>5.3. Window更新</h3><p>更新过程的起点从<code>ViewManager</code>的<code>updateViewLayout()</code>开始，实际上调用了<code>WindowManagerImpl</code>的<code>updateViewLayout()</code></p><p><em><strong>android\view\WindowManagerImpl.java</strong></em></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724093834650.png" alt="image-20220724093834650"></p><p>然后，也是由<code>WindowManagerGlobal</code>管事，同样是操作三个列表，调用<code>ViewRootImpl</code>的<code>setLayoutParams()</code></p><p><em><strong>android\view\WindowManagerGlobal.java</strong></em></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724094057194.png" alt="image-20220724094057194"></p><p>在<code>ViewRootImpl</code>的<code>setLayoutParams()</code>最后调用了<code>scheduleTraversals()</code></p><p><em><strong>android\view\ViewRootImpl.java</strong></em></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724094353430.png" alt="image-20220724094353430"></p><p>如果使用过<code>SysTrace</code>这类工具应该很熟悉这个名字，<strong>Choreographer</strong>，这里与UI绘制开始关联上了，其主要任务是接受显示系统的<code>VSync</code>信号，在下一帧渲染时进行一些同步操作</p><p><code>postCallback()</code>发送了一个线程任务<code>TraversalRunnable</code></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724094618665.png" alt="image-20220724094618665"></p><p>字面上看，叫“遍历线程”，它的<strong>线程任务</strong>为<code>doTraversal()</code></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724095124212.png" alt="image-20220724095124212"></p><p>所做的主要事情都在<code>performTraversals()</code>中</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724095340908.png" alt="image-20220724095340908"></p><p><code>performTraversals()</code>中的代码量非常大，都是与<code>View</code>绘制相关的，所谓的遍历其实就是<strong>遍历视图树</strong></p><p>首先，<code>relayoutWindow()</code>实际会去调用<code>mWindowSession.relayout()</code>，这又是一个<code>Binder</code>通信，和之前一样，又是<code>WMS</code>去处理</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724095639510.png" alt="image-20220724095639510"></p><p>随后，是自定义<code>View</code>需要了解的<strong>三连</strong>，也就是<code>View</code>的工作流程，这几个方法分别对应了<code>View</code>的<code>onMeasure()</code>、<code>onLayout()</code>、<code>onDraW()</code></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724095821478.png" alt="image-20220724095821478"></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724095903575.png" alt="image-20220724095903575"></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220724095951390.png" alt="image-20220724095951390"></p><p>一方面通知<code>WMS</code>去更新，另一方面进行<code>View</code>的绘制，完成了<code>Window</code>的更新</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gradle学习——Groovy基础</title>
      <link href="/2022/07/09/Gradle%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Groovy%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/07/09/Gradle%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Groovy%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1>Gradle学习——Groovy基础</h1><blockquote><p>Groovy官方文档：<a href="http://www.groovy-lang.org/documentation.html">The Apache Groovy programming language - Documentation (groovy-lang.org)</a></p></blockquote><h2 id="1-概述-v2"><a class="header-anchor" href="#1-概述-v2">¶</a>1. 概述</h2><p>借用一下Apache官方的图</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220703142755139.png" alt="image-20220703142755139" style="zoom:80%;" /><p>大体上看，官方将Groovy描述为一个<strong>Java平台上的多面手</strong></p><p>这里列举了很多内容，我们主要需要了解到Groovy是<strong>基于JVM的面向对象编程语言</strong>就行了</p><h2 id="2-编写与调试步骤"><a class="header-anchor" href="#2-编写与调试步骤">¶</a>2. 编写与调试步骤</h2><ul><li><p>目录创建<code>build.gradle</code>文件</p></li><li><p><code>build.gradle</code>文件中创建<code>task</code></p></li><li><p><code>task</code>中用<code>Groovy</code>编写逻辑</p></li><li><p><code>build.gradle</code>所在的目录下运行<code>gradle &lt;task名称&gt;</code></p></li></ul><h2 id="3-变量定义"><a class="header-anchor" href="#3-变量定义">¶</a>3. 变量定义</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> a = <span class="number">1</span>    <span class="comment">// 根据初始化的值，推断为int类型 </span></span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>    <span class="comment">// 指明类型为int</span></span><br><span class="line"><span class="keyword">def</span> c = <span class="string">&quot;3&quot;</span>  <span class="comment">// 推断为String</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220703152340601.png" alt="image-20220703152340601"></p><p>默认情况下的访问修饰符都是<code>public</code></p><h2 id="4-方法定义"><a class="header-anchor" href="#4-方法定义">¶</a>4. 方法定义</h2><p>与变量的定义非常类似，如果指明返回类型就可以不使用<code>def</code>，默认情况下访问修饰符类型也是<code>public</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> add(a, b) &#123;</span><br><span class="line">    println a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数也可以不声明类型，依赖于调用的时候进行推断</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220703155330059.png" alt="image-20220703155330059"></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220703155258563.png" alt="image-20220703155258563"></p><p>调用的地方根据传入参数的类型进行了推断，确定了定义的参数类型</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> minus(a, b) &#123;</span><br><span class="line">    println a - b</span><br><span class="line">    a - b   <span class="comment">// 自动作为返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至可以在调用时不写括号</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minus a, b   <span class="comment">// 调用时可省略括号</span></span><br></pre></td></tr></table></figure><p>方法体中如果没有<code>return</code>，那么<strong>最后一行内容会作为方法的返回值</strong></p><blockquote><p>注意：</p><ul><li>语句后的分号可以省略</li><li>方法的括号可以省略</li><li>参数类型可以省略</li><li>return语句也可以省略</li></ul></blockquote><h2 id="5-类"><a class="header-anchor" href="#5-类">¶</a>5. 类</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;     <span class="comment">// 定义类</span></span><br><span class="line">    String name</span><br><span class="line">    Integer age = <span class="number">18</span></span><br><span class="line">    <span class="keyword">def</span> gender = <span class="string">&quot;male&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> sayHello() &#123;</span><br><span class="line">        println <span class="string">&quot;Hello, my name is &quot;</span> + name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> person = <span class="keyword">new</span> Person()   <span class="comment">// 实例化</span></span><br><span class="line">person.name = <span class="string">&quot;Bob&quot;</span></span><br><span class="line">person.sayHello()    </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220703165005881.png" alt="image-20220703165005881"></p><p>默认的类修饰符是<code>public</code><br>并且没有设置可见修饰符的字段会自动生成对应的<code>setter</code>和<code>getter</code></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220703165210941.png" alt="image-20220703165210941"></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220703165228971.png" alt="image-20220703165228971"></p><h2 id="6-语句"><a class="header-anchor" href="#6-语句">¶</a>6. 语句</h2><h3 id="6-1-断言"><a class="header-anchor" href="#6-1-断言">¶</a>6.1. 断言</h3><p>首先需要注意，Groovy的断言<strong>一直处于开启状态</strong>，可以用作<strong>单元测试</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="number">1</span> + <span class="number">1</span> == <span class="number">3</span></span><br></pre></td></tr></table></figure><p>这是一条简单的断言，很显然，这将会失败</p><p>断言失败时，程序会抛出异常，并且中止</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220703170510424.png" alt="image-20220703170510424"></p><p>那么，我们根据错误去检查原因，并修复</p><p>如果断言成功，并不会有什么事情发生</p><h3 id="6-2-for循环"><a class="header-anchor" href="#6-2-for循环">¶</a>6.2. for循环</h3><p>关于for循环，Groovy首先支持Java的<code>for(int i = 0;i &lt; N;i ++)</code>和<code>for(i in array)</code>这两种形式的循环语句</p><p>另外还支持一种<code>for in loop</code>形式，能够支持多种类型的遍历</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历区间</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.5</span>) &#123;</span><br><span class="line">println i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220703173459074.png" alt="image-20220703173459074"></p><p>​</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历列表</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]) &#123;</span><br><span class="line">println i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220703173713089.png" alt="image-20220703173713089"></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历Map</span></span><br><span class="line"><span class="keyword">for</span> (entry <span class="keyword">in</span> [<span class="string">&#x27;9&#x27;</span> : <span class="string">&#x27;CF&#x27;</span>, <span class="string">&#x27;11&#x27;</span> : <span class="string">&#x27;RW&#x27;</span>, <span class="string">&#x27;7&#x27;</span> : <span class="string">&#x27;LF&#x27;</span>].entrySet()) &#123;</span><br><span class="line">println entry.key + <span class="string">&#x27; : &#x27;</span> + entry.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220703174154731.png" alt="image-20220703174154731"></p><h3 id="6-3-switch语句"><a class="header-anchor" href="#6-3-switch语句">¶</a>6.3. switch语句</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> response = <span class="number">500</span>  <span class="comment">// 自己可以换</span></span><br><span class="line"><span class="keyword">switch</span> (response) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">404</span>:   <span class="comment">// 单个值匹配</span></span><br><span class="line">        println <span class="string">&#x27;Not Found&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> [<span class="number">401</span>, <span class="number">403</span>]:    <span class="comment">// 列表内容匹配</span></span><br><span class="line">        println <span class="string">&#x27;Unauthorized or Forbidden&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">500.</span><span class="number">.505</span>:    <span class="comment">// 区间内容匹配</span></span><br><span class="line">        println <span class="string">&#x27;Server Problem&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">200</span>:</span><br><span class="line">        println <span class="string">&#x27;OK&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="symbol">default:</span>     </span><br><span class="line">        println <span class="string">&#x27;Other Problem&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此以外还可以进行类型匹配，能够处理的<code>case</code>类型比较多</p><h2 id="7-数据类型"><a class="header-anchor" href="#7-数据类型">¶</a>7. 数据类型</h2><p>Groovy所支持的数据类型主要包括：</p><ul><li>Java中的基本数据类型</li><li>Groovy中的容器类</li><li>闭包</li></ul><h3 id="7-1-字符串"><a class="header-anchor" href="#7-1-字符串">¶</a>7.1. 字符串</h3><p>首先，需要注意，在Groovy中有<strong>两种字符串类型</strong></p><ul><li>普通字符串<code>String</code></li><li>插值字符串<code>GString</code></li></ul><h4 id="7-1-1-单引号字符串"><a class="header-anchor" href="#7-1-1-单引号字符串">¶</a>7.1.1. 单引号字符串</h4><p>其实单引号和双引号都可以表示字符串，但是但因不支持插值，因此是纯常量</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Tears and Rain&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="7-1-2-双引号字符串"><a class="header-anchor" href="#7-1-2-双引号字符串">¶</a>7.1.2. 双引号字符串</h4><p>双引号除了单引号的字符串常量功能，还支持<strong>插值</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> value = <span class="string">&#x27;Rain&#x27;</span></span><br><span class="line"><span class="string">&quot;Tears and $value&quot;</span></span><br></pre></td></tr></table></figure><p>插值以<code>$</code>开头，表达式需要用<code>&#123;&#125;</code>括起来</p><h4 id="7-1-3-三引号字符串"><a class="header-anchor" href="#7-1-3-三引号字符串">¶</a>7.1.3. 三引号字符串</h4><p>在单引号常量的基础上添加了格式，但不支持插值</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> str =</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;Tears </span></span><br><span class="line"><span class="string">      and </span></span><br><span class="line"><span class="string">           Rain&#x27;&#x27;&#x27;</span></span><br><span class="line">    println str</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220704230111401.png" alt="image-20220704230111401"></p><p><code>String</code>不可变，<code>GString</code>可变，即使字面量相同，hashCode也可能不同，因此应当避免使用<code>GString</code>作为Map的Key</p><h3 id="7-2-List"><a class="header-anchor" href="#7-2-List">¶</a>7.2. List</h3><p>Groovy的集合类是对Java集合类的加工</p><p>因此Groovy中<code>List</code>就对应Java中的<code>List</code>，并且默认实现类是<code>ArrayList</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">assert</span> list <span class="keyword">instanceof</span> List</span><br></pre></td></tr></table></figure><p>在Groovy中，使用<code>as</code>进行强制转换</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> linkedList = list <span class="keyword">as</span> LinkedList</span><br><span class="line"><span class="keyword">assert</span> linkedList <span class="keyword">instanceof</span> LinkedList</span><br></pre></td></tr></table></figure><p>元素的获取直接采用<code>[]</code>，根据索引获取元素</p><p>这里的索引可正可负，分别对应正数和倒数的顺序</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">assert</span> list[<span class="number">0</span>] == <span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span> list[<span class="number">-1</span>] == <span class="number">3</span></span><br></pre></td></tr></table></figure><p>并且，使用<code>&lt;&lt;</code>可以进行末尾元素的追加</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">list &lt;&lt; <span class="number">4</span>  <span class="comment">// 末尾追加</span></span><br><span class="line">println list</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220706235406241.png" alt="image-20220706235406241"></p><h3 id="7-3-Map"><a class="header-anchor" href="#7-3-Map">¶</a>7.3. Map</h3><p>创建同样使用<code>[]</code>，不过其中的内容是键值对，并且这里的<code>Map</code>的默认实现使用的是<code>LinkedHashMap</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> map = [<span class="attr">one:</span> <span class="string">&#x27;1&#x27;</span>, <span class="attr">two:</span> <span class="string">&#x27;2&#x27;</span>, <span class="attr">three:</span> <span class="string">&#x27;3&#x27;</span>]   <span class="comment">// 键值对</span></span><br><span class="line">println map</span><br></pre></td></tr></table></figure><p>但是需要注意的是，key的表示，<strong>key默认为字符串</strong>（尽管没加引号）</p><p>取值的方式，则是通过<code>[]</code>加上key</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println map[<span class="string">&#x27;one&#x27;</span>]   <span class="comment">// 这个时候又需要加上引号了</span></span><br></pre></td></tr></table></figure><p>因为之前说了，key默认会为字符串，那么变量如何表示？</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220708231636025.png" alt="image-20220708231636025"></p><p>这样直接拿去用，自然key变成key1这个字符串，而非其内容（并未高亮显示）</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220708231741423.png" alt="image-20220708231741423"></p><p>这里就需要加上括号，现在就高亮了</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> key1 = <span class="string">&#x27;one&#x27;</span></span><br><span class="line"><span class="keyword">def</span> map = [(key1): <span class="string">&#x27;1&#x27;</span>, <span class="attr">two:</span> <span class="string">&#x27;2&#x27;</span>, <span class="attr">three:</span> <span class="string">&#x27;3&#x27;</span>]  <span class="comment">// 这里()特殊了这个key，表明它还拥有变量的身份</span></span><br></pre></td></tr></table></figure><h3 id="7-4-闭包"><a class="header-anchor" href="#7-4-闭包">¶</a>7.4. 闭包</h3><p>闭包实际上代表的是一个<strong>代码块</strong>，而它的行为则由你进行定义</p><p>在结构上，闭包分为两个部分：<strong>参数列表</strong>和<strong>语句</strong></p><p>大概的格式为</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; 参数列表 -&gt; 语句 &#125;</span><br></pre></td></tr></table></figure><p>其中，参数列表是可选的，如果参数列表只有一个参数，那么Groovy会将其默认为<code>it</code></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">task test &#123;</span><br><span class="line">   println it   <span class="comment">// 其实就是前面的task</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上没有使用到参数列表</p><p>也可以指定参数列表</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">task test &#123;</span><br><span class="line">   it -&gt; println it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包实质上是一个<code>Closure</code>实例</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> add = &#123;</span><br><span class="line">       String a, String b -&gt; println a + b</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>闭包可以看作是方法，根据参数列表传入参数，执行语句</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> add = &#123;</span><br><span class="line">        String a, String b -&gt; println a + b</span><br><span class="line">    &#125;</span><br><span class="line">add(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>)  <span class="comment">// 直接调用</span></span><br><span class="line">add.call(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>)  <span class="comment">// 通过call()调用</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220709074955052.png" alt="image-20220709074955052"></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> isTwo = &#123;</span><br><span class="line">        <span class="type">int</span> i -&gt; i == <span class="number">2</span>   <span class="comment">// 返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">println isTwo(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220709074820771.png" alt="image-20220709074820771"></p><h3 id="7-5-I-O操作"><a class="header-anchor" href="#7-5-I-O操作">¶</a>7.5. I/O操作</h3><p>I/O操作无外乎<strong>写入</strong>和<strong>读取</strong>，这样的操作在使用Gradle构建应该很常见</p><h4 id="7-5-1-写入"><a class="header-anchor" href="#7-5-1-写入">¶</a>7.5.1. 写入</h4><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220709080707372.png" alt="image-20220709080707372"></p><p>一会儿会在这里创建一个文件</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> path = <span class="string">&quot;C:\\Develop\\groovy_projects\\test\\mapping.txt&quot;</span>  <span class="comment">// 文件路径</span></span><br><span class="line"><span class="keyword">def</span> file = <span class="keyword">new</span> File(path)   <span class="comment">// 文件对象</span></span><br><span class="line">file.withPrintWriter &#123;   </span><br><span class="line">it.println(<span class="string">&quot;Happy birthday!&quot;</span>)   <span class="comment">// 按行写入</span></span><br><span class="line">it.println(<span class="string">&quot;My Love!&quot;</span>)</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>这里按照路径创建了一个文件</p><p><img src="C:/Users/Minos/AppData/Roaming/Typora/typora-user-images/image-20220709080946751.png" alt="image-20220709080946751"><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220709080946753.png" alt="image-20220709080946753"></p><p>打开可以看到一共两行内容，这就写入成功了</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220709081009743.png" alt="image-20220709081009743"></p><h4 id="7-5-2-读取"><a class="header-anchor" href="#7-5-2-读取">¶</a>7.5.2. 读取</h4><p>既然创建了对应的文件，并且写入了内容，那么接下来将文件的内容读取并输出到控制台上</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> path = <span class="string">&quot;C:\\Develop\\groovy_projects\\test\\mapping.txt&quot;</span></span><br><span class="line"><span class="keyword">def</span> file = <span class="keyword">new</span> File(path)</span><br><span class="line">file.eachLine &#123;    <span class="comment">// 将内容按行输出</span></span><br><span class="line">println it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220709081525024.png" alt="image-20220709081525024"></p><p>甚至可以更精简一些</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> path = <span class="string">&quot;C:\\Develop\\groovy_projects\\test\\mapping.txt&quot;</span></span><br><span class="line"><span class="keyword">def</span> file = <span class="keyword">new</span> File(path)</span><br><span class="line">println file.text  <span class="comment">// 全部输出</span></span><br></pre></td></tr></table></figure><h3 id="7-6-语法糖"><a class="header-anchor" href="#7-6-语法糖">¶</a>7.6. 语法糖</h3><h4 id="7-6-1-判断列表"><a class="header-anchor" href="#7-6-1-判断列表">¶</a>7.6.1. 判断列表</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> name = []</span><br><span class="line"><span class="keyword">if</span> (name) &#123;    <span class="comment">// 判断了!null且不为[]</span></span><br><span class="line">println name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-6-2-空判断"><a class="header-anchor" href="#7-6-2-空判断">¶</a>7.6.2. 空判断</h4><p>使用<code>.?</code>进行调用，可以对调用方施加<code>if(调用方!=null)</code>的判断</p><p>这比Java中层层相扣的空指针判断要舒服很多</p><h4 id="7-6-3-with"><a class="header-anchor" href="#7-6-3-with">¶</a>7.6.3. with</h4><p>可用于简化对同一对象的操作</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> p = <span class="keyword">new</span> Person()</span><br><span class="line">p.with &#123;    </span><br><span class="line">name = <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">age = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">println p.name</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Gradle </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式——六大原则</title>
      <link href="/2022/07/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2022/07/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1>设计模式——六大原则</h1><h2 id="1-单一职责原则（Single-Responsibility-Principle，SRP）"><a class="header-anchor" href="#1-单一职责原则（Single-Responsibility-Principle，SRP）">¶</a>1. 单一职责原则（Single Responsibility Principle，SRP）</h2><blockquote><p>定义：就一个类而言，应该<strong>仅有一个引起它变化的原因</strong></p></blockquote><p>程序最终期望实现的是<strong>高内聚，低耦合</strong>，而内聚就体现在这里</p><p>就像一个团体一样，既然赋予了它姓名，那么参与者们就都有着相似的特征，并且内部的设施都是为此而服务的</p><p>拿足球俱乐部举个例子，其实可以把它当成是一个类，那么里面的人，可以看做是类的成员，比如：球员、教练、队医、司机</p><p>而各种设施也是围着球队工作，可以把它们当做是类的方法，比如：球场集体训练、健身房强化锻炼、更衣室冲澡这些都是为这个整体服务，与足球俱乐部这个集体紧密相关</p><p>因此，在<strong>代码层面上的表现</strong>就是：这个类有着<strong>相关性很高的函数（Method）以及数据（Field）</strong></p><p>然而<strong>相关性这一点其实界限很模糊</strong>，因此这往往就依赖于开发者自身理解和工作经验了（）</p><h2 id="2-开闭原则（Open-Close-Principle，OCP）"><a class="header-anchor" href="#2-开闭原则（Open-Close-Principle，OCP）">¶</a>2. 开闭原则（Open Close Principle，OCP）</h2><p>这是Java世界里<strong>最基础</strong>的设计原则</p><blockquote><p>定义：软件中的对象（类、模块、函数等）应对于扩展开放，但是对于修改是封闭的</p></blockquote><p>我认为，这可以理解成对现有的逻辑代码的一种保护，因为现有功能是稳定的，后期的修改应当尽量避免引入新的问题</p><p>当然，在某种程度上，这也显得较为理想化，实际的开发过程却难免会因产品快速迭代与变更需要修改原有内容</p><p>因此，在代码层面为避免引入更多的问题，可以尽量选择扩展，也方便他人对已有内容进行实现</p><h2 id="3-里式替换原则（Liskov-Substitution-Priciple，LSP）"><a class="header-anchor" href="#3-里式替换原则（Liskov-Substitution-Priciple，LSP）">¶</a>3. 里式替换原则（Liskov Substitution Priciple，LSP）</h2><blockquote><p>定义：所有引用基类的地方必须能透明地使用其子类的对象</p></blockquote><p>里氏替换原则主要就是依赖于面向对象语言三大特性中的<strong>继承与多态</strong></p><p>简单点说，就是父类出现的地方统统可以使用其子类进行替代，并且能够正常工作</p><p>有点前人栽树，后人乘凉的意味</p><p>而里氏替换原则的核心则是<strong>抽象</strong></p><p>仅仅需要对应的对象最低限度啊满足它的职责（接口或抽象类的定义）</p><p><strong>优点：</strong></p><ul><li>代码重用，减少创建类的成本，每个子类都拥有父类的方法和属性</li><li>子类满足与父类的共性，同时又拥有自身的个性</li><li>提高了代码的可扩展性</li></ul><p><strong>缺点：</strong></p><ul><li>继承是侵入性的，只要继承就必须拥有父类的所有属性和方法</li><li>子类代码可能冗余，灵活性下降，因为不可避免地拥有父类的属性和方法</li></ul><p>里氏接口替换原则往往和开闭原则紧密相关，很好地支持外部自定义的操作</p><h2 id="4-依赖倒置原则（Dependence-Inversion-Principle，DIP）"><a class="header-anchor" href="#4-依赖倒置原则（Dependence-Inversion-Principle，DIP）">¶</a>4. 依赖倒置原则（Dependence Inversion Principle，DIP）</h2><blockquote><p>定义：依赖倒置原则体现的是一种特定的<strong>解耦方式</strong>，使得高层模块不依赖于底层模块的实现细节</p></blockquote><p>定义看上去很模糊，因此需要根据实际场景进行分解</p><p>首先，有以下关键点需要注意：</p><ul><li>高层模块不应依赖于低层模块，二者应该都依赖于<strong>抽象</strong></li><li>抽象不依赖细节</li><li>细节应当依赖抽象</li></ul><p>如果从Java语言的角度进行理解，抽象无非就是以<strong>接口或者抽象类的形式</strong>进行体现的，主要目的是<strong>明确职责</strong></p><p>所谓<strong>抽象正是代表了一种形式上的东西，需要遵守</strong></p><p>另一方面，细节体现的是<strong>接口的实现类或者是抽象类的实体子类</strong>，它们在<strong>遵守形式的基础上</strong>真正地去<strong>履行自己的职责</strong></p><p>这样，后两条就很清晰了</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220702122051298.png" alt="image-20220702122051298"></p><p>再举个例子，人类可以认为是一个抽象的概念，如果简单点进行定义，可以只有名字、年龄，能吃能睡，这里用了抽象类进行表示</p><p>而程序员，依赖人类的身份（对于People抽象类进行实现），首先履行了人类职责，拥有吃、睡的传统艺能（从父类继承而来），还会敲代码，并且还有账户（另外加的）</p><p>程序员对于吃和睡<strong>有实实在在的行动，而非只是标签</strong>：抢消费券点外卖吃，半夜回家倒头就睡（这便是对于细节的描述）</p><p>而对于第一点，首先要注意<strong>高层次模块和低层次模块的含义</strong></p><p>当一个项目增长到一定的量级，往往会对于其功能进行拆分，以明确代码的职责，也方便业务的扩展和梳理逻辑，减少问题</p><p>通常会将具体业务代码，根据其实现的业务功能进行划分，比如说网络模块、即时通信模块、通用工具模块、线上课程模块等</p><p>越位于下层的模块其本身的独立程度越高，比如通用工具模块，它们作为<strong>功能实现端</strong>，给其他模块调用，就像平时功能不好实现时上github找包一样，只需要关注需要用到的方法，因为具体的功能下层已经实现了（工具已经有了，看你上层怎么用）</p><p>而<strong>上层与下层的关系往往是相对的</strong>，因为你是用东西的人，你的地位高一些，但是更上层还会有人等待着你提供服务</p><p>因此，上层相<strong>对于低层次是调用方</strong></p><p>现在二者都依赖于抽象的意思，如果用Java语言理解，那么应该就是<strong>二者通过接口或抽象类进行交互，而不是直接进行调用</strong></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220702224416704.png" alt="image-20220702224416704"></p><p>原先高层直接调用低层，这就不得不让上层每次都亲自出马（上层主动依赖）</p><p>而现在，上层给了标准，需要人办事，下级直接按标准对号入座，所谓关注结果（上层提供标准，下层实现标准）</p><p>实现<strong>面向接口编程</strong></p><h2 id="5-接口隔离原则（Interface-Segregation-Principle，ISP）"><a class="header-anchor" href="#5-接口隔离原则（Interface-Segregation-Principle，ISP）">¶</a>5. 接口隔离原则（Interface Segregation Principle，ISP）</h2><blockquote><p>定义：类间的依赖关系应该建立在最小的接口上</p></blockquote><p>该原则也仅仅围绕<strong>抽象</strong></p><p>也就是说，对于某一类操作进行调用，那么取能够适配更多的接口，作为参数</p><p>这样，其他实现该接口的类可以直接使用，遵循<strong>里氏替换原则</strong>，而无需关注内部的细节</p><p>接口隔离的目的是<strong>使系统解开耦合，从而容易重构、更改和重新部署</strong></p><p>在Android中，Context经常会被用到，而Activity和Fragment等都是对于Context的某种实现，因此在设计方法的时候，如果需要好的兼容性，并且Activity和Fragment的作用可以用Context替代的话，那么就把Context类型作为参数，因为它是更高层次的抽象，能够应用更多的场景，而无需为每个类型单独考虑</p><p>就像你去公司或健身房一样，门禁并不关注你是谁，男的还是女的，只关注你有没有卡或者录入人脸，因为对于门禁来讲，谁来都一样，没有必要量身定制</p><h2 id="6-迪米特原则（Law-of-Demeter，LOD）"><a class="header-anchor" href="#6-迪米特原则（Law-of-Demeter，LOD）">¶</a>6. 迪米特原则（Law of Demeter，LOD）</h2><blockquote><p>定义：一个对象应该对其他对象有最少的了解</p></blockquote><p>其实这里主要体现出的还是一种抽象与解耦思想</p><p>类与类之间不可避免地会有引用，但是只保留必要的引用</p><p>这就像手机里下载App一样，只保留我们平时需要用的，其他不怎么用的可以删掉，这样才能保持系统整洁干净、易于管理</p><p>并且，让专业的人做专业的事，我们只是应用的用户，功能的内部实现不关注，这便是一层抽象，回到了之前的依赖倒置原则</p><p>也可以看得出，6大原则间其实也是紧密关联的</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AIDL学习之路（一）</title>
      <link href="/2022/06/19/AIDL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/06/19/AIDL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>AIDL学习之路（一）</h1><h2 id="1-简介"><a class="header-anchor" href="#1-简介">¶</a>1. 简介</h2><p><code>AIDL</code>全称为(Android Interface Definition Language)，由此可以看出这应当是一种<strong>定义接口</strong>的语言</p><h2 id="2-具体场景"><a class="header-anchor" href="#2-具体场景">¶</a>2. 具体场景</h2><p>客户端与服务端进行通信时，需要定义<strong>双方都认可的接口</strong>，<code>AIDL</code>这是用来完成这件工作的<strong>工具</strong></p><p><code>AIDL</code>主要应用于<code>IPC</code>，即<strong>进程间通信</strong></p><h3 id="2-1-你是否真的需要AIDL"><a class="header-anchor" href="#2-1-你是否真的需要AIDL">¶</a>2.1. 你是否真的需要AIDL</h3><p>首先，如果并不需要实现IPC，可以直接通过继承<code>Binder</code>类实现<code>client-sever</code>间的通信</p><p>其次，如果的确需要实现IPC，但是无需处理多线程，那么应该通过<code>Messager</code>实现，因为<code>Messager</code>能够保证信息是<strong>串行</strong>的（其实内部也是通过<code>AIDL</code>实现的）</p><p>综上，真正需要使用到<code>AIDL</code>的场景是<strong>IPC</strong>和<strong>并发处理多个请求</strong>并存</p><h2 id="3-使用步骤"><a class="header-anchor" href="#3-使用步骤">¶</a>3. 使用步骤</h2><ol><li>创建<code>.aidl</code>后缀名的文件，定义需要用到的接口</li><li>实现定义的接口</li><li>将接口暴露给客户端使用</li></ol><h3 id="3-1-创建-aidl文件，定义接口"><a class="header-anchor" href="#3-1-创建-aidl文件，定义接口">¶</a>3.1. 创建.aidl文件，定义接口</h3><p>使用AS新建一个空项目，在当前模块的<code>src</code>目录下直接创建一个<code>AIDL</code>文件</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220618164309730.png" alt="image-20220618164309730" style="zoom:80%;" /><p>然后重命名为<code>IRemoteService</code>，因为这是一个接口</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220618164447861.png" alt="image-20220618164447861" style="zoom:80%;" /><p>然后点击<code>Finish</code>完成创建</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220618174858440.png" alt="image-20220618174858440"></p><p>现在项目结构中多了一个<code>aidl</code>目录，下面有一级和<code>java</code>包下包名一样的目录，里面正好就是刚刚创建的<code>aidl</code>文件</p><p>以下为默认的aidl模板，我们来定义自己的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRemoteService.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.minos.aidldemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IRemoteService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">     * and return values in AIDL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">basicTypes</span><span class="params">(<span class="type">int</span> anInt, <span class="type">long</span> aLong, <span class="type">boolean</span> aBoolean, <span class="type">float</span> aFloat,</span></span><br><span class="line"><span class="params">            <span class="type">double</span> aDouble, String aString)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此之前，需要先了解一下<code>AIDL</code>中支持的<strong>基础类型</strong></p><h4 id="3-1-1-支持类型"><a class="header-anchor" href="#3-1-1-支持类型">¶</a>3.1.1. 支持类型</h4><ul><li>所有的基本类型（如int、float等）</li><li>String</li><li>CharSequence</li><li>List</li><li>Map</li></ul><p>其中，对于<code>List</code>，<code>Map</code>这种<strong>复合类型</strong>的要求是其中的元素类型必须为①<strong>前面的支持类型</strong> ，或者是②<strong>其他的AIDL接口类型</strong>，或者是③<strong>已经声明的Parcelable类型</strong></p><p>List -&gt; ArrayList(实例) [支持指定泛型]</p><p>Map -&gt; HashMap(实例) [不支持指定泛型]</p><p>知道了AIDL可以支持的类型，接下来我们开始定义自己的接口</p><p>首先，我们需要定义一个要用到的数据类型，这是需要在进程进行传递的数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Msg</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Msg</span><span class="params">(String msg, <span class="type">int</span> pid)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">        <span class="built_in">this</span>.pid = pid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPid</span><span class="params">(<span class="type">int</span> pid)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pid = pid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接定义了一个常见的Bean类</p><p>但是，如果需要这个数据对象能够在进程间进行传递，那么还需要这个类实现<code>Parcelable</code>接口</p><p>这是Android提供的一种序列化方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Msg</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Msg</span><span class="params">(String msg, <span class="type">int</span> pid)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">        <span class="built_in">this</span>.pid = pid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPid</span><span class="params">(<span class="type">int</span> pid)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pid = pid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">describeContents</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeToParcel</span><span class="params">(Parcel parcel, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        parcel.writeString(<span class="built_in">this</span>.msg);</span><br><span class="line">        parcel.writeInt(<span class="built_in">this</span>.pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Msg</span><span class="params">(Parcel in)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = in.readString();</span><br><span class="line">        <span class="built_in">this</span>.pid = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Msg&gt; CREATOR = <span class="keyword">new</span> <span class="title class_">Parcelable</span>.Creator&lt;Msg&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Msg <span class="title function_">createFromParcel</span><span class="params">(Parcel source)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Msg</span>(source);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Msg[] newArray(<span class="type">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Msg</span>[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把数据对象的结构定义完成后，还需要为这个新定义的数据类型设置一个<strong>同名的AIDL文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.minos.aidldemo;</span><br><span class="line"></span><br><span class="line">parcelable Msg;</span><br></pre></td></tr></table></figure><p>这个文件只声明了刚刚的类型，但是最终并不会参与编译</p><p>由于<code>IRemoteService</code>会用到这个类型，因此还需要<code>import</code>导入一下这个类型</p><p><strong>尽管在同一个包下，也依然需要写<code>import</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRemoteService.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.minos.aidldemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.minos.aidldemo.Msg;   <span class="comment">// 非默认都要导入</span></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IRemoteService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">     * and return values in AIDL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Msg <span class="title function_">getResponse</span><span class="params">()</span>;   <span class="comment">// 定义方法，返回自定义类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，完成AIDL文件的编写工作，开始<code>make</code>对应module</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220618234933788.png" alt="image-20220618234933788"></p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220618235036304.png" alt="image-20220618235036304"></p><p>接下来，SDK会为我们生成对应的Java文件</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220618235316304.png" alt="image-20220618235316304"></p><p>对应module下build的生成文件中可以找到</p><p>大概看一下结构</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220618235400683.png" alt="image-20220618235400683"></p><p>这里系统生成了<code>IRemoteService.java</code>这个文件</p><p>可以看到，里面有一个<code>Stub</code>类</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220619085855544.png" alt="image-20220619085855544"></p><p>这是一个静态抽象类，并且继承了<code>Binder</code>类，并且实现了<code>IRemoteService</code>接口</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220619090614521.png" alt="image-20220619090614521"></p><p><code>asInterface()</code>方法接收一个<code>Binder</code>类型参数，并且将其转化为当前的接口类型返回，即<code>IRemoteService</code></p><h3 id="3-2-实现定义的接口"><a class="header-anchor" href="#3-2-实现定义的接口">¶</a>3.2. 实现定义的接口</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mBinder = <span class="keyword">object</span> : IRemoteService.Stub() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponse</span><span class="params">()</span></span>: Msg &#123;</span><br><span class="line">                <span class="keyword">return</span> Msg(</span><br><span class="line">                    <span class="string">&quot;msg from service at <span class="subst">$&#123;Thread.currentThread().name&#125;</span>\ntid is <span class="subst">$&#123;Thread.currentThread().id&#125;</span>\nmain thread id is <span class="subst">$&#123;mainLooper.thread.id&#125;</span>&quot;</span>,</span><br><span class="line">                    myPid()</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>实现需要用到的接口，即之前定义的，消息中会有线程的信息和进程id</p><h3 id="3-3-将接口暴露给客户端使用"><a class="header-anchor" href="#3-3-将接口暴露给客户端使用">¶</a>3.3. 将接口暴露给客户端使用</h3><p>接下来创建一个服务，叫<code>RemoteService</code></p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220619092515055.png" alt="image-20220619092515055" style="zoom:80%;" /><p>随后在<code>onBind()</code>中返回之前实现的接口</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mBinder = <span class="keyword">object</span> : IRemoteService.Stub() &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponse</span><span class="params">()</span></span>: Msg &#123;</span><br><span class="line">          <span class="keyword">return</span> Msg(</span><br><span class="line">              <span class="string">&quot;msg from service at <span class="subst">$&#123;Thread.currentThread().name&#125;</span>\ntid is <span class="subst">$&#123;Thread.currentThread().id&#125;</span>\nmain thread id is <span class="subst">$&#123;mainLooper.thread.id&#125;</span>&quot;</span>,</span><br><span class="line">              Process.myPid()</span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>)</span></span>: IBinder &#123;</span><br><span class="line">      <span class="keyword">return</span> mBinder   <span class="comment">// 返回Binder</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后编写<code>Activity</code>模仿一下客户端</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;等待...&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;24sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;显示进程ID&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;@+id/textView&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/textView&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button2&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:capitalize</span>=<span class="string">&quot;sentences&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;GetResponse&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textAllCaps</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/button&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220619093406935.png" alt="image-20220619093406935"></p><p>然后，编写一下业务</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.minos.aidldemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.<span class="keyword">annotation</span>.SuppressLint</span><br><span class="line"><span class="keyword">import</span> android.content.ComponentName</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.content.ServiceConnection</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder</span><br><span class="line"><span class="keyword">import</span> android.os.Process.myPid</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> android.widget.Button</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mRemoteService: IRemoteService? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mBind = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mPidText: TextView</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mBtnShowPid: Button</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> mBtnGetResponse: Button</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mConnection: ServiceConnection = <span class="keyword">object</span> : ServiceConnection &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(name: <span class="type">ComponentName</span>, service: <span class="type">IBinder</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 返回接口的引用，后面通过该引用就可以进行操作了</span></span><br><span class="line">            mRemoteService = IRemoteService.Stub.asInterface(service)</span><br><span class="line">            mBind = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(name: <span class="type">ComponentName</span>)</span></span> &#123;</span><br><span class="line">            mRemoteService = <span class="literal">null</span></span><br><span class="line">            mBind = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint(<span class="string">&quot;SetTextI18n&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        mPidText = findViewById(R.id.textView)</span><br><span class="line">        mPidText.text = <span class="string">&quot;the client pid is <span class="subst">$&#123;myPid()&#125;</span>&quot;</span></span><br><span class="line">        mBtnShowPid = findViewById(R.id.button)</span><br><span class="line">        mBtnShowPid.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (mBind) &#123;</span><br><span class="line">                Log.i(<span class="string">&quot;RemoteServiceMsg&quot;</span>, <span class="string">&quot;the service pid is <span class="subst">$&#123;mRemoteService?.response?.pid&#125;</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mBtnGetResponse = findViewById(R.id.button2)</span><br><span class="line">        mBtnGetResponse.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (mBind) &#123;</span><br><span class="line">                Log.i(<span class="string">&quot;RemoteServiceMsg&quot;</span>, <span class="string">&quot;<span class="subst">$&#123;mRemoteService?.response?.msg&#125;</span>&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart()</span><br><span class="line">        <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, RemoteService::<span class="keyword">class</span>.java)</span><br><span class="line">        bindService(intent, mConnection, BIND_AUTO_CREATE)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop()</span><br><span class="line">        unbindService(mConnection)</span><br><span class="line">        mBind = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mRemoteService = IRemoteService.Stub.asInterface(service)</code>这一句是关键所在，客户端的操作主要是利用该接口的引用执行方法的调用</p><p>如果是<strong>非跨进程</strong>的情况下，这里可以直接使用<strong>强制类型转换</strong></p><p>接下来，再到清单文件中修改注册条件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:name</span>=<span class="string">&quot;.RemoteService&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:process</span>=<span class="string">&quot;:remote&quot;</span>   &lt;!<span class="attr">--</span>指定运行到另一进程<span class="attr">--</span>&gt;</span></span><br><span class="line">           android:enabled=&quot;true&quot;</span><br><span class="line">           android:exported=&quot;true&quot; /&gt;</span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">               <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在Activity扮演客户端，而Service扮演另一进程的服务端</p><p>接下来运行项目</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220619100247704.png" alt="image-20220619100247704"></p><p>这边是我们的两个进程，3010是Activity所在的进程，而3052是Service所在进程</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/image-20220619100418790.png" alt="image-20220619100418790"></p><p>点击一下“显示进程ID”按钮，这是另一进程中Service返回的消息</p><p><img src="C:%5CUsers%5CMinos%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220619100504780.png" alt="image-20220619100504780"></p><p>接着，再点击”GetResponse“</p><p><img src="C:%5CUsers%5CMinos%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220619100922653.png" alt="image-20220619100922653"></p><p>如果<strong>非跨进程通信，一定为主线程</strong>，跨进程的时候处理的线程便无法预测了</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么学Unity开发（四）</title>
      <link href="/2022/05/01/%E6%80%8E%E4%B9%88%E5%AD%A6Unity%E5%BC%80%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2022/05/01/%E6%80%8E%E4%B9%88%E5%AD%A6Unity%E5%BC%80%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>怎么学Unity开发（四）</h1><h2 id="1-组件介绍"><a class="header-anchor" href="#1-组件介绍">¶</a>1. 组件介绍</h2><p>组件对应的就是功能，每个游戏物体都可以看作是空物体 + 若干个具有特定功能的组件</p><h3 id="1-1-系统预置组件"><a class="header-anchor" href="#1-1-系统预置组件">¶</a>1.1. 系统预置组件</h3><p>在任意一个游戏物体的检查器里，可以找到“添加组件”按钮，里面的组件就是系统提供的预置组件</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204242247221.png" alt="image-20220424224739091" style="zoom:50%;" /><h3 id="1-2-自行编写的脚本组件"><a class="header-anchor" href="#1-2-自行编写的脚本组件">¶</a>1.2. 自行编写的脚本组件</h3><p>当系统提供的组件无法满足需求时，通常就需要自己编写<code>C#脚本</code>作为自定义的组件</p><h3 id="1-3-Transform组件"><a class="header-anchor" href="#1-3-Transform组件">¶</a>1.3. Transform组件</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204250801890.png" alt="image-20220425080151814" style="zoom:50%;" /><p>无论什么游戏对象，在出生的时候都会自带一个<code>Transform</code>组件，即使是空对象也是如此</p><p><code>Tansform</code>组件描述了当前对象在场景中的位置以及呈现的姿态等属性</p><h2 id="2-添加预置组件"><a class="header-anchor" href="#2-添加预置组件">¶</a>2. 添加预置组件</h2><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204250817541.png" alt="image-20220425081137453" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204250817909.png" alt="image-20220425081217966" style="zoom: 40%;" /></p><p>这两处都可以进行组件的添加</p><p>先准备一个空物体，然后加上一个<code>Mesh Filter</code></p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204250814923.png" alt="image-20220425081419891" style="zoom:50%;" /><p>该组件可以选择一种网格的外观给当前的游戏对象，这里可以选一个<code>Sphere</code></p><p>但是，仅仅选中网格，没有渲染器并不能够看见，因此继续添加一个<code>Mesh Renderer</code>组件</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204250817203.png" alt="image-20220425081711169" style="zoom:50%;" /><p>这样，就可以看到这个物体了</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204292230286.png" alt="image-20220429223038164" style="zoom:33%;" /><p>但是，现在没有为其添加材质，因此看起来与其他直接创建的球在外观上有些不一样，这里可以直接创建个材质加上</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204292232532.png" alt="image-20220429223247506" style="zoom:50%;" /><p>这里选择这种默认材质，与平常创建的几何体用的是同款</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204292234271.png" style="zoom:50%;" /><p>这样，在外观上基本是保持一致了</p><h2 id="3-组件状态控制"><a class="header-anchor" href="#3-组件状态控制">¶</a>3. 组件状态控制</h2><p>在一些组件的面板上，会有这种复选框</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204292236553.png" alt="image-20220429223618505" style="zoom:50%;" /><p>用来设置当前组件的<strong>启用或禁用</strong></p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204292237235.png" alt="image-20220429223754185" style="zoom:50%;" /><p>并且在游戏物体上也有一个复选框，用于<strong>表示整个游戏物体的启用和禁用</strong>，组件当然是隶属于对应的游戏物体的</p><p>一旦禁用，游戏物体会被置灰，并且消失在场景当中</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204292240970.png" alt="image-20220429224025924" style="zoom:50%;" /><p>由于被禁用，处于一种不可选中的状态下</p><h2 id="4-组件的复制粘贴"><a class="header-anchor" href="#4-组件的复制粘贴">¶</a>4. 组件的复制粘贴</h2><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204292246223.png" alt="image-20220429224628173" style="zoom:50%;" /><p>可以通过复制组件组件从一个物体复制到另一个物体上</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204292251794.png" alt="image-20220429225109751" style="zoom:50%;" /><p>然后在另一个物体上将组件粘贴为新组件，这样会将复制的组件作为一个新的组件添加到该物体上</p><p>除此之外，如果在原来的物体的组件上更新了参数的值，想要将这些参数的值更新的现在物体对应的那个组件上，可以同样执行组件的复制操作，只是粘贴的步骤有所不同</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204292256809.png" alt="image-20220429225659762" style="zoom: 50%;" /><p>在判断出组件相同的情况下，可以<strong>无需再创建一个新组件</strong>，只是将组件对应的参数的值更新的当前的组件中</p><h2 id="5-添加脚本组件"><a class="header-anchor" href="#5-添加脚本组件">¶</a>5. 添加脚本组件</h2><p>创建脚本组件往往是由于系统的组件无法满足业务的需求，创建方式也很简单</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204292306640.png" alt="image-20220429230615612" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204292305344.png" alt="image-20220429230454215" style="zoom:50%;" /><p>都可以直接新建或添加一个脚本组件</p><p>创建完脚本文件之后可以双击关联一下，这个时候会调起<code>Visual Studio</code>，打开对应的类</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204292312892.png" alt="image-20220429231233829" style="zoom: 33%;" /><blockquote><p>类的名称要确保与脚本文件的名称一致，否则会出问题，在外部修改.cs文件的名称时，里面的类名并不会跟着变，因此一定要注意**.cs文件的名称需要与类的名称一致**</p></blockquote><h2 id="6-脚本的生命周期"><a class="header-anchor" href="#6-脚本的生命周期">¶</a>6. 脚本的生命周期</h2><p>终于可以看代码了，直接打开之前的脚本组件对应的.cs脚本</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hello</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上有两个最为常用的声明周期方法<code>Start()</code>和<code>Update()</code></p><p>为了了解其调用，需要使用<code>Debug.Log()</code>方法进行日志的输出，在控制台上打印调试信息，以此了解声明周期的调用</p><h3 id="6-1-概览"><a class="header-anchor" href="#6-1-概览">¶</a>6.1. 概览</h3><h4 id="Awake"><a class="header-anchor" href="#Awake">¶</a>Awake()</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;Awake&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，<code>Awake()</code>在生命周期中会是<strong>最早被调用的</strong>，像是刚刚出生、苏醒过来，并且生命周期当中<strong>仅调用一次</strong></p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204301733210.png" alt="image-20220430173308088" style="zoom:50%;" /><p>可以看到，控制台中的打印信息，<code>Awake()先于Start()</code>输出</p><h4 id="OnEnable"><a class="header-anchor" href="#OnEnable">¶</a>OnEnable()</h4><p>组件激活后调用一次，如果组件处于启用，在<code>Awake()</code>之后会被调用</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204301752428.png" alt="image-20220430174958558" style="zoom:50%;" /><p>由于当前的组件已被启用，因此在<code>Awake()</code>和<code>Start()</code>之间插入了<code>OnEnable()</code></p><h4 id="Start"><a class="header-anchor" href="#Start">¶</a>Start()</h4><p>在<code>OnEnable()</code>之后调用，生命周期中<strong>只调用一次</strong>，通常处理初始化相关的操作，会在更新前被调用</p><h4 id="FixedUpdate"><a class="header-anchor" href="#FixedUpdate">¶</a>FixedUpdate()</h4><p>以固定的时间间隔进行刷新，这个间隔可以在项目设置中找到</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204301814342.png" alt="image-20220430181429298" style="zoom: 33%;" /><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204301816573.png" alt="image-20220430181600540" style="zoom:50%;" /><p>更新所处的阶段是在<code>Start()</code>之后，每隔0.02s更新一次，这种更新无关性能，只是<strong>固定的时间间隔</strong></p><h4 id="Update-和LateUpdate"><a class="header-anchor" href="#Update-和LateUpdate">¶</a>Update()和LateUpdate()</h4><p>这两个方法总是捆绑在一起，与性能有关，每一帧调用一次，时间间隔通常不等</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204301849243.png" alt="image-20220430184932193" style="zoom:50%;" /><p>可以关注到，<code>Update()</code>和<code>LateUpdate()</code>调用了相同的次数，<code>LateUpdate()</code>总是跟在<code>Update()</code>的后面</p><h4 id="OnDisable"><a class="header-anchor" href="#OnDisable">¶</a>OnDisable()</h4><p>该状态与<code>OnEnable()</code>正好相反，代表组件的禁用，组件改变禁用状态也会触发<code>onEnale()</code>和<code>onDisable()</code>之间的切换</p><h4 id="OnDestroy"><a class="header-anchor" href="#OnDestroy">¶</a>OnDestroy()</h4><p>组件的生命周期中调用的最后一个方法，代表组价生命的终结</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204301936795.png" alt="image-20220430193619744" style="zoom:50%;" /><p>将游戏物体从场景中删除，依次触发<code>OnDisable()</code>和<code>OnDestroy()</code></p><h3 id="6-2-多个脚本的场景"><a class="header-anchor" href="#6-2-多个脚本的场景">¶</a>6.2. 多个脚本的场景</h3><p>如果有多个脚本在组件上，这个时候如果需要控制执行的顺序应该怎样做呢？</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204302209466.png" alt="image-20220430220915425" style="zoom:50%;" /><p>这两个脚本只做一件事：打印生命周期，可以发现在第一个脚本<code>onEnable()</code>结束后，第二个脚本才开始，但是可以发现，都是所有脚本的<code>Awake()</code>结束后，才会回调<code>Start()</code>，脚本根据类型回调，可以考虑通过这个来控制顺序</p><p>除此以外，如果想要更加有条理地控制脚本的顺序，也可以借助项目设置里面的功能对执行顺序进行控制</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204302220929.png" alt="image-20220430222007877" style="zoom:50%;" /><p>将需要控制顺序的脚本放入其中，右边数字小的就先执行，也可直接进行拖拽，上面的总会是数字小的</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204302234968.png" alt="image-20220430223443918" style="zoom:50%;" /><p>然后应用变更，就能够按照设置的顺序进行执行</p><h2 id="7-标记"><a class="header-anchor" href="#7-标记">¶</a>7. 标记</h2><h3 id="7-1-名称标记"><a class="header-anchor" href="#7-1-名称标记">¶</a>7.1. 名称标记</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204302252391.png" alt="image-20220430225257342" style="zoom: 50%;" /><p>通过设置标记，方便找到物体或分类，效果就像是超市货架上的商品一样</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204302254673.png" alt="image-20220430225404622" style="zoom:50%;" /><h3 id="7-2-标签"><a class="header-anchor" href="#7-2-标签">¶</a>7.2. 标签</h3><p>主要用作游戏物体的标识符，可以方便脚本对游戏物体进行获取以及判断</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204302257590.png" alt="image-20220430225712550" style="zoom:50%;" /><p>也可以添加各种自定义的标签，标签不一定唯一，也可能表示一类对象</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204302300636.png" alt="image-20220430230002583" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204302300191.png" alt="image-20220430230054148" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204302301100.png" alt="image-20220430230131048" style="zoom:50%;" /><h3 id="7-3-图层"><a class="header-anchor" href="#7-3-图层">¶</a>7.3. 图层</h3><p>相较于标签，图层相当于直接将游戏物体进行<strong>分组</strong>（通常是比较重要的类型）</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204302303965.png" alt="image-20220430230353924" style="zoom:50%;" /><p>可以添加图层进行游戏对象分组，前几层一般是系统使用的，通常在Layer6开始添加，并且最多到Layer31</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204302304802.png" alt="image-20220430230450759" style="zoom: 33%;" /><p>在添加完图层后，可以将需要分到一起的游戏对象塞到对应的层中</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204302311975.png" alt="image-20220430231133906" style="zoom:50%;" /><p>图层的一个常用的场景在摄像机对于内容的过滤方面</p><img src="/Users/shenzhisheng/Library/Application Support/typora-user-images/image-20220430231252034.png" alt="image-20220430231252034" style="zoom:50%;" /><p>通常情况下，<code>Culling Mask</code>是Everything，这样会把所有场景拍摄到其中</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204302318557.png" alt="image-20220430231827519" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204302319083.png" alt="image-20220430231921038" style="zoom:50%;" /><p>但是这个时候对于其中的图层进行取消选择，对应的游戏物体就不会出现在摄像机的视野当中了</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204302318181.png" alt="image-20220430231803129" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么学Unity开发（三）</title>
      <link href="/2022/04/23/%E6%80%8E%E4%B9%88%E5%AD%A6Unity%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2022/04/23/%E6%80%8E%E4%B9%88%E5%AD%A6Unity%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>怎么学Unity开发（三）</h1><h1>1. 地形系统</h1><p>大型的3D游戏往往离不开丰富的地形，尤其是开放世界类型，会有丰富的地形供玩家进行探索</p><h3 id="1-1-准备工作"><a class="header-anchor" href="#1-1-准备工作">¶</a>1.1. 准备工作</h3><p>这里又重新创建了一个3D游戏的项目，然后去到Unity的资源商城里去搜索一些资源</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204222259829.png" alt="image-20220422225910756" style="zoom: 33%;" /><p>其实需要的呢也就是官方提供的这套标准资源</p><p>使用方面按照之前的流程进行资源导入，然后勾选上需要用到的资源类型，进行确认</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204222306646.png" alt="image-20220422230628587" style="zoom: 33%;" /><p>这里仅仅选中这些资源当中的环境类资源就足够使用了</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204222308935.png" alt="image-20220422230837889" style="zoom:50%;" /><p>此时，可以着手创建地形</p><h3 id="1-2-地形创建"><a class="header-anchor" href="#1-2-地形创建">¶</a>1.2. 地形创建</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232317427.png" alt="image-20220423110230027" style="zoom: 33%;" /><p>接下来在场景中创建地形对象</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204231104312.png" alt="image-20220423110422279" style="zoom:50%;" /><p>场景中随后生成了一个巨大的平面，这就是地形对象</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232318248.png" alt="image-20220423110554664" style="zoom:33%;" /><p>点开该对象的属性，并切换到设置一栏，可以看到地形对象上的一些参数</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232318873.png" alt="image-20220423110641873" style="zoom:50%;" /><p>向下滚动，可以找到有关当前地形对象大小的信息</p><p>刚刚创建出来的地形对象的长和宽都是1000，高度为600</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204231111522.png" alt="image-20220423111133486" style="zoom:33%;" /><p>创建的小立方体默认大小是1 * 1，因此可以发现地形这个平面是有多大了</p><h3 id="1-3-地形编辑"><a class="header-anchor" href="#1-3-地形编辑">¶</a>1.3. 地形编辑</h3><p>对于地形的编辑工作主要通过该面板完成</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204231113603.png" alt="image-20220423111341564" style="zoom:50%;" /><h4 id="1-3-1-创建相邻的地形"><a class="header-anchor" href="#1-3-1-创建相邻的地形">¶</a>1.3.1. 创建相邻的地形</h4><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204231115018.png" alt="image-20220423111555986" style="zoom:50%;" /><p>第一个按钮用于创建相邻的地形</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204231125078.png" alt="image-20220423112551033" style="zoom:50%;" /><p>选中后当前地形的几个相邻区域高亮显示，点击可用于快速扩张地形</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204231129395.png" alt="image-20220423112910358" style="zoom:50%;" /><p>添加后，相邻区域也增加了，每一次添加都会伴随着地形文件的创建</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232319501.png" alt="image-20220423113152759" style="zoom:33%;" /><blockquote><p><strong>注意</strong></p><p>如果要删除，Assets目录下添加的地形文件不会删除，需要手动清除</p></blockquote><h4 id="1-3-2-绘制地形"><a class="header-anchor" href="#1-3-2-绘制地形">¶</a>1.3.2. 绘制地形</h4><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204231133648.png" alt="image-20220423113312606" style="zoom: 50%;" /><p>绘制地形的内容是最丰富的也是最有趣的</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204231137135.png" alt="image-20220423113708096" style="zoom:50%;" /><h5 id="抬高或降低"><a class="header-anchor" href="#抬高或降低">¶</a>抬高或降低</h5><p>这个类型笔刷主要用于绘制山峰和盆地，大致勾勒出地形的高度、轮廓</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204231139079.png" alt="image-20220423113944040" style="zoom:50%;" /><p>绘制前需要准备一下笔刷，这里的笔刷有几个属性</p><ul><li>笔刷的形状：就是每一笔点下去形状，通常用的多的是圆形，当然，边缘一般比较柔和，显得更加自然</li><li>笔刷的尺寸：也就是笔头的粗细，笔头粗的处理大面积的区域填充，笔头细的主要便于勾勒细节</li><li>不透明度（或者可以理解为笔刷的硬度）：硬度越高，高度的变化越剧烈；硬度越低，则越平缓</li></ul><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232323686.png" alt="image-20220423114642055" style="zoom: 50%;" /><p>左侧的笔刷硬度较高，更容易绘制出陡峭的地形，右边的更柔和，可以表现出平缓的山坡</p><p>另外，笔刷绘制时加上<code>Shift</code>，表现出地形的下降</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204231151902.png" alt="image-20220423115101874" style="zoom:50%;" /><h5 id="绘制洞"><a class="header-anchor" href="#绘制洞">¶</a>绘制洞</h5><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204231153407.png" alt="image-20220423115324364" style="zoom:50%;" /><p>这个功能的主要作用就是在地形上凿一个洞，实际上就是删除部分面</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204231155437.png" alt="image-20220423115505393" style="zoom:50%;" /><p>直接去掉的是这块地形模型的面，显得太过突兀，需要山洞之类的模型放置进来进行填补和平滑</p><h5 id="设置高度"><a class="header-anchor" href="#设置高度">¶</a>设置高度</h5><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204231901737.png" alt="image-20220423190157690" style="zoom:50%;" /><p>这里相当于是设置了绘制的高度上限，比如说把高度修改为100</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204231903730.png" alt="image-20220423190345693" style="zoom:50%;" /><p>那么在当前的场景中，所能够绘制的最大高度就被限制在了100，于是就产生了这样一个平台</p><p>另外，还可以使用该功能进行高度采样，只需要在需要取样的高度的位置点击的同时按住<code>Shift</code>，就能够进行高度取样，此时高度就会被采集到Height的位置</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204231920037.png" alt="image-20220423192040985" style="zoom:50%;" /><p>并且<code>Flatten Tile</code>展平的功能也较为常用，可以将当前地形的整体平面展平，然后设置到指定的高度，<code>Flatten All</code>则可以影响到其他相邻地形</p><p>这个最经常用的场景就是在地形绘制前，设置整体的高度就比较方便挖坑，然后设置一些池塘、湖泊等低洼地带</p><h5 id="平滑地形"><a class="header-anchor" href="#平滑地形">¶</a>平滑地形</h5><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204231929479.png" alt="image-20220423192951432" style="zoom:50%;" /><p>主要用来对于地形进行抛光</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204231934279.png" alt="image-20220423193432235" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204231935550.png" alt="image-20220423193536511" style="zoom:50%;" /><p>在面板中有一个可以调节模糊方向的属性，靠近-1，对于山尖的削弱作用明显，会变秃，而靠近1，对于山尖周围的削弱更明显，山尖会更尖</p><h5 id="绘制纹理"><a class="header-anchor" href="#绘制纹理">¶</a>绘制纹理</h5><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232147045.png" alt="image-20220423214731006" style="zoom: 50%;" /><p>这个过程相当于是给地形上色，这里给地形上色的过程是通过<strong>地形层级</strong>完成的，涉及到样式、上色往往离不开层级的概念，绘画的小伙伴应该都深有体会</p><p>首先，需要县创建一个层级</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232156093.png" alt="image-20220423215643047" style="zoom:50%;" /><p>此时，选中并添加了一个层</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232200373.png" alt="image-20220423220014320" style="zoom:50%;" /><p>然后整体地形都会被应用上该纹理</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232159842.png" alt="image-20220423215945794" style="zoom:50%;" /><p>当然，通常的纹理层级都不是单层的，往往会有各种内容，比如可能这里会有山间小道</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232204421.png" alt="image-20220423220451374" style="zoom: 50%;" /><p>这个时候就添加一个山间小道的纹理层级，用于绘制小路</p><blockquote><p><strong>注意</strong></p><p>这里的几个层间可以像调色板一样进行切换，使用不同的纹理进行绘制</p></blockquote><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232320370.png" alt="image-20220423220719636" style="zoom:50%;" /><h4 id="1-3-3-种树"><a class="header-anchor" href="#1-3-3-种树">¶</a>1.3.3. 种树</h4><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232214305.png" alt="image-20220423221402260" style="zoom:50%;" /><p>切换到种树的Tab下，然后选择树的模型</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232219682.png" alt="image-20220423221917635" style="zoom: 50%;" /><p>这里使用资源包下的内容</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232221866.png" alt="image-20220423222120826" style="zoom:50%;" /><p>此时，也是可以选择多种类型进行切换</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232222534.png" alt="image-20220423222242494" style="zoom:50%;" /><p>在面板的下方会有关于树的一些属性可以调节，由于这些树是通过笔刷进行绘制的，因此点一下会生成多棵树，可以通过调节笔刷的大小和树的密度，控制间距和疏密程度</p><p>树木的高度、树木旋转的角度、以及颜色往往给定一个范围，然后在此范围内进行随机生成，这样往往显得更加自然</p><p>树木的宽高比多数情况情况是锁定的，这其实代表生成的树在随机生成的过程中伴随着尺寸的变化，依然是进行等比例的缩放，将其取消可以生成一些宽高比更加多样的树木的类型，这个当然还是视自己的需求而定</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232240115.png" alt="image-20220423224030055" style="zoom:50%;" /><p>这样非常方便地生成了一个小树林</p><p>而在这样的场景中浏览，可以使用鼠标右键按住，然后利用<code>WASD</code>在场景中进行移动，并且按住<code>Shift</code>可以进行疾跑，在像地形这种面积比较大的模型中使用也是很有必要的</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232246089.png" alt="image-20220423224604032" style="zoom:50%;" /><p>另外还有这样一个按钮，可以在当前的地形直接弄来大量的树，这个通常用于森林场景的快速构建，会很方便</p><h4 id="1-3-4-绘制细节"><a class="header-anchor" href="#1-3-4-绘制细节">¶</a>1.3.4. 绘制细节</h4><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232255927.png" alt="image-20220423225500885" style="zoom:50%;" /><p>往往用来绘制草皮，毕竟之前的纹理仅仅是一张壁纸</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232257384.png" alt="image-20220423225730343" style="zoom:50%;" /><p>然后这里选择一种草纹理添加并绘制，整个过程和树似乎区别不大</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232259258.png" alt="image-20220423225940207" style="zoom:50%;" /><p>这里不透明度代表的依然是笔刷的硬度，也就是这一刷下去的草的疏密情况，而后一个属性目标强度，实际上是设置了一个上限，意味着最终的草的密度不能够超过多少，比如说拿着笔刷在同一块地方反复刷，不会导致该区域的草过于密，其实这应该是考虑到一个绘制过程的简化，这样就可以随便涂，不用担心画的不均匀，就像在PS中创建新的图层一样，不用担心会画脏其他部分，可以在该图层放肆涂色一样，还是很好用的😄</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204232320968.png" alt="image-20220423230848664" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么学Unity开发（二）</title>
      <link href="/2022/04/22/%E6%80%8E%E4%B9%88%E5%AD%A6Unity%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/04/22/%E6%80%8E%E4%B9%88%E5%AD%A6Unity%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>怎么学Unity开发（二）</h1><h2 id="1-资源"><a class="header-anchor" href="#1-资源">¶</a>1. 资源</h2><p><code>Assets</code>目录的文件对应关系，与文件浏览器打开的内容是一一对应的，这里存放着整个游戏会用到的所有资源</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204202240982.png" alt="image-20220420224006873" style="zoom: 50%;" /><h3 id="1-1-导入导出资源"><a class="header-anchor" href="#1-1-导入导出资源">¶</a>1.1. 导入导出资源</h3><p>在<code>Assets</code>中选中所有需要导出的资源，右键<code>Export Package</code></p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204202249388.png" alt="image-20220420224902345" style="zoom: 50%;" /><p>再次确认一下内容</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204202254549.png" alt="image-20220420225454508" style="zoom:50%;" /><p>选择名称以及导出的路径，会生成如下文件</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204202259377.png" alt="image-20220420225945340" style="zoom: 33%;" /><p>先把资源文件夹中原来的文件删了，否则系统检测到已有是不会再导的</p><p>然后双击刚刚导出的文件</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204202302026.png" alt="image-20220420230253999" style="zoom: 33%;" /><p>然后选择文件，导入资源</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204202304067.png" alt="image-20220420230415021" style="zoom:50%;" /><p>通过导入的方式，这些资源又回来了</p><h2 id="2-材质概览"><a class="header-anchor" href="#2-材质概览">¶</a>2. 材质概览</h2><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204202320600.png" alt="image-20220420232048563" style="zoom:33%;" /><p>选中场景中的某个游戏对象，可以在<code>Inspector</code>面板中看到其对应的材质</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204202322365.png" alt="image-20220420232217327" style="zoom:50%;" /><p>默认材质不好修改，因此再创建一个新的材质</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204210758820.png" alt="image-20220421075826776" style="zoom: 50%;" /><p><code>Assets</code>目录下创建一个材质文件夹</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204210800676.png" alt="image-20220421080044642" style="zoom: 33%;" /><p>直接右击，创建一个新材质</p><p>​<img src="/Users/shenzhisheng/Library/Application Support/typora-user-images/image-20220421080243721.png" alt="image-20220421080243721" style="zoom:50%;" /></p><p>创建完成后可以调节颜色，在外侧的色环上调节色相，然后再在内部的方框中调节明暗和饱和度</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204210804023.png" alt="image-20220421080450997" style="zoom:50%;" /><p>显示在场景中的物体实际上都是网格体，通过材质为其着色，而负责着色工作的便是<strong>着色器</strong></p><p>之后可以通过编写脚本编写自己的着色器</p><h2 id="3-学习使用资源商店"><a class="header-anchor" href="#3-学习使用资源商店">¶</a>3. 学习使用资源商店</h2><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204212245790.png" style="zoom:50%;" /><p><code>Asset Store</code>就是Unity经常会用到的资源商店</p><p><a href="https://assetstore.unity.com">资源商店（https://assetstore.unity.com）</a></p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204212253500.png" alt="image-20220421225359456" style="zoom:67%;" /><p>不知怎么的，眼前一亮</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204212300160.png" alt="image-20220421230026115" style="zoom:50%;" /><p>然后再在白嫖资源中找一个喜欢的，比方说这个</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204212303902.png" alt="image-20220421230349862" style="zoom:50%;" /><p>点击进到详情页</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204212307306.png" alt="image-20220421230728264" style="zoom:67%;" /><p>选择”添加至我的资源”，一会儿就可以去包管理器找它了</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204212313421.png" alt="image-20220421231319385" style="zoom:50%;" /><p>找到刚刚商城下面的包管理器</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204212314507.png" alt="image-20220421231434465" style="zoom:50%;" /><p>打开后选择<code>My Assets</code>就可以找到从商城添加的各种资源，可以看到刚刚添加的资源</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204212316437.png" alt="image-20220421231659402" style="zoom: 33%;" /><p>然后点击右下角进行下载</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204212326403.png" alt="image-20220421232615339" style="zoom:50%;" /><p>下载完成后，可将资源导入到项目中</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204212327356.png" alt="image-20220421232746314" style="zoom: 33%;" /><p>勾选需要的内容，导入的部分和之前一样，就不重复操作了</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么学Unity开发（一）</title>
      <link href="/2022/04/19/%E6%80%8E%E4%B9%88%E5%AD%A6Unity%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/04/19/%E6%80%8E%E4%B9%88%E5%AD%A6Unity%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>怎么学Unity开发（一）</h1><h2 id="1-创建一个新项目"><a class="header-anchor" href="#1-创建一个新项目">¶</a>1. 创建一个新项目</h2><p>首先打开新建项目的页面，里面会有很多游戏模板可供选择</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171652306.png" style="zoom: 33%;" /><p>直接选用3D模板进行接下来的开发</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171701337.png" alt="image-20220417170128306" style="zoom: 50%;" /><p>给项目起个名字，然后指定一个存放路径，完成后点击”创建项目“</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171703111.png" alt="image-20220417170358066"></p><p>等待一段时间之后，编辑器会被激活，打开以上界面，项目创建完成</p><h2 id="2-常用设置"><a class="header-anchor" href="#2-常用设置">¶</a>2. 常用设置</h2><p>一个功能复杂的工具往往只需要熟悉一些常用的功能就可以很好得进行运用，其他的内容总是能够在日日复一日的积累和使用中不断加深印象，逐渐形成个人的习惯和体系</p><h3 id="2-1-首选项"><a class="header-anchor" href="#2-1-首选项">¶</a>2.1. 首选项</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171844852.png" alt="image-20220417184422814" style="zoom:50%;" /><p>这里面主要包含了编辑器工具的一些属性设置，主要体现了一些个人偏好，比如：界面的配色、显示内容使用的语言等</p><h3 id="2-2-项目设置"><a class="header-anchor" href="#2-2-项目设置">¶</a>2.2. 项目设置</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171847888.png" alt="image-20220417184715865" style="zoom:40%;" /><p>这里的设置内容往往是关联当前的这个项目的，比如：场景、物理、输出质量等</p><h3 id="2-3-资源"><a class="header-anchor" href="#2-3-资源">¶</a>2.3. 资源</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171851628.png" alt="image-20220417185152560" style="zoom:40%;" /><p>用得比较多的可能是一些游戏资源的创建，以及游戏资源、素材的导入导出功能</p><h3 id="2-4-游戏对象"><a class="header-anchor" href="#2-4-游戏对象">¶</a>2.4. 游戏对象</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171854598.png" alt="image-20220417185450569" style="zoom:50%;" /><p>游戏对象最终需要在场景中扮演角色，根据其功能和外观可以分为多个类型，也是<strong>最需要被关注的内容</strong></p><h3 id="2-5-组件"><a class="header-anchor" href="#2-5-组件">¶</a>2.5. 组件</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171858344.png" alt="image-20220417185801309" style="zoom:50%;" /><p>组件要依赖于游戏对象，因此只有在选定相应的游戏对象之后，其功能才会可用，主要用于丰富游戏对象的功能和结构</p><h3 id="2-6-窗口"><a class="header-anchor" href="#2-6-窗口">¶</a>2.6. 窗口</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171900877.png" alt="image-20220417190057842" style="zoom:33%;" /><p>主要功能是对于窗口的管理，调整布局、包管理器以及一些窗口可见性的控制</p><h2 id="3-界面划分"><a class="header-anchor" href="#3-界面划分">¶</a>3. 界面划分</h2><h3 id="3-1-运行控制"><a class="header-anchor" href="#3-1-运行控制">¶</a>3.1. 运行控制</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171908664.png" alt="image-20220417190850621" style="zoom:50%;" /><p>这个界面非常简洁，主要就是控制游戏的运行</p><h3 id="3-2-视口"><a class="header-anchor" href="#3-2-视口">¶</a>3.2. 视口</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171911649.png" alt="image-20220417191140613" style="zoom: 33%;" /><p>这个区域往往是占比最大的，游戏世界就是通过这个界面来进行展现的。</p><p><code>Scene</code>是用来向开发者展示游戏的搭建情况，方便浏览和定位；而<code>Game</code>展示的玩家的视角，用来给目标用户看的</p><h3 id="3-3-层级面板"><a class="header-anchor" href="#3-3-层级面板">¶</a>3.3. 层级面板</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171910917.png" alt="image-20220417191037877" style="zoom:50%;" /><p>这个面板的内容是与视口对应的，放置到视口的游戏对象都会以列表的形式展现在这个面板上，也可以很清晰看到对象间的层级关系</p><p>在游戏对象很多、场景很复杂的情况下，使用层级面板无疑会更有效率</p><h3 id="3-4-项目面板"><a class="header-anchor" href="#3-4-项目面板">¶</a>3.4. 项目面板</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171920154.png" alt="image-20220417192043117" style="zoom: 50%;" /><p>一个游戏下载下来，在它的目录下可以找到许多资源的目录，这些目录提供的是用于支持游戏的一些静态资源，如：图片、音乐、模型等，以及编写脚本，视口所展示的内容，实际上会被存成场景文件，依然属于项目管理的范畴</p><p>这些内容开发者使用项目面板进行分类管理，会在开发时显得条理清晰，也能很好地提高开发效率</p><h3 id="3-5-检查器（其实我觉得详情更合适）"><a class="header-anchor" href="#3-5-检查器（其实我觉得详情更合适）">¶</a>3.5. 检查器（其实我觉得详情更合适）</h3><img src="/Users/shenzhisheng/Library/Application Support/typora-user-images/image-20220417215337955.png" alt="image-20220417215337955" style="zoom: 33%;" /><p>当选中一个游戏对象后，这个面板上会浮现出该游戏对象所有的属性，可以方便地对于属性进行修改</p><h3 id="3-6-控制台"><a class="header-anchor" href="#3-6-控制台">¶</a>3.6. 控制台</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204172157596.png" alt="image-20220417215710559" style="zoom:33%;" /><p>这个面板可能通常状态下处于隐藏状态，但是可以通过<code>Window</code>找到它，或者使用<code>shift + command + C</code>将其呼出</p><p>它显示的主要是一些日志信息，在游戏画面中，有些问题可能看不出来，因此在调试过程中添加日志，能够对于游戏各个功能的执行有更加细致的把握，也可以在追踪问题时，发挥很大的作用</p><h2 id="4-游戏物体的创建及操作"><a class="header-anchor" href="#4-游戏物体的创建及操作">¶</a>4. 游戏物体的创建及操作</h2><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204172207047.png" alt="image-20220417220744013" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204172212813.png" alt="image-20220417221203769" style="zoom:50%;" /></p><p>创建游戏物体既可以在编辑器中选中顶部的<code>Game Object</code>，也可以直接在层级面板中右击进行创建，或者使用层级面板顶部的”+“</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204172215037.png" alt="image-20220417221536003" style="zoom:50%;" /><p>当然，也可以快捷地借助已有的游戏对象进行创建，选定游戏对象<code>command + C</code>、<code>command + V</code>复制粘贴，或者直接使用<code>command + D</code>，直接复制粘贴一起</p><h3 id="4-1-常用的基础模型对象"><a class="header-anchor" href="#4-1-常用的基础模型对象">¶</a>4.1. 常用的基础模型对象</h3><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204172240947.png" alt="image-20220417224057899" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204172242365.png" alt="image-20220417224237327" style="zoom:33%;" /></p><p>正好从左到右对应是这些对象</p><blockquote><p>注意：平面和四边形都是单面的，仅有一面可见，并且在性能消耗上，四边形更少</p><p>模型由网格构成，这些网格其实就是图元（三角形），这涉及着色器的知识，使用图元少，用到的三角形顶点就少，计算的内容就会少，那么同等情况下，性能消耗就会少一些</p></blockquote><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204172246931.png" alt="image-20220417224606890" style="zoom:33%;" /><h3 id="4-2-视角调整"><a class="header-anchor" href="#4-2-视角调整">¶</a>4.2. 视角调整</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204172257155.png" alt="image-20220417225725117" style="zoom: 50%;" /><p>在视口中移动鼠标，并且按住右键时，会发现鼠标变成”眼睛“图标，此时工具栏如上图所示，继续按住右键可以以当前位置为轴心，在场景中浏览</p><p>前后滚动鼠标，可以将场景拉近拉远</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204172303817.png" alt="image-20220417230339775" style="zoom:33%;" /><p>双指按住，激活抓手工具，进行场景拖拽，如果使用过ps一类的工具，应该会很熟悉</p><p>以上几种操作进行配合，可以很方便的在场景中进行浏览</p><h3 id="4-3-坐标系"><a class="header-anchor" href="#4-3-坐标系">¶</a>4.3. 坐标系</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204180734034.png" alt="image-20220418073404001" style="zoom: 33%;" /><p>Unity内部采用的是左手坐标系</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204180736904.png" alt="image-20220418073637865" style="zoom:50%;" /><p>如同视口右上角的<code>Gizmo</code>显示的一样</p><h4 id="4-3-1-世界坐标系"><a class="header-anchor" href="#4-3-1-世界坐标系">¶</a>4.3.1. 世界坐标系</h4><p>所有在场景中创建的游戏对象的位置都是相对于世界坐标的</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204180741925.png" alt="image-20220418074120877" style="zoom:50%;" /><p>在<code>Inspector</code>面板中可以查看游戏对象的该属性</p><p><strong>世界坐标系本身是固定不变的</strong></p><h4 id="4-3-2-本地坐标系"><a class="header-anchor" href="#4-3-2-本地坐标系">¶</a>4.3.2. 本地坐标系</h4><p>除了世界坐标系，每个创建的物体还有一个自身的本地坐标系</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204180806042.png" alt="image-20220418080636995" style="zoom:50%;" /><p>首先，建立一个关系，让球体成为立方体的子物体，直接在层级面板上将球体拖动到立方体上</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204180808036.png" alt="image-20220418080840993" style="zoom:50%;" /><p>此时，选中立方体会同时选中球体，反之不可以</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204180809069.png" alt="image-20220418080958020" style="zoom:50%;" /><p>直接移动立方体，立方体的坐标会变，而球体的目标始终不变，因为球体目前的参考对象是立方体，处于立方体的本地坐标系中</p><blockquote><p>在物体没有父物体时，才会使用世界坐标系，或者也可以将世界看作是一切物体的父物体</p></blockquote><h4 id="4-3-3-中心和轴心"><a class="header-anchor" href="#4-3-3-中心和轴心">¶</a>4.3.3. 中心和轴心</h4><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182221194.png" alt="image-20220418222153157" style="zoom:50%;" /><p>在启用<strong>中心</strong>的情况下，选中有父子级关系的两个物体中的父物体，其中心是经过<strong>重新计算</strong>的，因为系统会将两个物体当做整体，这时候坐标轴出现在二者之间</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182226704.png" alt="image-20220418222617675" style="zoom: 50%;" /><p>再切换到<strong>轴心</strong>，此时坐标轴中心移到了父物体的中心</p><p>选中子物体的坐标轴中心并不会改变</p><h4 id="4-3-4-世界坐标与本地坐标切换"><a class="header-anchor" href="#4-3-4-世界坐标与本地坐标切换">¶</a>4.3.4. 世界坐标与本地坐标切换</h4><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182237504.png" alt="image-20220418223736467" style="zoom:50%;" /><p>在切换到世界坐标系时，坐标轴的方向与右上角的<code>Gizmo</code>一致，作为整个场景的坐标轴，所有物体都遵循这个规则，选中后会显示对应方向的坐标轴</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182241256.png" style="zoom: 50%;" /><p>即使进行旋转等操作，依然保持原来的指向</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182249461.png" alt="image-20220418224922417" style="zoom:50%;" /><p>切换到本地坐标系，现在的坐标系是游戏物体自己的，不必遵循原来的规则，跟随着物体的变化而变化</p><h2 id="5-物体的基本操作"><a class="header-anchor" href="#5-物体的基本操作">¶</a>5. 物体的基本操作</h2><h3 id="5-1-移动工具"><a class="header-anchor" href="#5-1-移动工具">¶</a>5.1. 移动工具</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182255497.png" alt="image-20220418225511463" style="zoom:50%;" /><p>快捷键<code>W</code>，显示坐标轴，可以选中坐标轴仅在对应的方向上进行移动</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182257257.png" alt="image-20220418225703213" style="zoom:50%;" /><p>或者选中两个轴之间的方形，仅在选定的平面上进行移动</p><h3 id="5-2-旋转工具"><a class="header-anchor" href="#5-2-旋转工具">¶</a>5.2. 旋转工具</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182302021.png" alt="image-20220418230220951" style="zoom:50%;" /><p>快捷键<code>E</code>，可以选定方向进行旋转</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182306592.png" alt="image-20220418230642555" style="zoom:50%;" /><p>也可以利用查看器进行输入，更加容易获得精准的角度</p><h3 id="5-3-缩放工具"><a class="header-anchor" href="#5-3-缩放工具">¶</a>5.3. 缩放工具</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182310642.png" alt="image-20220418231039594" style="zoom:50%;" /><p>快捷键<code>R</code>，可以选定轴进行缩放，默认为倍数为1，也可以选中中间整体进行缩放</p><h3 id="5-4-矩形工具"><a class="header-anchor" href="#5-4-矩形工具">¶</a>5.4. 矩形工具</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182323620.png" alt="image-20220418232358554" style="zoom:50%;" /><p>快捷键<code>T</code>，主要应用于2D场景和游戏UI绘制上，因为这个工具的作用对象是一个平面，因此将场景切换为2D模式，可以使用该工具进行调整</p><h3 id="5-5-三位一体"><a class="header-anchor" href="#5-5-三位一体">¶</a>5.5. 三位一体</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182334884.png" alt="image-20220418232809276" style="zoom:50%;" /><p>快捷键<code>Y</code>，其实就是将移动、旋转、缩放的功能综合在一起了</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart学习笔记（二）</title>
      <link href="/2022/04/15/Dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/04/15/Dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>Dart学习笔记（二）</h1><h2 id="1-运算符"><a class="header-anchor" href="#1-运算符">¶</a>1. 运算符</h2><p>在<code>Dart</code>中的运算符使用与现代的大多编程语言大都类似</p><h3 id="1-1-关系运算符"><a class="header-anchor" href="#1-1-关系运算符">¶</a>1.1. 关系运算符</h3><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img202204142308448.png" alt="image-20220414230828424"></p><p>关系运算符的用法与其他编程语言中的基本没有多少区别，主要注意一下相等</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较运算符</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (num1 == num2) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="keyword">true</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里相等的当然是内容，如果需要判断两者为同一对象，使用<code>identical()</code></p><h3 id="1-2-算术运算符"><a class="header-anchor" href="#1-2-算术运算符">¶</a>1.2. 算术运算符</h3><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img202204142311103.png" alt="image-20220414231128986"></p><p>以上为一些常用运算符，可能特殊一点是</p><p>~/（取整） %（取余）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num5 = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> num6 = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">print</span>(num5 ~/ num6);</span><br></pre></td></tr></table></figure><p>这样的结果只会取到整数部分的1</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num5 = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> num6 = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">print</span>(num5 % num6);</span><br></pre></td></tr></table></figure><p>换成<code>%</code>取得就是余数1</p><p>并且需要注意，这里的<code>/</code>操作，返回的是<code>double</code>，与传统的c-like语言有点不同</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img202204142322372.png" alt="image-20220414232234291"></p><p><code>++</code>，<code>--</code>前后皆可，没什么特别</p><h3 id="1-3-类型判断"><a class="header-anchor" href="#1-3-类型判断">¶</a>1.3. 类型判断</h3><p>主要用于在代码<strong>运行时</strong>对于字段的类型进行检查</p><p><code>is</code>用于判断变量是否属于某个类型</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> <span class="built_in">int</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>is!</code>这个符号很奇葩，<code>!</code>一定注意是在后面😂</p><p>意思与<code>is</code>相反</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span>! <span class="built_in">int</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>as</code>代表一种强转，他需要<strong>目标类型从属于原类型</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">as</span> <span class="built_in">int</span>);</span><br></pre></td></tr></table></figure><p>一切都是<code>Object</code>，那么自然可以取出<code>int</code>，当然，既然是强转，不匹配是会抛异常的</p><h3 id="1-4-赋值运算符"><a class="header-anchor" href="#1-4-赋值运算符">¶</a>1.4. 赋值运算符</h3><p>其他都很到理解，与其他语言没什么两样，比较特殊的应该就是<strong>为空赋值</strong></p><p><code>??=</code>表示为空赋值</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 可能有其他处理</span></span><br><span class="line">b ??= <span class="string">&#x27;--&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(b);  <span class="comment">// --</span></span><br></pre></td></tr></table></figure><p>这种使用场景可能在接口返回时使用，主要作为缺省值，后端返回为null，显示缺省，否则就显示对应字段</p><h3 id="1-5-条件表达式"><a class="header-anchor" href="#1-5-条件表达式">¶</a>1.5. 条件表达式</h3><p>三元运算符和其他语言的差不多，但是需要注意<code>??</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">var</span> b = a ?? <span class="number">5</span>;</span><br><span class="line"><span class="built_in">print</span>(b);  </span><br></pre></td></tr></table></figure><p>与<code>??=</code>相似，那个是处理左值可能为空的情况，这个是右值，主要还是用于保证非空类型不会为空</p><h3 id="1-6-基础的类型转换"><a class="header-anchor" href="#1-6-基础的类型转换">¶</a>1.6. 基础的类型转换</h3><p>经常会用到的可能就是<code>String</code>和<code>Number</code>之间的转化了</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// toString()</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="number">23.36</span>;</span><br><span class="line"><span class="keyword">var</span> str = d.toString();</span><br></pre></td></tr></table></figure><p>数值类型转化为<code>String</code>直接可以调用<code>toString</code>方法，相当于给原来的数值外面加上括号</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parse()</span></span><br><span class="line"><span class="built_in">String</span> s = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="comment">// 异常添加try...catch</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">int</span>.parse(s);</span><br><span class="line"><span class="keyword">if</span> (num3 <span class="keyword">is</span> <span class="built_in">int</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(num3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>String</code>转为数值类型，可以通过对应数值类型的<code>parse()</code>方法，但是，由于不是所有<code>String</code>都能是<code>Number</code>，所以可能会发生异常，实际应用中需要加上<code>try...catch</code>，防止程序崩溃</p><blockquote><p>其他语句表达式与其他语言相似，想深入了解，文档依然是最好的选择</p><p><a href="https://www.dartcn.com/guides/language/language-tour#%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F">Dart文档（https://www.dartcn.com/guides/language/language-tour）</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart学习笔记（一）</title>
      <link href="/2022/04/12/Dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/04/12/Dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>Dart学习笔记（一）</h1><p>作为编写<code>Flutter</code>应用的工具语言，当然还是还是跑不掉的</p><blockquote><p>Dart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和sound type system 。                                                                                 ——百度百科</p></blockquote><p>由Google开发，<code>Flutter</code>基于<code>Dart</code>开发，并且在2018年，<code>Dart2</code>成为强类型语言，总的来说，它还比较新，目前对于它的了解仍停留在其是<code>Flutter</code>的**“工具语言”**</p><h2 id="1-程序的入口"><a class="header-anchor" href="#1-程序的入口">¶</a>1. 程序的入口</h2><p>至关重要的一点，程序的入口，与其他编程语言一样，<code>Dart</code>老实本分地遵循着传统，以<code>main()</code>作为起点</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="comment">// 或者void main表示没有返回值</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Hello Dart&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以直接写成<code>main()</code>或者前面加上<code>void</code>表明其没有返回值</p><h2 id="2-注释"><a class="header-anchor" href="#2-注释">¶</a>2. 注释</h2><p>良好的注释对于所有程序员都很重要，包括自己</p><p><code>Dart</code>中支持单行注释、多行注释以及文档注释</p><h3 id="2-1-单行注释"><a class="header-anchor" href="#2-1-单行注释">¶</a>2.1. 单行注释</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释</span></span><br></pre></td></tr></table></figure><p>这个用的最为频繁，对于各种方法、变量、语句都很适用，就像读书时加批注一样</p><h3 id="2-2-多行注释"><a class="header-anchor" href="#2-2-多行注释">¶</a>2.2. 多行注释</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个无非是多注释几行，如果需要描述的内容多一些可以用这个</p><h3 id="2-3-文档注释"><a class="header-anchor" href="#2-3-文档注释">¶</a>2.3. 文档注释</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file</span></span><br><span class="line"><span class="comment">// for details. All rights reserved. Use of this source code is governed by a</span></span><br><span class="line"><span class="comment">// BSD-style license that can be found in the LICENSE file.</span></span><br></pre></td></tr></table></figure><p>像这个注释就比较规范了，通常用在声明类和文件时，总体描述作用时使用，最常见的就是在源码里面</p><p>总之，如果不确定在哪里用什么样的注释，源码总是最好的参考</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img202204102325039.png" alt="image-20220410232524898" style="zoom:67%;" /><h2 id="3-变量"><a class="header-anchor" href="#3-变量">¶</a>3. 变量</h2><p>变量可以使用<code>var</code>进行定义</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 类型推断</span></span><br></pre></td></tr></table></figure><p>编译器会根据初始化的值进行<code>类型推断</code>，这里会被推断为<code>String</code></p><p>除此以外，也可以<strong>使用指定的类型进行声明</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> s = <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>直接使用指定的类型声明为该类型的变量</p><h2 id="4-常量"><a class="header-anchor" href="#4-常量">¶</a>4. 常量</h2><p>在<code>Dart</code>中，常量通常使用<code>const</code>和<code>final</code>声明</p><p>使用<code>const</code>表示，可以直接替代<code>var</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>; <span class="comment">// 类型推导</span></span><br></pre></td></tr></table></figure><p>直接使用<code>const</code>，编译器可以根据赋值进行类型推导</p><p>也可以直接加上具体类型</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">String</span> DATE_FORMAT = <span class="string">&#x27;yyyy-MM-dd&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>const</code>声明的是<strong>编译期</strong>常量，即在程序开始运行之前，就进行赋值</p><p><code>final</code>的使用方面同样也有两种</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> now = <span class="keyword">new</span> <span class="built_in">DateTime</span>.now();  <span class="comment">// 惰性初始化</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">int</span> length = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>但是尤其需要主要的是，<code>final</code>声明的常量可以接受函数调用，只有它可以获取运行时的量进行赋值，这也是其与<code>const</code>最大的不同</p><h2 id="5-数据类型"><a class="header-anchor" href="#5-数据类型">¶</a>5. 数据类型</h2><p>与其他各类编程语言如出一辙，<code>Dart</code>也需要丰富的数据类型给处理的数据分分类</p><h3 id="5-1-字符串"><a class="header-anchor" href="#5-1-字符串">¶</a>5.1. 字符串</h3><p>这绝对是最最最常用到的类型了</p><p><code>String</code>用来表示字符串，直接可以使用<code>String</code>声明该类型的变量</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> s2 = <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><p>单引号、双引号都可以，保持一种习惯较好</p><p>不过声明更加推荐的方式还是直接进行<strong>类型推导</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>除此以外，<code>Dart</code>还提供了使用<code>'''</code>或<code>&quot;&quot;&quot;</code>括起来的写法，用来输出带有格式的字符串</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">String</span> s3 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  Hello, </span></span><br><span class="line"><span class="string">    World!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(s3);</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img202204112310753.png" alt="image-20220411231011454" style="zoom:100%;" /><p>和预览的效果完全一致</p><p>字符串的拼接有两种，一种使用<code>+</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s4 = <span class="string">&#x27;Happy&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s5 = <span class="string">&#x27; Birthday!&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(s4 + s5);</span><br></pre></td></tr></table></figure><p>而另一种使用的是<strong>模板占位</strong>，运用<code>$</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$s4</span><span class="subst">$s5</span>&#x27;</span>);</span><br></pre></td></tr></table></figure><p>使用这种方式先占位，程序会替换，与<code>Kotlin</code>的模板字符串完全一致，非常舒适</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img202204112317308.png" alt="image-20220411231715184"></p><h3 id="5-2-数值类型"><a class="header-anchor" href="#5-2-数值类型">¶</a>5.2. 数值类型</h3><p>主要分为整数与浮点</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值类型</span></span><br><span class="line"><span class="built_in">int</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">double</span> b = <span class="number">12.56</span>;</span><br></pre></td></tr></table></figure><p>整数使用<code>int</code>，小数使用<code>double</code>，简单粗暴，当然，同样推荐使用类型推导</p><p>另外，<code>int</code>可以直接赋值给<code>double</code>，反之不可</p><h3 id="5-3-布尔类型"><a class="header-anchor" href="#5-3-布尔类型">¶</a>5.3. 布尔类型</h3><p>没有太多可说的，<code>bool</code>定义，总共两个值：true和false</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">var</span> mFlag = <span class="keyword">false</span>;  <span class="comment">// 推导</span></span><br></pre></td></tr></table></figure><h3 id="5-4-List（数组-集合）"><a class="header-anchor" href="#5-4-List（数组-集合）">¶</a>5.4. List（数组/集合）</h3><p><code>[]</code>可以声明一个<code>List</code>，没有指定类型的情况下什么都可以往里放</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list1 = [<span class="string">&#x27;呱太&#x27;</span>, <span class="number">666</span>, <span class="keyword">false</span>];</span><br><span class="line"><span class="built_in">print</span>(list1);</span><br></pre></td></tr></table></figure><p>并且<code>List</code>的<code>length</code>属性可以获取长度</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;长度=<span class="subst">$&#123;list1.length&#125;</span>&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如果想要访问<code>List</code>中的元素，可以通过<code>索引</code>进行获取</p><blockquote><p>和其他语言一样，索引从0开始</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(list1[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>可以使用<code>&lt;T&gt;</code>的方式为<code>List</code>中的元素限定类型</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list2 = &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;阿凡提&#x27;</span>, <span class="string">&#x27;钢铁侠&#x27;</span>, <span class="string">&#x27;皮卡丘&#x27;</span>];</span><br><span class="line"><span class="built_in">print</span>(list2);</span><br></pre></td></tr></table></figure><p>这就不能自由发挥了，必须按照规矩办事</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list3 = []; <span class="comment">// 空List</span></span><br><span class="line">list3.add(<span class="string">&#x27;Van&#x27;</span>); <span class="comment">// 增加数据</span></span><br></pre></td></tr></table></figure><p>也可以先创建空的<code>List</code>，然后调用<code>add()</code>向其中填充元素，构建一个完整的<code>List</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个固定长度的集合</span></span><br><span class="line"><span class="keyword">var</span> list4 = <span class="built_in">List</span>.filled(<span class="number">3</span>, <span class="number">1</span>); <span class="comment">// growable属性为false，不可add，显示标明true可以add</span></span><br><span class="line">  <span class="comment">// list4.add(5);</span></span><br><span class="line"><span class="built_in">print</span>(list4);</span><br></pre></td></tr></table></figure><p>在<code>Java</code>中，集合是可以动态增长的，而数组则是在声明时给定了容量</p><p><code>List</code>的<code>filled(length, element)</code>方法会初始化指定长度<code>length</code>的数组，里面的元素使用给定的<code>element</code></p><blockquote><p>这个方法返回的<code>List</code>是默认growable为false，也就是不可增长的</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">external</span> <span class="keyword">factory</span> <span class="built_in">List</span>.filled(<span class="built_in">int</span> length, E fill, &#123;<span class="built_in">bool</span> growable = <span class="keyword">false</span>&#125;);</span><br></pre></td></tr></table></figure><p>源码里能看到<code>growable</code>，如果显示设置为true，就会转变为先前几个<code>List</code>那样，可以动态增长，当然，不能增长，你猜<code>add（）</code>会不会报错😏</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改非定长的集合的长度</span></span><br><span class="line">list1.length = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>直接修改<code>length</code>默认会<code>set</code>（当然<code>List</code>得是能变的那种）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">注释的解释 如果新的长度更大，新元素会赋值null，注意当前类型是否允许空值</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">The list must be growable.</span></span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img202204112348039.png" alt="image-20220411234824911"></p><h3 id="5-5-Map（字典-映射表）"><a class="header-anchor" href="#5-5-Map（字典-映射表）">¶</a>5.5. Map（字典/映射表）</h3><p><code>Map</code>常用于二级列表</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map 定义，类似于Json数据</span></span><br><span class="line">  <span class="keyword">var</span> map1 = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;minos&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&#x27;hobbies&#x27;</span>: [<span class="string">&#x27;唱&#x27;</span>, <span class="string">&#x27;跳&#x27;</span>, <span class="string">&#x27;rap&#x27;</span>, <span class="string">&#x27;魁地奇&#x27;</span>]</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>定义似乎和JS中的对象差不多，<code>key</code>和<code>value</code>可以指定任意类型，但<code>key</code>通常使用<code>String</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据访问</span></span><br><span class="line"><span class="built_in">print</span>(map1[<span class="string">&#x27;name&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>通过<code>key</code>来获取<code>Map</code>对象中与之对应的<code>value</code></p><p>当一个<code>key</code>对应多个<code>value</code>就会产生分组的形式，也就二级列表</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建空的map并向其中添加元素</span></span><br><span class="line"><span class="keyword">var</span> map2 = <span class="built_in">Map</span>();</span><br><span class="line">map2[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;伏地魔&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(map2);</span><br></pre></td></tr></table></figure><p>另外，调用<code>Map()</code>会创建一个空的<code>Map</code>实例，<code>Dart2</code>中省去了<code>new</code>关键字</p><p>直接通过给<code>key</code>赋值，就能添加对应数据，对应到<code>key</code>和<code>value</code>的关联关系</p><h2 id="6-类型判断"><a class="header-anchor" href="#6-类型判断">¶</a>6. 类型判断</h2><p>在编写代码时，有的时候只需要<strong>对关注的特定类型</strong>进行处理</p><p>这个时候就需要<code>is</code>来帮忙筛选一下</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用is关键字判断类型</span></span><br><span class="line"> <span class="comment">// 尤其是服务器返回</span></span><br><span class="line"> <span class="keyword">var</span> params = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"> <span class="keyword">if</span> (params <span class="keyword">is</span> <span class="built_in">String</span>) &#123;  <span class="comment">// 所期望的</span></span><br><span class="line">   <span class="built_in">print</span>(params.length);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params <span class="keyword">is</span> <span class="built_in">int</span>) &#123;</span><br><span class="line">   <span class="comment">// int处理</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们没有把握，或者担心出错，可以保险一点，取数据时添加上类型判断，仅处理需要的，防止返回了意料之外的内容</p><p><strong>只拿需要的，和考虑各种以外情况相比，自然是前者更简单</strong></p>]]></content>
      
      
      <categories>
          
          <category> Dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter学习笔记（四）</title>
      <link href="/2022/04/09/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2022/04/09/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>Flutter学习笔记（四）</h1><h2 id="1-列表组件"><a class="header-anchor" href="#1-列表组件">¶</a>1. 列表组件</h2><p>在实际的应用中，经常会有需要向用户提供大量数据进行阅读的场景，这就需要使用到列表组件展示数据</p><h3 id="1-1-ListView"><a class="header-anchor" href="#1-1-ListView">¶</a>1.1. ListView</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListView(</span><br><span class="line">          children: [</span><br><span class="line">            Text(<span class="string">&#x27;内容&#x27;</span>),</span><br><span class="line">            ElevatedButton(</span><br><span class="line">                onPressed: () =&gt; &#123;&#125;,</span><br><span class="line">                child: Text(<span class="string">&#x27;按钮&#x27;</span>)</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>对于<code>ListView</code>组件而言最重要的是内容，也就是<code>children</code>属性，它所接收的是<code>Widget</code>列表，理论上只要是<code>Widget</code>就可以放</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204082343867.png" alt="image-20220408234337755" style="zoom: 50%;" /><p>通常是使用<code>ListTile</code>组件进行搭配使用</p><p><code>ListTile</code>代表的就是列表中的一项，利用其属性可以方便组合列表项的样式</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ListTile(</span><br><span class="line">              leading: Image.network(<span class="string">&#x27;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffile01.dysucai.com%2Fd%2Ffile%2Flan2018061913%2Fk0ajx12543d.jpg&amp;refer=http%3A%2F%2Ffile01.dysucai.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1651720679&amp;t=7c87729681050f86d1340f1412b7eb52&#x27;</span>),   <span class="comment">// 开头的图片</span></span><br><span class="line">              title: Text(<span class="string">&#x27;标题&#x27;</span>),  <span class="comment">// 标题</span></span><br><span class="line">              subtitle: Text(<span class="string">&#x27;二级标题&#x27;</span>),    <span class="comment">// 子标题</span></span><br><span class="line">              trailing: Icon(Icons.keyboard_arrow_right),   <span class="comment">// 结尾的图片</span></span><br><span class="line">            ),</span><br></pre></td></tr></table></figure><p>以上就是<code>ListTile</code>常用的一些属性，然后多复制几个</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204091341330.png" style="zoom: 50%;" /><p><code>ListView</code>默认是沿垂直方向滚动，可以通过<code>scrollDirection</code>属性进行修改</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListView(</span><br><span class="line">          scrollDirection: Axis.horizontal,</span><br><span class="line">          children: [</span><br><span class="line">           Container(</span><br><span class="line">             width: <span class="number">150</span>,</span><br><span class="line">             color: Colors.blueAccent,</span><br><span class="line">           ),</span><br><span class="line">            Container(</span><br><span class="line">              width: <span class="number">150</span>,</span><br><span class="line">              color: Colors.yellowAccent,</span><br><span class="line">            ),</span><br><span class="line">            Container(</span><br><span class="line">              width: <span class="number">150</span>,</span><br><span class="line">              color: Colors.orangeAccent,</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204091458840.png" alt="image-20220409145802224" style="zoom:50%;" /><blockquote><p>注意：</p><p>设置沿水平方向滚动，高度会自适应父容器；设置垂直方向滚动，宽度会自适应父容器</p></blockquote><p>也可以为列表项设置子组件为<code>ListView</code>，实现嵌套</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ListView(</span><br><span class="line">          scrollDirection: Axis.horizontal,</span><br><span class="line">          children: [</span><br><span class="line">           Container(</span><br><span class="line">             width: <span class="number">150</span>,</span><br><span class="line">             color: Colors.blueAccent,</span><br><span class="line">           ),</span><br><span class="line">            Container(</span><br><span class="line">              width: <span class="number">150</span>,</span><br><span class="line">              color: Colors.yellowAccent,</span><br><span class="line">              child: ListView(   <span class="comment">// 子组件依然是列表</span></span><br><span class="line">                children: [</span><br><span class="line">                  Container(</span><br><span class="line">                    height: <span class="number">250</span>,</span><br><span class="line">                    color: Colors.black,</span><br><span class="line">                  ),</span><br><span class="line">                  Container(</span><br><span class="line">                    height: <span class="number">250</span>,</span><br><span class="line">                    color: Colors.white,</span><br><span class="line">                  ),</span><br><span class="line">                  Container(</span><br><span class="line">                    height: <span class="number">250</span>,</span><br><span class="line">                    color: Colors.red,</span><br><span class="line">                  )</span><br><span class="line">                ],</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            Container(</span><br><span class="line">              width: <span class="number">150</span>,</span><br><span class="line">              color: Colors.orangeAccent,</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204091503414.png" alt="image-20220409150334357" style="zoom:50%;" /><h3 id="1-2-GridView"><a class="header-anchor" href="#1-2-GridView">¶</a>1.2. GridView</h3><p>用于以网格的形式呈现数据的组件，因为默认是沿垂直方向滚动的，因此垂直方向为<code>主轴</code>，水平方向便是<code>副轴</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GridView.count(</span><br><span class="line">            crossAxisCount: <span class="number">2</span>,  <span class="comment">// 列数，副轴</span></span><br><span class="line">            children: [</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.deepOrange,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.lightBlue,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.blueGrey,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.amber,</span><br><span class="line">              )</span><br><span class="line">        ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204091621467.png" alt="image-20220409162101304" style="zoom:50%;" /><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GridView.count(</span><br><span class="line">            crossAxisCount: <span class="number">2</span>,  <span class="comment">// 列数，副轴</span></span><br><span class="line">            mainAxisSpacing: <span class="number">10</span>,   <span class="comment">// 沿主轴的间隙</span></span><br><span class="line">            crossAxisSpacing: <span class="number">20</span>,   <span class="comment">// 沿副轴的间隙</span></span><br><span class="line">            children: [</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.deepOrange,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.lightBlue,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.blueGrey,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.amber,</span><br><span class="line">              )</span><br><span class="line">        ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204091623947.png" alt="image-20220409162313898" style="zoom:50%;" /><p><code>GridView</code>中的每一项都是进行自适应的，需要修改item的比例需要通过<code>childAspectRatio</code>设置</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GridView.count(</span><br><span class="line">            crossAxisCount: <span class="number">2</span>,  <span class="comment">// 列数，副轴</span></span><br><span class="line">            mainAxisSpacing: <span class="number">10</span>,   <span class="comment">// 沿主轴的间隙</span></span><br><span class="line">            crossAxisSpacing: <span class="number">20</span>,   <span class="comment">// 沿副轴的间隙</span></span><br><span class="line">            childAspectRatio: <span class="number">0.8</span>,  <span class="comment">// 子项宽高比</span></span><br><span class="line">            children: [</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.deepOrange,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.lightBlue,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.blueGrey,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.amber,</span><br><span class="line">              )</span><br><span class="line">        ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204091628375.png" alt="image-20220409162840338" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Widget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter学习笔记（三）</title>
      <link href="/2022/04/07/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2022/04/07/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>Flutter学习笔记（三）</h1><h2 id="1-内置基础组件（图文）"><a class="header-anchor" href="#1-内置基础组件（图文）">¶</a>1. 内置基础组件（图文）</h2><h3 id="1-1-Text"><a class="header-anchor" href="#1-1-Text">¶</a>1.1. Text</h3><p><code>Text</code>组件就可以当成是Android里面的<code>TextView</code>，用来显示一段文本</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(</span><br><span class="line">            <span class="string">&#x27;虚荣，是我最喜欢的原罪！&#x27;</span>,</span><br><span class="line">            textAlign: TextAlign.center,</span><br><span class="line">            overflow: TextOverflow.ellipsis,</span><br><span class="line">            style: <span class="keyword">const</span> TextStyle(fontWeight: FontWeight.bold),</span><br><span class="line">          ),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491574275681649157427277.png" alt=""></p><p>这里外面加了<code>Container</code>作为<code>Text</code>组件的父容器</p><p><code>textAlign</code>属性用于居中文本，那应当是相当于<code>Text</code>自身，那需要关注一下<code>Text</code>组件自身有没有变化，之前的<code>Align</code>组件和<code>Container</code>的<code>alignment</code>属性都是会使容器变化的</p><p>因此加上一个样式属性，查看一下组件的有效区域</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(</span><br><span class="line">            <span class="string">&#x27;虚荣，是我最喜欢的原罪！&#x27;</span>,</span><br><span class="line">            textAlign: TextAlign.center,</span><br><span class="line">            overflow: TextOverflow.ellipsis,</span><br><span class="line">            style: <span class="keyword">const</span> TextStyle(</span><br><span class="line">                fontWeight: FontWeight.bold,</span><br><span class="line">                backgroundColor: Colors.lightGreenAccent    <span class="comment">// 加上一个背景色</span></span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491580745661649158073901.png" alt=""></p><p>并没有变化，依然是&quot;<code>wrap_content</code>&quot;</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          color: Colors.lightBlue,</span><br><span class="line">          width: <span class="number">300</span>,</span><br><span class="line">          height: <span class="number">300</span>,</span><br><span class="line">          child: Text(</span><br><span class="line">            <span class="string">&#x27;虚荣，是我最喜欢的原罪！&#x27;</span>,</span><br><span class="line">            textAlign: TextAlign.center,</span><br><span class="line">            overflow: TextOverflow.ellipsis,</span><br><span class="line">            style: <span class="keyword">const</span> TextStyle(</span><br><span class="line">                fontWeight: FontWeight.bold,</span><br><span class="line">                backgroundColor: Colors.lightGreenAccent</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>这里的<code>textAlign</code>可以理解为就是文本组件对于它的容器的一种位置</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491707415731649170741232.png" alt=""></p><p>文本组件恰好包裹文字内容，但是对齐是相对于父级组件也就是<code>Container</code>的</p><p>在<code>TextAlign</code>中有一段注释</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Whether and how to align text horizontally.</span></span></span><br></pre></td></tr></table></figure><p>这里表述的是该对齐只是水平方向上的，因此上文是水平居中</p><br/><p><code>overflow</code>属性虽然设置，但此刻并未生效，需要改动一下父容器，使文字溢出</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491719935641649171993079.png" alt=""></p><p>由于父容器宽度变小了，空间显得局促，因而在显示不下时，会采用实现设置的方式对文本进行省略</p><br/><p><code>style</code>属性主要借助于<code>TextStyle</code>来实现样式的修改</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          color: Colors.lightBlue,</span><br><span class="line">          width: <span class="number">100</span>,</span><br><span class="line">          height: <span class="number">300</span>,</span><br><span class="line">          child: Text(</span><br><span class="line">            <span class="string">&#x27;虚荣，是我最喜欢的原罪！&#x27;</span>,</span><br><span class="line">            textAlign: TextAlign.center,</span><br><span class="line">            overflow: TextOverflow.ellipsis,</span><br><span class="line">            style: <span class="keyword">const</span> TextStyle(</span><br><span class="line">              color: Colors.deepOrange,  <span class="comment">// 字体颜色</span></span><br><span class="line">                fontWeight: FontWeight.bold,  <span class="comment">// 加粗</span></span><br><span class="line">                backgroundColor: Colors.lightGreenAccent,  <span class="comment">// 背景</span></span><br><span class="line">              letterSpacing: <span class="number">10</span>  <span class="comment">// 字间距</span></span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491725205651649172519942.png" alt=""></p><h3 id="1-2-Image"><a class="header-anchor" href="#1-2-Image">¶</a>1.2. Image</h3><p><code>Image</code>组件主要用来展示图片，既可以是网络图片，也可以是本地资源</p><h4 id="1-2-1-本地图片"><a class="header-anchor" href="#1-2-1-本地图片">¶</a>1.2.1. 本地图片</h4><p>使用本地图片资源首先需要进行一些配置</p><p>项目的<strong>根目录</strong>下新建文件夹<code>images</code>，以及子级目录<code>3.0x</code>、<code>2.0x</code>，系统会根据设备不同的像素密度自动加载</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16492581935801649258193278.png" alt=""></p><p>这里就随便一点了</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16492587575791649258756960.png" alt=""></p><p>然后修改配置文件<code>pubspec.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># To add assets to your application, add an assets section, like this:</span></span><br><span class="line">  <span class="attr">assets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">images/bg.jpg</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">images/2.0x/bg.jpg</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">images/3.0x/bg.jpg</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p><code>YAML</code>格式要对齐</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          color: Colors.lightBlue,</span><br><span class="line">          child: Image.asset(<span class="string">&#x27;images/bg.jpg&#x27;</span>),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>使用<code>assets</code>构造器加载</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16493438680106e05e5b6d944ca20128dcec4ab4d6774.png" alt="" style="zoom:80%;" /><h4 id="1-2-2-网络图片"><a class="header-anchor" href="#1-2-2-网络图片">¶</a>1.2.2. 网络图片</h4><p>使用<code>network</code>构造器实现网络图片加载</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          color: Colors.lightBlue,</span><br><span class="line">          width: <span class="number">300</span>,</span><br><span class="line">          height: <span class="number">300</span>,</span><br><span class="line">          child: Image.network(</span><br><span class="line">            <span class="string">&#x27;https://i0.hdslb.com/bfs/archive/ca375eb31fa90b8e23b88ed3433c2f60de1c2e6e.png&#x27;</span>,</span><br><span class="line">          ),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16492574445821649257443735.png" alt="" style="zoom:80%;" /><blockquote><p>组件还是要在具体场景使用中积累，**“每周组件”**的视频和组件API文档才是最有用的</p></blockquote><br/><p><a href="https://api.flutter.dev/flutter/widgets/widgets-library.html">Flutter组件库文档（https://api.flutter.dev/flutter/widgets/widgets-library.html）</a></p><p><a href="https://youtu.be/c1xLMaTUWCY">每日一组件（https://youtu.be/c1xLMaTUWCY）https://youtu.be/c1xLMaTUWCY）</a></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Widget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter学习笔记（二）</title>
      <link href="/2022/04/05/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/04/05/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>Flutter学习笔记（二）</h1><h2 id="1-概述"><a class="header-anchor" href="#1-概述">¶</a>1. 概述</h2><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490749945651649074994467.png" alt="" style="zoom:50%;" /><p>Flutter中其实提供很多种类的内置组件，既涉及有状态的，也涉及无状态的，使用这些组件进行组合，很快能够完成界面布局的搭建工作</p><br/><h2 id="2-容器类"><a class="header-anchor" href="#2-容器类">¶</a>2. 容器类</h2><p>容器自然是要可以将其他组件放在自己的内部的，有点像Android里面的<code>ViewGroup</code>或者HTML里面的<code>&lt;div&gt;</code></p><h3 id="2-1-Container"><a class="header-anchor" href="#2-1-Container">¶</a>2.1. Container</h3><p><code>Container</code>组件的主要作用是将其他组件<strong>打包</strong>，以便于整体进行修饰或定位</p><p>可以将这里的<code>Container</code>看做是Android里的某一种布局</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          color: Colors.greenAccent,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490838940271649083893967.png" alt=""></p><p>这里只包含一个<code>Text</code>组件，并且设置了容器的背景色，在默认情况下，<code>Container</code>的大小会根据内容的大小自适应，可以看做是Android中的<code>wrap_content</code></p><br/><p>当然，内边距的<code>padding</code>的效果也别无二致</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          color: Colors.greenAccent,</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">20.0</span>),   <span class="comment">// 添加内边距</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490841665651649084166405.png" alt=""></p><p><code>EdgeInsets.all()</code>从外表大致能猜出来是四周都设置为相同的指定边距</p><br/><p>使用<code>margin</code>属性无疑是添加组件四周的外边距的设置</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          color: Colors.greenAccent,</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">          margin: EdgeInsets.all(<span class="number">10.0</span>),    <span class="comment">// 添加外边距，当然，这里也是四周一起加了</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490843445651649084343570.png" alt=""></p><br/><p><strong>装饰器</strong>可以用来在容器内部添加一个图形</p><blockquote><p>注意：</p><p>装饰器不可与color属性共存</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">          margin: EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">          decoration: BoxDecoration(      <span class="comment">// 添加装饰器，同时去掉color属性，否则会报错</span></span><br><span class="line">            shape: BoxShape.circle,</span><br><span class="line">            color: Colors.lightBlueAccent</span><br><span class="line">          ),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490848415681649084840871.png" alt=""></p><p>这样看起来显然不好看，<strong>装饰器的大小默认受制于整个容器的大小</strong>，而容器的大小又是被内部的子组件撑起来的，那么在有限的空间里只能允许这么大的圆</p><p>因为装饰器在<code>Container</code>内部，因此只要增加一些<code>padding</code>，这样就有更多空间“发育”</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490855485651649085547838.png" alt=""></p><br/><p><strong>对齐属性</strong>，作用于<code>Container</code>的子级组件</p><blockquote><p>注意：</p><p>该属性直接设置后当前容器会直接铺满父容器，感觉这一点很奇怪，可能是因为本身默认情况下自适应，没有办法体现该属性的效果吧，但这就改变自己用于体现这种效果吗，这个组件的表现欲也太强了😂</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          color: Colors.amber,</span><br><span class="line">          alignment: Alignment.topLeft,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490867335671649086732861.png" alt=""></p><p>当然，也可以通过指定宽高或者进行布局约束覆盖该效果</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          color: Colors.amber,</span><br><span class="line">          alignment: Alignment.topLeft,</span><br><span class="line">          width: <span class="number">200</span>,</span><br><span class="line">          height: <span class="number">100</span>,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490869365741649086936336.png" alt=""></p><h3 id="2-2-Padding"><a class="header-anchor" href="#2-2-Padding">¶</a>2.2. Padding</h3><p>注意，这里的<code>Padding</code>不是一个属性，而是一个组件</p><br/><p>简单了解一下之前提到的<code>EdgeInsets</code></p><p>它是抽象类<code>EdgeInsetsGeometry</code>的子类，可以用来描述组件各个方向上的距离</p><br/><p><code>Padding</code>组件实际上与<code>Container</code>的<code>padding</code>属性差不多，但是更加<strong>专一和轻量</strong></p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491234345651649123433576.png" alt="" style="zoom:70%;" /><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Padding(</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">          child: Container(</span><br><span class="line">            color: Colors.deepPurple,</span><br><span class="line">            child: Text(<span class="string">&#x27;一切皆为组件&#x27;</span>),</span><br><span class="line">          )</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491233175681649123317120.png" alt=""></p><h3 id="2-3-Align"><a class="header-anchor" href="#2-3-Align">¶</a>2.3. Align</h3><p><code>Align</code>组件重点描述的是父子组件之间的关系，<strong>子组件相对于父组件的位置</strong></p><blockquote><p>注意：</p><p>这里在使用<code>Align</code>组件时和之前<code>Container</code>的<code>alignment</code>属性有相似之处，父级都会自己扩展范围</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">         color: Colors.lightBlue,</span><br><span class="line">         child: Align(</span><br><span class="line">           alignment: Alignment.topLeft,</span><br><span class="line">           child: Text(<span class="string">&#x27;一切皆组件&#x27;</span>),</span><br><span class="line">         ),</span><br><span class="line">       )</span><br></pre></td></tr></table></figure><p>这里设置文本组件位于父级组件的左上角，可以想象父级组件会默认为父级的大小，然后将子级组件放到左上角（因为没有指定大小）</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491240515661649124051139.png" alt=""></p><p>除了代码枚举的几个预设的位置，还可以通过<strong>校准值</strong>进行指定</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491242135651649124213167.png" alt="" style="zoom:50%;" /><p><code>Align</code>组件在定义中将一个组件在水平方向和垂直方向，水平方向上组件从左至划分为为-1 ~ 1，垂直方向上组件从上到下划分为-1 ~ 1</p><p>当然，范围可以超出，只是不在组件范围内了</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          color: Colors.lightBlue,</span><br><span class="line">          child: Align(</span><br><span class="line">            alignment: Alignment(<span class="number">0.5</span>, <span class="number">0.5</span>),</span><br><span class="line">            child: Text(<span class="string">&#x27;一切皆组件&#x27;</span>),</span><br><span class="line">          )</span><br></pre></td></tr></table></figure><p>这样可以将对齐控制得更加精确</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491253045671649125303770.png" alt="" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NDK（入门）</title>
      <link href="/2022/04/04/NDK%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/"/>
      <url>/2022/04/04/NDK%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>NDK（入门）</h1><h2 id="1-使用目的"><a class="header-anchor" href="#1-使用目的">¶</a>1. 使用目的</h2><ul><li>进一步提升设备性能，以降低延迟或运行游戏或物理模拟等计算密集型应用</li><li>重复使用您自己或其他开发者的 C 或 C++ 库</li></ul><p>Android Studio原生库编译默认使用<code>CMake</code>，同时也支持<code>ndk-build</code></p><h2 id="2-准备工作"><a class="header-anchor" href="#2-准备工作">¶</a>2. 准备工作</h2><ul><li>NDK：允许在Android中使用C/C++</li><li>CMake：外部构建工具，如果使用<code>ndk-build</code>，可以不需要</li><li>LLDB：原生代码调试工具，默认AS自带</li></ul><p>先进到<code>SDK Manager</code>准备一下对应的工具</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490380341231649038033292.png" alt="" style="zoom:70%;" /><br/><h2 id="3-添加原生代码"><a class="header-anchor" href="#3-添加原生代码">¶</a>3. 添加原生代码</h2><h3 id="3-1-创建原生源代码文件"><a class="header-anchor" href="#3-1-创建原生源代码文件">¶</a>3.1. 创建原生源代码文件</h3><p>首先，创建项目时选择<code>Native C++</code>类型</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490391141311649039113214.png" alt="" style="zoom:70%;" /><p>选择默认的工具链，这样可以使用默认的<code>CMake</code>配置</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490392661221649039265481.png" alt="" style="zoom:70%;" /><p>新的项目创建完成后，使用Android视图查看一下项目文件结构，会发现出现了一个<code>cpp</code>目录，<code>CMakeLists.txt</code>代表<code>CMake</code>的构建脚本，而另一个.cpp文件是示例代码</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490400261281649040025617.png" alt=""></p><blockquote><p><strong>简要分析示例</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_minos_nativedemo_MainActivity_stringFromJNI(</span><br><span class="line">        JNIEnv* env,</span><br><span class="line">        jobject /* this */) &#123;</span><br><span class="line">    std::string hello = &quot;Hello from C++&quot;;</span><br><span class="line">    return env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是示例.cpp的代码，可以看到顶部包含了<code>jni</code>框架的头文件，下面声明的就是<code>stringFromJNI()</code>函数，大致的意思就是将该函数对外暴露，提供给Java调用</p><br/><p>再看下<code>CMakeLists.txt</code>中的内容</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Creates and names a library, sets it as either STATIC</span><br><span class="line"># or SHARED, and provides the relative paths to its source code.</span><br><span class="line"># You can define multiple libraries, and CMake builds them for you.</span><br><span class="line"># Gradle automatically packages shared libraries with your APK.</span><br><span class="line"></span><br><span class="line">add_library( # Sets the name of the library.</span><br><span class="line">        nativedemo</span><br><span class="line"></span><br><span class="line">        # Sets the library as a shared library.</span><br><span class="line">        SHARED</span><br><span class="line"></span><br><span class="line">        # Provides a relative path to your source file(s).</span><br><span class="line">        native-lib.cpp)</span><br></pre></td></tr></table></figure><p>就像注释里描述的那样，根据源文件的路径生成库，Gradle自动打包时会一同放入apk中</p><br/><p>然后来看看使用的地方，在MainActivity中会使用到里面的方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="comment">// Used to load the &#x27;nativedemo&#x27; library on application startup.</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;nativedemo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是初始化，放在了Activity的初始化块中，这样在应用启动时就可以调用<code>System.loadLibrary()</code>方法根据库的名称将库加载进来</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A native method that is implemented by the &#x27;nativedemo&#x27; native library,</span></span><br><span class="line"><span class="comment"> * which is packaged with this application.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">external</span> <span class="function"><span class="keyword">fun</span> <span class="title">stringFromJNI</span><span class="params">()</span></span>: String</span><br></pre></td></tr></table></figure><p>这里是对于<code>JNI</code>方法的声明，在加载完库之后，就可以从中取它了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">    binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example of a call to a native method</span></span><br><span class="line">        binding.sampleText.text = stringFromJNI()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用<code>ViewBinding</code>进行布局元素的操作，调用<code>stringFromJNI()</code>返回字符串，然后将内容显示到布局上</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490541765681649054175831.png" alt="" style="zoom:50%;" /><br/><p>整体流程大致是：</p><ul><li>Gradle调用<code>CMakeLists.txt</code></li><li><code>CMake</code>按照构建脚本中的命令将.cpp编译到共享对象库中，并命名为<code>xxx.so</code>，Gradle之后会将其一同打包到apk中（包分析器可以看到）</li></ul><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490545195721649054519114.png" alt="" style="zoom:70%;" /><ul><li>运行时，MainActivity调用<code>System.loadLibrary()</code>加载原生库</li><li>在<code>onCreate()</code>中MainActivity调用<code>stringFromJNI()</code></li></ul><br/><blockquote><p>开始自定义</p></blockquote><p>首先需要在当前模块下有一个专门的cpp目录</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490550415661649055041171.png" alt="" style="zoom:70%;" /><p>大概是这样的层次结构，模块 &gt; src &gt; main &gt; <strong>cpp</strong></p><br/><p>然后在该目录下放置C++的源代码文件</p><p>接下来就是代码逻辑的编写，去实现我们需要的功能</p><br/><h3 id="3-2-配置CMake"><a class="header-anchor" href="#3-2-配置CMake">¶</a>3.2. 配置CMake</h3><p><code>CMake</code>的构建脚本文件<code>CMakeLists.txt</code>是一个<strong>纯文本文件</strong>，并且使用它必须指定文件的名称为<strong>CMakeLists.txt</strong></p><br/><p>然后需要向其中添加一些需要用到的命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10.2)</span><br></pre></td></tr></table></figure><p>这个命令是设置了构建的最小版本，也就是下限</p><br/><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_library(</span><br><span class="line">  nativedemo</span><br><span class="line">  SHARED</span><br><span class="line">  native-lib.cpp)</span><br></pre></td></tr></table></figure><p>这里给出库的名称、类型、对应的源文件路径</p><blockquote><p><strong>注意</strong></p><p>so库的名称总是以lib&lt;CMake中定义的库名称&gt;.so出现，但是使用System.loadLibrary()时还是使用CMake中定义的名称</p></blockquote><br/><h3 id="3-3-提供CMake脚本文件的路径配置Gradle"><a class="header-anchor" href="#3-3-提供CMake脚本文件的路径配置Gradle">¶</a>3.3. 提供CMake脚本文件的路径配置Gradle</h3><p>实现Gradle关联<code>CMake</code>打包，需要在当前模块的<code>build.gradle</code>中进行一些配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">··android &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        externalNativeBuild &#123;</span><br><span class="line">            cmake &#123;</span><br><span class="line">                cppFlags <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            path file(<span class="string">&#x27;src/main/cpp/CMakeLists.txt&#x27;</span>)</span><br><span class="line">            version <span class="string">&#x27;3.10.2&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到需要<code>externalNativeBuild</code>块进行相关配置</p><br/><p>外层的主要用于与Gradle建立连接，而<code>defaultConfog</code>块内层的则进行一些可选的配置项</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter学习笔记（一）</title>
      <link href="/2022/04/03/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/04/03/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>Flutter学习笔记（一）</h1><p>Flutter的官方文档提供了一个理念——<strong>“一切皆为Widget”</strong></p><p>由此可以看得出来<code>Widget</code>在Flutter中的重要地位</p><h2 id="1-Widget是什么？"><a class="header-anchor" href="#1-Widget是什么？">¶</a>1. Widget是什么？</h2><p><code>Widget</code>我们将其理解为<strong>组件</strong>，一个应用的界面往往都比较丰富，上面会有各式各样的组件，像图片、按钮、播放器这些都可以称为组件。</p><p>由于之前自己接触过<code>React</code>的开发，因此我认为，这里的组件就相当于程序中的一个对象，它具有<strong>专门</strong>的功能，与用户进行交互，处理相应的数据，就像你打开<code>Material Design</code>组件库一样，里面各个组件都扮演着特定的角色，为了某一种特定的功能而存在。</p><p>打个更加贴近生活的比方，我们刚搬进新家，而空荡荡的屋子就是我们原始的空白界面，然而我们的日常生活总是需要各种工具或者是家具来满足我们的需要，那么这种需要就相当于是组件所需要具备的功能，每个工具或者家具只是<strong>专门负责某一方面的功能</strong>，此时，在我看来，就可以将家具或工具理解为程序意义上的组件，同时，这些组件的摆放和搭配也形成了界面上丰富多彩的布局。</p><h2 id="2-Widget有哪些？"><a class="header-anchor" href="#2-Widget有哪些？">¶</a>2. Widget有哪些？</h2><ul><li>无状态组件（Stateless Widget）</li><li>有状态组件（Stateful Widget）</li></ul><p>可以将组件根据状态特点分为两个大类</p><h3 id="2-1-无状态组件"><a class="header-anchor" href="#2-1-无状态组件">¶</a>2.1. 无状态组件</h3><p><code>StatelessWidget</code>类直接继承于<code>Widget</code>类</p><p>无状态组件具体做些什么事呢？它的任务很简单，仅仅是将需要展示的内容进行呈现，而后就躺平了。</p><p><code>StatelessWidget</code>是一个抽象类，需要重写抽象方法<code>build()</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> TextButton(</span><br><span class="line">      onPressed: () =&gt; &#123;&#125;,</span><br><span class="line">      child: <span class="keyword">const</span> Text(<span class="string">&#x27;Flutter&#x27;</span>)</span><br><span class="line">      ,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>简单使用一个<code>TextButton</code>的内置组件构成第一个无状态组件的内容，在<code>build</code>方法中返回需要展示的<code>Widget</code>对象</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204031715214.png" alt="image-20220403171552181" style="zoom:40%;" /><h3 id="2-2-有状态组件"><a class="header-anchor" href="#2-2-有状态组件">¶</a>2.2. 有状态组件</h3><p>无状态组件似乎看起来挺简单的，接下来关注一下有状态组件，它能够实现组件状态的切换。</p><p>有状态组件需要继承自<code>StatefulWidget</code>类，另外，由于其需要对状态进行操作，还会涉及到<code>State</code>类</p><p>首先，先定义一个继承于<code>StatefulWidget</code>类的组件，并且重写<code>createState()</code>方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> text = <span class="string">&#x27;空空如也&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _AnotherWidgetState createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _AnotherWidgetState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给出text作为一个组件的属性，用于显示文本</p><p><code>State</code>类是一个抽象类，<code>createState()</code>需要返回一个状态，因此，专门为该组件设置一个状态类</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnotherWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnotherWidget</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> textState = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化状态</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    textState = widget.text;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定义一个函数来更新状态</span></span><br><span class="line">  <span class="keyword">void</span> _changeText(<span class="built_in">String</span> s) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      textState = s;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> TextButton(</span><br><span class="line">        onPressed: () =&gt; _changeText(<span class="string">&#x27;内有玄机&#x27;</span>),</span><br><span class="line">        child: Text(textState)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义该组件的状态，让其继承<code>State</code>类，使用泛型让它和对应的组件间建立联系</p><p>而后对应的泛型会被赋给<code>State</code>的成员<code>widget</code>上，通过该成员便可以获取之前定义的组件上的text属性</p><p>重写<code>initState()</code>方法对状态进行初始化的赋值操作，这里使用textState记录状态</p><p><code>setState()</code>则是用来更新状态的，在这里就是将变量进行修改</p><p><code>build()</code>就像之前无状态组件里的一样，用于呈现组件，利用其<code>onPressed</code>属性，监听点击，触发状态修改</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204032037870.png" alt="image-20220403203721828" style="zoom:50%;" /><img src="/Users/shenzhisheng/Library/Application Support/typora-user-images/image-20220403203810971.png" alt="image-20220403203810971" style="zoom:50%;" /></p><p>这样，通过对于变量textState的修改，更新了UI的文本显示</p><h2 id="3-几个重要的方法"><a class="header-anchor" href="#3-几个重要的方法">¶</a>3. 几个重要的方法</h2><h3 id="3-1-setState"><a class="header-anchor" href="#3-1-setState">¶</a>3.1. setState()</h3><p>在有状态组件中，通过数据的变更来触发UI的改变，<code>setState()</code>方法就是用来操作状态的，它所起到的作用就是<strong>触发组件树的重建，并且将新的状态数据更新到组件上</strong></p><p>基于上面的代码，也就是说，按下按钮触发<code>_changeText(String s)</code>方法，从而调用内部的`setState() 通知关联的组件进行重建，以呈现新的状态</p><h3 id="3-2-initState"><a class="header-anchor" href="#3-2-initState">¶</a>3.2. initState()</h3><p>这是组件状态对象中第一个被调用的方法，正如其名字一样，主要进行一些状态初始化的操作，属于状态生命周期里的内容</p><h2 id="3-3-dispose"><a class="header-anchor" href="#3-3-dispose">¶</a>3.3. dispose()</h2><p>与<code>initState()</code>相对应，在状态生命周期结束前调用，主要用于释放资源</p><h2 id="3-4-build"><a class="header-anchor" href="#3-4-build">¶</a>3.4. build()</h2><p>在无状态组件和有状态组件的状态类中都有它的踪影</p><p>组件通过组合往往会形成更加复杂的组件，将组件呈现出来的过程总是离不开“套娃”。其实这也是对应了<strong>组件树</strong>的概念</p><p><code>build()</code>返回的<code>Widget</code>其实是最外层的组件，因为将里面的内容相当于打了个包，这样便将整个需要显示的内容都准备好了</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>视图绑定</title>
      <link href="/2022/04/02/%E8%A7%86%E5%9B%BE%E7%BB%91%E5%AE%9A/"/>
      <url>/2022/04/02/%E8%A7%86%E5%9B%BE%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h1>ViewBinding</h1><h2 id="1-准备工作"><a class="header-anchor" href="#1-准备工作">¶</a>1. 准备工作</h2><p>首先需要在模块中启用“视图绑定”，在模块对应的<code>build.gradle</code>中添加配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdk <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    viewBinding &#123;</span><br><span class="line">        enabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后项目就下载了对应依赖</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/WechatIMG9.png" alt="WechatIMG9"></p><p>启用完成后，系统会为该模块下的所有布局XML文件生成一个<strong>与之对应的绑定类</strong></p><br/><h2 id="2-绑定类"><a class="header-anchor" href="#2-绑定类">¶</a>2. 绑定类</h2><p>布局XML中会有一些组件设置id属性，这些属性在对应的绑定类中可以直接通过id来获取，这些控件相当于类的成员，根组件和其他有id的组件的引用都包含其实例之中</p><br/><h3 id="2-1-命名方式"><a class="header-anchor" href="#2-1-命名方式">¶</a>2.1. 命名方式</h3><p>绑定类会以“Binding”结尾，采用大驼峰</p><h3 id="2-2-根视图"><a class="header-anchor" href="#2-2-根视图">¶</a>2.2. 根视图</h3><p>可以通过<code>getRoot()</code>获取对于布局文件中根视图的引用</p><br/><h2 id="3-使用"><a class="header-anchor" href="#3-使用">¶</a>3. 使用</h2><h3 id="3-1-Activity中"><a class="header-anchor" href="#3-1-Activity中">¶</a>3.1. Activity中</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="comment">// 调用绑定类的inflate静态方法，对象实例化</span></span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        <span class="comment">// 获取根布局</span></span><br><span class="line">        <span class="keyword">val</span> view = binding.root</span><br><span class="line">        setContentView(view)</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure><p>然后就可以通过绑定类的实例去操作布局文件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">binding.run &#123;</span><br><span class="line">            ivLogo.setImageResource(R.drawable.ic_launcher_background)</span><br><span class="line">            tvContent.setText(R.string.app_name)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-Fragment中"><a class="header-anchor" href="#3-2-Fragment中">¶</a>3.2. Fragment中</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: FragmentBlankBinding</span><br><span class="line"></span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View &#123;</span><br><span class="line">        binding = FragmentBlankBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> binding.root</span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure><p>同样得到了布局文件绑定类的实例，然后可以使用其中的引用去操作布局中的组件</p><p><strong>在Fragment中，由于其视图的生命周期短于Fragment自身的生命周期，因此需要在<code>onDestroyView()</code>中清除对绑定类实例的引用</strong></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/29/hello-world/"/>
      <url>/2022/03/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2><h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
