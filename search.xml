<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>怎么学Unity开发（一）</title>
      <link href="/2022/04/19/%E6%80%8E%E4%B9%88%E5%AD%A6Unity%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/04/19/%E6%80%8E%E4%B9%88%E5%AD%A6Unity%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>怎么学Unity开发（一）</h1><h2 id="1-创建一个新项目"><a class="header-anchor" href="#1-创建一个新项目">¶</a>1. 创建一个新项目</h2><p>首先打开新建项目的页面，里面会有很多游戏模板可供选择</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171652306.png" style="zoom: 33%;" /><p>直接选用3D模板进行接下来的开发</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171701337.png" alt="image-20220417170128306" style="zoom: 50%;" /><p>给项目起个名字，然后指定一个存放路径，完成后点击”创建项目“</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171703111.png" alt="image-20220417170358066"></p><p>等待一段时间之后，编辑器会被激活，打开以上界面，项目创建完成</p><h2 id="2-常用设置"><a class="header-anchor" href="#2-常用设置">¶</a>2. 常用设置</h2><p>一个功能复杂的工具往往只需要熟悉一些常用的功能就可以很好得进行运用，其他的内容总是能够在日日复一日的积累和使用中不断加深印象，逐渐形成个人的习惯和体系</p><h3 id="2-1-首选项"><a class="header-anchor" href="#2-1-首选项">¶</a>2.1. 首选项</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171844852.png" alt="image-20220417184422814" style="zoom:50%;" /><p>这里面主要包含了编辑器工具的一些属性设置，主要体现了一些个人偏好，比如：界面的配色、显示内容使用的语言等</p><h3 id="2-2-项目设置"><a class="header-anchor" href="#2-2-项目设置">¶</a>2.2. 项目设置</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171847888.png" alt="image-20220417184715865" style="zoom:40%;" /><p>这里的设置内容往往是关联当前的这个项目的，比如：场景、物理、输出质量等</p><h3 id="2-3-资源"><a class="header-anchor" href="#2-3-资源">¶</a>2.3. 资源</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171851628.png" alt="image-20220417185152560" style="zoom:40%;" /><p>用得比较多的可能是一些游戏资源的创建，以及游戏资源、素材的导入导出功能</p><h3 id="2-4-游戏对象"><a class="header-anchor" href="#2-4-游戏对象">¶</a>2.4. 游戏对象</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171854598.png" alt="image-20220417185450569" style="zoom:50%;" /><p>游戏对象最终需要在场景中扮演角色，根据其功能和外观可以分为多个类型，也是<strong>最需要被关注的内容</strong></p><h3 id="2-5-组件"><a class="header-anchor" href="#2-5-组件">¶</a>2.5. 组件</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171858344.png" alt="image-20220417185801309" style="zoom:50%;" /><p>组件要依赖于游戏对象，因此只有在选定相应的游戏对象之后，其功能才会可用，主要用于丰富游戏对象的功能和结构</p><h3 id="2-6-窗口"><a class="header-anchor" href="#2-6-窗口">¶</a>2.6. 窗口</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171900877.png" alt="image-20220417190057842" style="zoom:33%;" /><p>主要功能是对于窗口的管理，调整布局、包管理器以及一些窗口可见性的控制</p><h2 id="3-界面划分"><a class="header-anchor" href="#3-界面划分">¶</a>3. 界面划分</h2><h3 id="3-1-运行控制"><a class="header-anchor" href="#3-1-运行控制">¶</a>3.1. 运行控制</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171908664.png" alt="image-20220417190850621" style="zoom:50%;" /><p>这个界面非常简洁，主要就是控制游戏的运行</p><h3 id="3-2-视口"><a class="header-anchor" href="#3-2-视口">¶</a>3.2. 视口</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171911649.png" alt="image-20220417191140613" style="zoom: 33%;" /><p>这个区域往往是占比最大的，游戏世界就是通过这个界面来进行展现的。</p><p><code>Scene</code>是用来向开发者展示游戏的搭建情况，方便浏览和定位；而<code>Game</code>展示的玩家的视角，用来给目标用户看的</p><h3 id="3-3-层级面板"><a class="header-anchor" href="#3-3-层级面板">¶</a>3.3. 层级面板</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171910917.png" alt="image-20220417191037877" style="zoom:50%;" /><p>这个面板的内容是与视口对应的，放置到视口的游戏对象都会以列表的形式展现在这个面板上，也可以很清晰看到对象间的层级关系</p><p>在游戏对象很多、场景很复杂的情况下，使用层级面板无疑会更有效率</p><h3 id="3-4-项目面板"><a class="header-anchor" href="#3-4-项目面板">¶</a>3.4. 项目面板</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204171920154.png" alt="image-20220417192043117" style="zoom: 50%;" /><p>一个游戏下载下来，在它的目录下可以找到许多资源的目录，这些目录提供的是用于支持游戏的一些静态资源，如：图片、音乐、模型等，以及编写脚本，视口所展示的内容，实际上会被存成场景文件，依然属于项目管理的范畴</p><p>这些内容开发者使用项目面板进行分类管理，会在开发时显得条理清晰，也能很好地提高开发效率</p><h3 id="3-5-检查器（其实我觉得详情更合适）"><a class="header-anchor" href="#3-5-检查器（其实我觉得详情更合适）">¶</a>3.5. 检查器（其实我觉得详情更合适）</h3><img src="/Users/shenzhisheng/Library/Application Support/typora-user-images/image-20220417215337955.png" alt="image-20220417215337955" style="zoom: 33%;" /><p>当选中一个游戏对象后，这个面板上会浮现出该游戏对象所有的属性，可以方便地对于属性进行修改</p><h3 id="3-6-控制台"><a class="header-anchor" href="#3-6-控制台">¶</a>3.6. 控制台</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204172157596.png" alt="image-20220417215710559" style="zoom:33%;" /><p>这个面板可能通常状态下处于隐藏状态，但是可以通过<code>Window</code>找到它，或者使用<code>shift + command + C</code>将其呼出</p><p>它显示的主要是一些日志信息，在游戏画面中，有些问题可能看不出来，因此在调试过程中添加日志，能够对于游戏各个功能的执行有更加细致的把握，也可以在追踪问题时，发挥很大的作用</p><h2 id="4-游戏物体的创建及操作"><a class="header-anchor" href="#4-游戏物体的创建及操作">¶</a>4. 游戏物体的创建及操作</h2><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204172207047.png" alt="image-20220417220744013" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204172212813.png" alt="image-20220417221203769" style="zoom:50%;" /></p><p>创建游戏物体既可以在编辑器中选中顶部的<code>Game Object</code>，也可以直接在层级面板中右击进行创建，或者使用层级面板顶部的”+“</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204172215037.png" alt="image-20220417221536003" style="zoom:50%;" /><p>当然，也可以快捷地借助已有的游戏对象进行创建，选定游戏对象<code>command + C</code>、<code>command + V</code>复制粘贴，或者直接使用<code>command + D</code>，直接复制粘贴一起</p><h3 id="4-1-常用的基础模型对象"><a class="header-anchor" href="#4-1-常用的基础模型对象">¶</a>4.1. 常用的基础模型对象</h3><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204172240947.png" alt="image-20220417224057899" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204172242365.png" alt="image-20220417224237327" style="zoom:33%;" /></p><p>正好从左到右对应是这些对象</p><blockquote><p>注意：平面和四边形都是单面的，仅有一面可见，并且在性能消耗上，四边形更少</p><p>模型由网格构成，这些网格其实就是图元（三角形），这涉及着色器的知识，使用图元少，用到的三角形顶点就少，计算的内容就会少，那么同等情况下，性能消耗就会少一些</p></blockquote><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204172246931.png" alt="image-20220417224606890" style="zoom:33%;" /><h3 id="4-2-视角调整"><a class="header-anchor" href="#4-2-视角调整">¶</a>4.2. 视角调整</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204172257155.png" alt="image-20220417225725117" style="zoom: 50%;" /><p>在视口中移动鼠标，并且按住右键时，会发现鼠标变成”眼睛“图标，此时工具栏如上图所示，继续按住右键可以以当前位置为轴心，在场景中浏览</p><p>前后滚动鼠标，可以将场景拉近拉远</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204172303817.png" alt="image-20220417230339775" style="zoom:33%;" /><p>双指按住，激活抓手工具，进行场景拖拽，如果使用过ps一类的工具，应该会很熟悉</p><p>以上几种操作进行配合，可以很方便的在场景中进行浏览</p><h3 id="4-3-坐标系"><a class="header-anchor" href="#4-3-坐标系">¶</a>4.3. 坐标系</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204180734034.png" alt="image-20220418073404001" style="zoom: 33%;" /><p>Unity内部采用的是左手坐标系</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204180736904.png" alt="image-20220418073637865" style="zoom:50%;" /><p>如同视口右上角的<code>Gizmo</code>显示的一样</p><h4 id="4-3-1-世界坐标系"><a class="header-anchor" href="#4-3-1-世界坐标系">¶</a>4.3.1. 世界坐标系</h4><p>所有在场景中创建的游戏对象的位置都是相对于世界坐标的</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204180741925.png" alt="image-20220418074120877" style="zoom:50%;" /><p>在<code>Inspector</code>面板中可以查看游戏对象的该属性</p><p><strong>世界坐标系本身是固定不变的</strong></p><h4 id="4-3-2-本地坐标系"><a class="header-anchor" href="#4-3-2-本地坐标系">¶</a>4.3.2. 本地坐标系</h4><p>除了世界坐标系，每个创建的物体还有一个自身的本地坐标系</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204180806042.png" alt="image-20220418080636995" style="zoom:50%;" /><p>首先，建立一个关系，让球体成为立方体的子物体，直接在层级面板上将球体拖动到立方体上</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204180808036.png" alt="image-20220418080840993" style="zoom:50%;" /><p>此时，选中立方体会同时选中球体，反之不可以</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204180809069.png" alt="image-20220418080958020" style="zoom:50%;" /><p>直接移动立方体，立方体的坐标会变，而球体的目标始终不变，因为球体目前的参考对象是立方体，处于立方体的本地坐标系中</p><blockquote><p>在物体没有父物体时，才会使用世界坐标系，或者也可以将世界看作是一切物体的父物体</p></blockquote><h4 id="4-3-3-中心和轴心"><a class="header-anchor" href="#4-3-3-中心和轴心">¶</a>4.3.3. 中心和轴心</h4><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182221194.png" alt="image-20220418222153157" style="zoom:50%;" /><p>在启用<strong>中心</strong>的情况下，选中有父子级关系的两个物体中的父物体，其中心是经过<strong>重新计算</strong>的，因为系统会将两个物体当做整体，这时候坐标轴出现在二者之间</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182226704.png" alt="image-20220418222617675" style="zoom: 50%;" /><p>再切换到<strong>轴心</strong>，此时坐标轴中心移到了父物体的中心</p><p>选中子物体的坐标轴中心并不会改变</p><h4 id="4-3-4-世界坐标与本地坐标切换"><a class="header-anchor" href="#4-3-4-世界坐标与本地坐标切换">¶</a>4.3.4. 世界坐标与本地坐标切换</h4><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182237504.png" alt="image-20220418223736467" style="zoom:50%;" /><p>在切换到世界坐标系时，坐标轴的方向与右上角的<code>Gizmo</code>一致，作为整个场景的坐标轴，所有物体都遵循这个规则，选中后会显示对应方向的坐标轴</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182241256.png" style="zoom: 50%;" /><p>即使进行旋转等操作，依然保持原来的指向</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182249461.png" alt="image-20220418224922417" style="zoom:50%;" /><p>切换到本地坐标系，现在的坐标系是游戏物体自己的，不必遵循原来的规则，跟随着物体的变化而变化</p><h2 id="5-物体的基本操作"><a class="header-anchor" href="#5-物体的基本操作">¶</a>5. 物体的基本操作</h2><h3 id="5-1-移动工具"><a class="header-anchor" href="#5-1-移动工具">¶</a>5.1. 移动工具</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182255497.png" alt="image-20220418225511463" style="zoom:50%;" /><p>快捷键<code>W</code>，显示坐标轴，可以选中坐标轴仅在对应的方向上进行移动</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182257257.png" alt="image-20220418225703213" style="zoom:50%;" /><p>或者选中两个轴之间的方形，仅在选定的平面上进行移动</p><h3 id="5-2-旋转工具"><a class="header-anchor" href="#5-2-旋转工具">¶</a>5.2. 旋转工具</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182302021.png" alt="image-20220418230220951" style="zoom:50%;" /><p>快捷键<code>E</code>，可以选定方向进行旋转</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182306592.png" alt="image-20220418230642555" style="zoom:50%;" /><p>也可以利用查看器进行输入，更加容易获得精准的角度</p><h3 id="5-3-缩放工具"><a class="header-anchor" href="#5-3-缩放工具">¶</a>5.3. 缩放工具</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182310642.png" alt="image-20220418231039594" style="zoom:50%;" /><p>快捷键<code>R</code>，可以选定轴进行缩放，默认为倍数为1，也可以选中中间整体进行缩放</p><h3 id="5-4-矩形工具"><a class="header-anchor" href="#5-4-矩形工具">¶</a>5.4. 矩形工具</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182323620.png" alt="image-20220418232358554" style="zoom:50%;" /><p>快捷键<code>T</code>，主要应用于2D场景和游戏UI绘制上，因为这个工具的作用对象是一个平面，因此将场景切换为2D模式，可以使用该工具进行调整</p><h3 id="5-5-三位一体"><a class="header-anchor" href="#5-5-三位一体">¶</a>5.5. 三位一体</h3><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204182334884.png" alt="image-20220418232809276" style="zoom:50%;" /><p>快捷键<code>Y</code>，其实就是将移动、旋转、缩放的功能综合在一起了</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart学习笔记（二）</title>
      <link href="/2022/04/15/Dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/04/15/Dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>Dart学习笔记（二）</h1><h2 id="1-运算符"><a class="header-anchor" href="#1-运算符">¶</a>1. 运算符</h2><p>在<code>Dart</code>中的运算符使用与现代的大多编程语言大都类似</p><h3 id="1-1-关系运算符"><a class="header-anchor" href="#1-1-关系运算符">¶</a>1.1. 关系运算符</h3><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img202204142308448.png" alt="image-20220414230828424"></p><p>关系运算符的用法与其他编程语言中的基本没有多少区别，主要注意一下相等</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较运算符</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (num1 == num2) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="keyword">true</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里相等的当然是内容，如果需要判断两者为同一对象，使用<code>identical()</code></p><h3 id="1-2-算术运算符"><a class="header-anchor" href="#1-2-算术运算符">¶</a>1.2. 算术运算符</h3><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img202204142311103.png" alt="image-20220414231128986"></p><p>以上为一些常用运算符，可能特殊一点是</p><p>~/（取整） %（取余）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num5 = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> num6 = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">print</span>(num5 ~/ num6);</span><br></pre></td></tr></table></figure><p>这样的结果只会取到整数部分的1</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num5 = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">var</span> num6 = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">print</span>(num5 % num6);</span><br></pre></td></tr></table></figure><p>换成<code>%</code>取得就是余数1</p><p>并且需要注意，这里的<code>/</code>操作，返回的是<code>double</code>，与传统的c-like语言有点不同</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img202204142322372.png" alt="image-20220414232234291"></p><p><code>++</code>，<code>--</code>前后皆可，没什么特别</p><h3 id="1-3-类型判断"><a class="header-anchor" href="#1-3-类型判断">¶</a>1.3. 类型判断</h3><p>主要用于在代码<strong>运行时</strong>对于字段的类型进行检查</p><p><code>is</code>用于判断变量是否属于某个类型</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> <span class="built_in">int</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>is!</code>这个符号很奇葩，<code>!</code>一定注意是在后面😂</p><p>意思与<code>is</code>相反</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span>! <span class="built_in">int</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>as</code>代表一种强转，他需要<strong>目标类型从属于原类型</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">as</span> <span class="built_in">int</span>);</span><br></pre></td></tr></table></figure><p>一切都是<code>Object</code>，那么自然可以取出<code>int</code>，当然，既然是强转，不匹配是会抛异常的</p><h3 id="1-4-赋值运算符"><a class="header-anchor" href="#1-4-赋值运算符">¶</a>1.4. 赋值运算符</h3><p>其他都很到理解，与其他语言没什么两样，比较特殊的应该就是<strong>为空赋值</strong></p><p><code>??=</code>表示为空赋值</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 可能有其他处理</span></span><br><span class="line">b ??= <span class="string">&#x27;--&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(b);  <span class="comment">// --</span></span><br></pre></td></tr></table></figure><p>这种使用场景可能在接口返回时使用，主要作为缺省值，后端返回为null，显示缺省，否则就显示对应字段</p><h3 id="1-5-条件表达式"><a class="header-anchor" href="#1-5-条件表达式">¶</a>1.5. 条件表达式</h3><p>三元运算符和其他语言的差不多，但是需要注意<code>??</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">var</span> b = a ?? <span class="number">5</span>;</span><br><span class="line"><span class="built_in">print</span>(b);  </span><br></pre></td></tr></table></figure><p>与<code>??=</code>相似，那个是处理左值可能为空的情况，这个是右值，主要还是用于保证非空类型不会为空</p><h3 id="1-6-基础的类型转换"><a class="header-anchor" href="#1-6-基础的类型转换">¶</a>1.6. 基础的类型转换</h3><p>经常会用到的可能就是<code>String</code>和<code>Number</code>之间的转化了</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// toString()</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="number">23.36</span>;</span><br><span class="line"><span class="keyword">var</span> str = d.toString();</span><br></pre></td></tr></table></figure><p>数值类型转化为<code>String</code>直接可以调用<code>toString</code>方法，相当于给原来的数值外面加上括号</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parse()</span></span><br><span class="line"><span class="built_in">String</span> s = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="comment">// 异常添加try...catch</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">int</span>.parse(s);</span><br><span class="line"><span class="keyword">if</span> (num3 <span class="keyword">is</span> <span class="built_in">int</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(num3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>String</code>转为数值类型，可以通过对应数值类型的<code>parse()</code>方法，但是，由于不是所有<code>String</code>都能是<code>Number</code>，所以可能会发生异常，实际应用中需要加上<code>try...catch</code>，防止程序崩溃</p><blockquote><p>其他语句表达式与其他语言相似，想深入了解，文档依然是最好的选择</p><p><a href="https://www.dartcn.com/guides/language/language-tour#%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F">Dart文档（https://www.dartcn.com/guides/language/language-tour）</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart学习笔记（一）</title>
      <link href="/2022/04/12/Dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/04/12/Dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>Dart学习笔记（一）</h1><p>作为编写<code>Flutter</code>应用的工具语言，当然还是还是跑不掉的</p><blockquote><p>Dart是面向对象的、类定义的、单继承的语言。它的语法类似C语言，可以转译为JavaScript，支持接口(interfaces)、混入(mixins)、抽象类(abstract classes)、具体化泛型(reified generics)、可选类型(optional typing)和sound type system 。                                                                                 ——百度百科</p></blockquote><p>由Google开发，<code>Flutter</code>基于<code>Dart</code>开发，并且在2018年，<code>Dart2</code>成为强类型语言，总的来说，它还比较新，目前对于它的了解仍停留在其是<code>Flutter</code>的**“工具语言”**</p><h2 id="1-程序的入口"><a class="header-anchor" href="#1-程序的入口">¶</a>1. 程序的入口</h2><p>至关重要的一点，程序的入口，与其他编程语言一样，<code>Dart</code>老实本分地遵循着传统，以<code>main()</code>作为起点</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="comment">// 或者void main表示没有返回值</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Hello Dart&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以直接写成<code>main()</code>或者前面加上<code>void</code>表明其没有返回值</p><h2 id="2-注释"><a class="header-anchor" href="#2-注释">¶</a>2. 注释</h2><p>良好的注释对于所有程序员都很重要，包括自己</p><p><code>Dart</code>中支持单行注释、多行注释以及文档注释</p><h3 id="2-1-单行注释"><a class="header-anchor" href="#2-1-单行注释">¶</a>2.1. 单行注释</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释</span></span><br></pre></td></tr></table></figure><p>这个用的最为频繁，对于各种方法、变量、语句都很适用，就像读书时加批注一样</p><h3 id="2-2-多行注释"><a class="header-anchor" href="#2-2-多行注释">¶</a>2.2. 多行注释</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个无非是多注释几行，如果需要描述的内容多一些可以用这个</p><h3 id="2-3-文档注释"><a class="header-anchor" href="#2-3-文档注释">¶</a>2.3. 文档注释</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file</span></span><br><span class="line"><span class="comment">// for details. All rights reserved. Use of this source code is governed by a</span></span><br><span class="line"><span class="comment">// BSD-style license that can be found in the LICENSE file.</span></span><br></pre></td></tr></table></figure><p>像这个注释就比较规范了，通常用在声明类和文件时，总体描述作用时使用，最常见的就是在源码里面</p><p>总之，如果不确定在哪里用什么样的注释，源码总是最好的参考</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img202204102325039.png" alt="image-20220410232524898" style="zoom:67%;" /><h2 id="3-变量"><a class="header-anchor" href="#3-变量">¶</a>3. 变量</h2><p>变量可以使用<code>var</code>进行定义</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 类型推断</span></span><br></pre></td></tr></table></figure><p>编译器会根据初始化的值进行<code>类型推断</code>，这里会被推断为<code>String</code></p><p>除此以外，也可以<strong>使用指定的类型进行声明</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> s = <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>直接使用指定的类型声明为该类型的变量</p><h2 id="4-常量"><a class="header-anchor" href="#4-常量">¶</a>4. 常量</h2><p>在<code>Dart</code>中，常量通常使用<code>const</code>和<code>final</code>声明</p><p>使用<code>const</code>表示，可以直接替代<code>var</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>; <span class="comment">// 类型推导</span></span><br></pre></td></tr></table></figure><p>直接使用<code>const</code>，编译器可以根据赋值进行类型推导</p><p>也可以直接加上具体类型</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">String</span> DATE_FORMAT = <span class="string">&#x27;yyyy-MM-dd&#x27;</span>;</span><br></pre></td></tr></table></figure><p><code>const</code>声明的是<strong>编译期</strong>常量，即在程序开始运行之前，就进行赋值</p><p><code>final</code>的使用方面同样也有两种</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> now = <span class="keyword">new</span> <span class="built_in">DateTime</span>.now();  <span class="comment">// 惰性初始化</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">int</span> length = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>但是尤其需要主要的是，<code>final</code>声明的常量可以接受函数调用，只有它可以获取运行时的量进行赋值，这也是其与<code>const</code>最大的不同</p><h2 id="5-数据类型"><a class="header-anchor" href="#5-数据类型">¶</a>5. 数据类型</h2><p>与其他各类编程语言如出一辙，<code>Dart</code>也需要丰富的数据类型给处理的数据分分类</p><h3 id="5-1-字符串"><a class="header-anchor" href="#5-1-字符串">¶</a>5.1. 字符串</h3><p>这绝对是最最最常用到的类型了</p><p><code>String</code>用来表示字符串，直接可以使用<code>String</code>声明该类型的变量</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> s2 = <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><p>单引号、双引号都可以，保持一种习惯较好</p><p>不过声明更加推荐的方式还是直接进行<strong>类型推导</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>除此以外，<code>Dart</code>还提供了使用<code>'''</code>或<code>&quot;&quot;&quot;</code>括起来的写法，用来输出带有格式的字符串</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">String</span> s3 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  Hello, </span></span><br><span class="line"><span class="string">    World!</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>;</span><br><span class="line">  <span class="built_in">print</span>(s3);</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img202204112310753.png" alt="image-20220411231011454" style="zoom:100%;" /><p>和预览的效果完全一致</p><p>字符串的拼接有两种，一种使用<code>+</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s4 = <span class="string">&#x27;Happy&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s5 = <span class="string">&#x27; Birthday!&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(s4 + s5);</span><br></pre></td></tr></table></figure><p>而另一种使用的是<strong>模板占位</strong>，运用<code>$</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$s4</span><span class="subst">$s5</span>&#x27;</span>);</span><br></pre></td></tr></table></figure><p>使用这种方式先占位，程序会替换，与<code>Kotlin</code>的模板字符串完全一致，非常舒适</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img202204112317308.png" alt="image-20220411231715184"></p><h3 id="5-2-数值类型"><a class="header-anchor" href="#5-2-数值类型">¶</a>5.2. 数值类型</h3><p>主要分为整数与浮点</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值类型</span></span><br><span class="line"><span class="built_in">int</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">double</span> b = <span class="number">12.56</span>;</span><br></pre></td></tr></table></figure><p>整数使用<code>int</code>，小数使用<code>double</code>，简单粗暴，当然，同样推荐使用类型推导</p><p>另外，<code>int</code>可以直接赋值给<code>double</code>，反之不可</p><h3 id="5-3-布尔类型"><a class="header-anchor" href="#5-3-布尔类型">¶</a>5.3. 布尔类型</h3><p>没有太多可说的，<code>bool</code>定义，总共两个值：true和false</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">var</span> mFlag = <span class="keyword">false</span>;  <span class="comment">// 推导</span></span><br></pre></td></tr></table></figure><h3 id="5-4-List（数组-集合）"><a class="header-anchor" href="#5-4-List（数组-集合）">¶</a>5.4. List（数组/集合）</h3><p><code>[]</code>可以声明一个<code>List</code>，没有指定类型的情况下什么都可以往里放</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list1 = [<span class="string">&#x27;呱太&#x27;</span>, <span class="number">666</span>, <span class="keyword">false</span>];</span><br><span class="line"><span class="built_in">print</span>(list1);</span><br></pre></td></tr></table></figure><p>并且<code>List</code>的<code>length</code>属性可以获取长度</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;长度=<span class="subst">$&#123;list1.length&#125;</span>&#x27;</span>);</span><br></pre></td></tr></table></figure><p>如果想要访问<code>List</code>中的元素，可以通过<code>索引</code>进行获取</p><blockquote><p>和其他语言一样，索引从0开始</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(list1[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>可以使用<code>&lt;T&gt;</code>的方式为<code>List</code>中的元素限定类型</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list2 = &lt;<span class="built_in">String</span>&gt;[<span class="string">&#x27;阿凡提&#x27;</span>, <span class="string">&#x27;钢铁侠&#x27;</span>, <span class="string">&#x27;皮卡丘&#x27;</span>];</span><br><span class="line"><span class="built_in">print</span>(list2);</span><br></pre></td></tr></table></figure><p>这就不能自由发挥了，必须按照规矩办事</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list3 = []; <span class="comment">// 空List</span></span><br><span class="line">list3.add(<span class="string">&#x27;Van&#x27;</span>); <span class="comment">// 增加数据</span></span><br></pre></td></tr></table></figure><p>也可以先创建空的<code>List</code>，然后调用<code>add()</code>向其中填充元素，构建一个完整的<code>List</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个固定长度的集合</span></span><br><span class="line"><span class="keyword">var</span> list4 = <span class="built_in">List</span>.filled(<span class="number">3</span>, <span class="number">1</span>); <span class="comment">// growable属性为false，不可add，显示标明true可以add</span></span><br><span class="line">  <span class="comment">// list4.add(5);</span></span><br><span class="line"><span class="built_in">print</span>(list4);</span><br></pre></td></tr></table></figure><p>在<code>Java</code>中，集合是可以动态增长的，而数组则是在声明时给定了容量</p><p><code>List</code>的<code>filled(length, element)</code>方法会初始化指定长度<code>length</code>的数组，里面的元素使用给定的<code>element</code></p><blockquote><p>这个方法返回的<code>List</code>是默认growable为false，也就是不可增长的</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">external</span> <span class="keyword">factory</span> <span class="built_in">List</span>.filled(<span class="built_in">int</span> length, E fill, &#123;<span class="built_in">bool</span> growable = <span class="keyword">false</span>&#125;);</span><br></pre></td></tr></table></figure><p>源码里能看到<code>growable</code>，如果显示设置为true，就会转变为先前几个<code>List</code>那样，可以动态增长，当然，不能增长，你猜<code>add（）</code>会不会报错😏</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改非定长的集合的长度</span></span><br><span class="line">list1.length = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>直接修改<code>length</code>默认会<code>set</code>（当然<code>List</code>得是能变的那种）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">注释的解释 如果新的长度更大，新元素会赋值null，注意当前类型是否允许空值</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">The list must be growable.</span></span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img202204112348039.png" alt="image-20220411234824911"></p><h3 id="5-5-Map（字典-映射表）"><a class="header-anchor" href="#5-5-Map（字典-映射表）">¶</a>5.5. Map（字典/映射表）</h3><p><code>Map</code>常用于二级列表</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map 定义，类似于Json数据</span></span><br><span class="line">  <span class="keyword">var</span> map1 = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;minos&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&#x27;hobbies&#x27;</span>: [<span class="string">&#x27;唱&#x27;</span>, <span class="string">&#x27;跳&#x27;</span>, <span class="string">&#x27;rap&#x27;</span>, <span class="string">&#x27;魁地奇&#x27;</span>]</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>定义似乎和JS中的对象差不多，<code>key</code>和<code>value</code>可以指定任意类型，但<code>key</code>通常使用<code>String</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据访问</span></span><br><span class="line"><span class="built_in">print</span>(map1[<span class="string">&#x27;name&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>通过<code>key</code>来获取<code>Map</code>对象中与之对应的<code>value</code></p><p>当一个<code>key</code>对应多个<code>value</code>就会产生分组的形式，也就二级列表</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建空的map并向其中添加元素</span></span><br><span class="line"><span class="keyword">var</span> map2 = <span class="built_in">Map</span>();</span><br><span class="line">map2[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;伏地魔&#x27;</span>;</span><br><span class="line"><span class="built_in">print</span>(map2);</span><br></pre></td></tr></table></figure><p>另外，调用<code>Map()</code>会创建一个空的<code>Map</code>实例，<code>Dart2</code>中省去了<code>new</code>关键字</p><p>直接通过给<code>key</code>赋值，就能添加对应数据，对应到<code>key</code>和<code>value</code>的关联关系</p><h2 id="6-类型判断"><a class="header-anchor" href="#6-类型判断">¶</a>6. 类型判断</h2><p>在编写代码时，有的时候只需要<strong>对关注的特定类型</strong>进行处理</p><p>这个时候就需要<code>is</code>来帮忙筛选一下</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用is关键字判断类型</span></span><br><span class="line"> <span class="comment">// 尤其是服务器返回</span></span><br><span class="line"> <span class="keyword">var</span> params = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"> <span class="keyword">if</span> (params <span class="keyword">is</span> <span class="built_in">String</span>) &#123;  <span class="comment">// 所期望的</span></span><br><span class="line">   <span class="built_in">print</span>(params.length);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params <span class="keyword">is</span> <span class="built_in">int</span>) &#123;</span><br><span class="line">   <span class="comment">// int处理</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们没有把握，或者担心出错，可以保险一点，取数据时添加上类型判断，仅处理需要的，防止返回了意料之外的内容</p><p><strong>只拿需要的，和考虑各种以外情况相比，自然是前者更简单</strong></p>]]></content>
      
      
      <categories>
          
          <category> Dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter学习笔记（四）</title>
      <link href="/2022/04/09/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2022/04/09/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>Flutter学习笔记（四）</h1><h2 id="1-列表组件"><a class="header-anchor" href="#1-列表组件">¶</a>1. 列表组件</h2><p>在实际的应用中，经常会有需要向用户提供大量数据进行阅读的场景，这就需要使用到列表组件展示数据</p><h3 id="1-1-ListView"><a class="header-anchor" href="#1-1-ListView">¶</a>1.1. ListView</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ListView(</span><br><span class="line">          children: [</span><br><span class="line">            Text(<span class="string">&#x27;内容&#x27;</span>),</span><br><span class="line">            ElevatedButton(</span><br><span class="line">                onPressed: () =&gt; &#123;&#125;,</span><br><span class="line">                child: Text(<span class="string">&#x27;按钮&#x27;</span>)</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>对于<code>ListView</code>组件而言最重要的是内容，也就是<code>children</code>属性，它所接收的是<code>Widget</code>列表，理论上只要是<code>Widget</code>就可以放</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204082343867.png" alt="image-20220408234337755" style="zoom: 50%;" /><p>通常是使用<code>ListTile</code>组件进行搭配使用</p><p><code>ListTile</code>代表的就是列表中的一项，利用其属性可以方便组合列表项的样式</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ListTile(</span><br><span class="line">              leading: Image.network(<span class="string">&#x27;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Ffile01.dysucai.com%2Fd%2Ffile%2Flan2018061913%2Fk0ajx12543d.jpg&amp;refer=http%3A%2F%2Ffile01.dysucai.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1651720679&amp;t=7c87729681050f86d1340f1412b7eb52&#x27;</span>),   <span class="comment">// 开头的图片</span></span><br><span class="line">              title: Text(<span class="string">&#x27;标题&#x27;</span>),  <span class="comment">// 标题</span></span><br><span class="line">              subtitle: Text(<span class="string">&#x27;二级标题&#x27;</span>),    <span class="comment">// 子标题</span></span><br><span class="line">              trailing: Icon(Icons.keyboard_arrow_right),   <span class="comment">// 结尾的图片</span></span><br><span class="line">            ),</span><br></pre></td></tr></table></figure><p>以上就是<code>ListTile</code>常用的一些属性，然后多复制几个</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204091341330.png" style="zoom: 50%;" /><p><code>ListView</code>默认是沿垂直方向滚动，可以通过<code>scrollDirection</code>属性进行修改</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ListView(</span><br><span class="line">          scrollDirection: Axis.horizontal,</span><br><span class="line">          children: [</span><br><span class="line">           Container(</span><br><span class="line">             width: <span class="number">150</span>,</span><br><span class="line">             color: Colors.blueAccent,</span><br><span class="line">           ),</span><br><span class="line">            Container(</span><br><span class="line">              width: <span class="number">150</span>,</span><br><span class="line">              color: Colors.yellowAccent,</span><br><span class="line">            ),</span><br><span class="line">            Container(</span><br><span class="line">              width: <span class="number">150</span>,</span><br><span class="line">              color: Colors.orangeAccent,</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204091458840.png" alt="image-20220409145802224" style="zoom:50%;" /><blockquote><p>注意：</p><p>设置沿水平方向滚动，高度会自适应父容器；设置垂直方向滚动，宽度会自适应父容器</p></blockquote><p>也可以为列表项设置子组件为<code>ListView</code>，实现嵌套</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ListView(</span><br><span class="line">          scrollDirection: Axis.horizontal,</span><br><span class="line">          children: [</span><br><span class="line">           Container(</span><br><span class="line">             width: <span class="number">150</span>,</span><br><span class="line">             color: Colors.blueAccent,</span><br><span class="line">           ),</span><br><span class="line">            Container(</span><br><span class="line">              width: <span class="number">150</span>,</span><br><span class="line">              color: Colors.yellowAccent,</span><br><span class="line">              child: ListView(   <span class="comment">// 子组件依然是列表</span></span><br><span class="line">                children: [</span><br><span class="line">                  Container(</span><br><span class="line">                    height: <span class="number">250</span>,</span><br><span class="line">                    color: Colors.black,</span><br><span class="line">                  ),</span><br><span class="line">                  Container(</span><br><span class="line">                    height: <span class="number">250</span>,</span><br><span class="line">                    color: Colors.white,</span><br><span class="line">                  ),</span><br><span class="line">                  Container(</span><br><span class="line">                    height: <span class="number">250</span>,</span><br><span class="line">                    color: Colors.red,</span><br><span class="line">                  )</span><br><span class="line">                ],</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            Container(</span><br><span class="line">              width: <span class="number">150</span>,</span><br><span class="line">              color: Colors.orangeAccent,</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204091503414.png" alt="image-20220409150334357" style="zoom:50%;" /><h3 id="1-2-GridView"><a class="header-anchor" href="#1-2-GridView">¶</a>1.2. GridView</h3><p>用于以网格的形式呈现数据的组件，因为默认是沿垂直方向滚动的，因此垂直方向为<code>主轴</code>，水平方向便是<code>副轴</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GridView.count(</span><br><span class="line">            crossAxisCount: <span class="number">2</span>,  <span class="comment">// 列数，副轴</span></span><br><span class="line">            children: [</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.deepOrange,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.lightBlue,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.blueGrey,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.amber,</span><br><span class="line">              )</span><br><span class="line">        ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204091621467.png" alt="image-20220409162101304" style="zoom:50%;" /><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GridView.count(</span><br><span class="line">            crossAxisCount: <span class="number">2</span>,  <span class="comment">// 列数，副轴</span></span><br><span class="line">            mainAxisSpacing: <span class="number">10</span>,   <span class="comment">// 沿主轴的间隙</span></span><br><span class="line">            crossAxisSpacing: <span class="number">20</span>,   <span class="comment">// 沿副轴的间隙</span></span><br><span class="line">            children: [</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.deepOrange,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.lightBlue,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.blueGrey,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.amber,</span><br><span class="line">              )</span><br><span class="line">        ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204091623947.png" alt="image-20220409162313898" style="zoom:50%;" /><p><code>GridView</code>中的每一项都是进行自适应的，需要修改item的比例需要通过<code>childAspectRatio</code>设置</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GridView.count(</span><br><span class="line">            crossAxisCount: <span class="number">2</span>,  <span class="comment">// 列数，副轴</span></span><br><span class="line">            mainAxisSpacing: <span class="number">10</span>,   <span class="comment">// 沿主轴的间隙</span></span><br><span class="line">            crossAxisSpacing: <span class="number">20</span>,   <span class="comment">// 沿副轴的间隙</span></span><br><span class="line">            childAspectRatio: <span class="number">0.8</span>,  <span class="comment">// 子项宽高比</span></span><br><span class="line">            children: [</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.deepOrange,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.lightBlue,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.blueGrey,</span><br><span class="line">              ),</span><br><span class="line">              Container(</span><br><span class="line">                color: Colors.amber,</span><br><span class="line">              )</span><br><span class="line">        ],</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204091628375.png" alt="image-20220409162840338" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Widget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter学习笔记（三）</title>
      <link href="/2022/04/07/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2022/04/07/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>Flutter学习笔记（三）</h1><h2 id="1-内置基础组件（图文）"><a class="header-anchor" href="#1-内置基础组件（图文）">¶</a>1. 内置基础组件（图文）</h2><h3 id="1-1-Text"><a class="header-anchor" href="#1-1-Text">¶</a>1.1. Text</h3><p><code>Text</code>组件就可以当成是Android里面的<code>TextView</code>，用来显示一段文本</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(</span><br><span class="line">            <span class="string">&#x27;虚荣，是我最喜欢的原罪！&#x27;</span>,</span><br><span class="line">            textAlign: TextAlign.center,</span><br><span class="line">            overflow: TextOverflow.ellipsis,</span><br><span class="line">            style: <span class="keyword">const</span> TextStyle(fontWeight: FontWeight.bold),</span><br><span class="line">          ),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491574275681649157427277.png" alt=""></p><p>这里外面加了<code>Container</code>作为<code>Text</code>组件的父容器</p><p><code>textAlign</code>属性用于居中文本，那应当是相当于<code>Text</code>自身，那需要关注一下<code>Text</code>组件自身有没有变化，之前的<code>Align</code>组件和<code>Container</code>的<code>alignment</code>属性都是会使容器变化的</p><p>因此加上一个样式属性，查看一下组件的有效区域</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(</span><br><span class="line">            <span class="string">&#x27;虚荣，是我最喜欢的原罪！&#x27;</span>,</span><br><span class="line">            textAlign: TextAlign.center,</span><br><span class="line">            overflow: TextOverflow.ellipsis,</span><br><span class="line">            style: <span class="keyword">const</span> TextStyle(</span><br><span class="line">                fontWeight: FontWeight.bold,</span><br><span class="line">                backgroundColor: Colors.lightGreenAccent    <span class="comment">// 加上一个背景色</span></span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491580745661649158073901.png" alt=""></p><p>并没有变化，依然是&quot;<code>wrap_content</code>&quot;</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          color: Colors.lightBlue,</span><br><span class="line">          width: <span class="number">300</span>,</span><br><span class="line">          height: <span class="number">300</span>,</span><br><span class="line">          child: Text(</span><br><span class="line">            <span class="string">&#x27;虚荣，是我最喜欢的原罪！&#x27;</span>,</span><br><span class="line">            textAlign: TextAlign.center,</span><br><span class="line">            overflow: TextOverflow.ellipsis,</span><br><span class="line">            style: <span class="keyword">const</span> TextStyle(</span><br><span class="line">                fontWeight: FontWeight.bold,</span><br><span class="line">                backgroundColor: Colors.lightGreenAccent</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>这里的<code>textAlign</code>可以理解为就是文本组件对于它的容器的一种位置</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491707415731649170741232.png" alt=""></p><p>文本组件恰好包裹文字内容，但是对齐是相对于父级组件也就是<code>Container</code>的</p><p>在<code>TextAlign</code>中有一段注释</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Whether and how to align text horizontally.</span></span></span><br></pre></td></tr></table></figure><p>这里表述的是该对齐只是水平方向上的，因此上文是水平居中</p><br/><p><code>overflow</code>属性虽然设置，但此刻并未生效，需要改动一下父容器，使文字溢出</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491719935641649171993079.png" alt=""></p><p>由于父容器宽度变小了，空间显得局促，因而在显示不下时，会采用实现设置的方式对文本进行省略</p><br/><p><code>style</code>属性主要借助于<code>TextStyle</code>来实现样式的修改</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          color: Colors.lightBlue,</span><br><span class="line">          width: <span class="number">100</span>,</span><br><span class="line">          height: <span class="number">300</span>,</span><br><span class="line">          child: Text(</span><br><span class="line">            <span class="string">&#x27;虚荣，是我最喜欢的原罪！&#x27;</span>,</span><br><span class="line">            textAlign: TextAlign.center,</span><br><span class="line">            overflow: TextOverflow.ellipsis,</span><br><span class="line">            style: <span class="keyword">const</span> TextStyle(</span><br><span class="line">              color: Colors.deepOrange,  <span class="comment">// 字体颜色</span></span><br><span class="line">                fontWeight: FontWeight.bold,  <span class="comment">// 加粗</span></span><br><span class="line">                backgroundColor: Colors.lightGreenAccent,  <span class="comment">// 背景</span></span><br><span class="line">              letterSpacing: <span class="number">10</span>  <span class="comment">// 字间距</span></span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491725205651649172519942.png" alt=""></p><h3 id="1-2-Image"><a class="header-anchor" href="#1-2-Image">¶</a>1.2. Image</h3><p><code>Image</code>组件主要用来展示图片，既可以是网络图片，也可以是本地资源</p><h4 id="1-2-1-本地图片"><a class="header-anchor" href="#1-2-1-本地图片">¶</a>1.2.1. 本地图片</h4><p>使用本地图片资源首先需要进行一些配置</p><p>项目的<strong>根目录</strong>下新建文件夹<code>images</code>，以及子级目录<code>3.0x</code>、<code>2.0x</code>，系统会根据设备不同的像素密度自动加载</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16492581935801649258193278.png" alt=""></p><p>这里就随便一点了</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16492587575791649258756960.png" alt=""></p><p>然后修改配置文件<code>pubspec.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># To add assets to your application, add an assets section, like this:</span></span><br><span class="line">  <span class="attr">assets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">images/bg.jpg</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">images/2.0x/bg.jpg</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">images/3.0x/bg.jpg</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p><code>YAML</code>格式要对齐</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          color: Colors.lightBlue,</span><br><span class="line">          child: Image.asset(<span class="string">&#x27;images/bg.jpg&#x27;</span>),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>使用<code>assets</code>构造器加载</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16493438680106e05e5b6d944ca20128dcec4ab4d6774.png" alt="" style="zoom:80%;" /><h4 id="1-2-2-网络图片"><a class="header-anchor" href="#1-2-2-网络图片">¶</a>1.2.2. 网络图片</h4><p>使用<code>network</code>构造器实现网络图片加载</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          color: Colors.lightBlue,</span><br><span class="line">          width: <span class="number">300</span>,</span><br><span class="line">          height: <span class="number">300</span>,</span><br><span class="line">          child: Image.network(</span><br><span class="line">            <span class="string">&#x27;https://i0.hdslb.com/bfs/archive/ca375eb31fa90b8e23b88ed3433c2f60de1c2e6e.png&#x27;</span>,</span><br><span class="line">          ),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16492574445821649257443735.png" alt="" style="zoom:80%;" /><blockquote><p>组件还是要在具体场景使用中积累，**“每周组件”**的视频和组件API文档才是最有用的</p></blockquote><br/><p><a href="https://api.flutter.dev/flutter/widgets/widgets-library.html">Flutter组件库文档（https://api.flutter.dev/flutter/widgets/widgets-library.html）</a></p><p><a href="https://youtu.be/c1xLMaTUWCY">每日一组件（https://youtu.be/c1xLMaTUWCY）https://youtu.be/c1xLMaTUWCY）</a></p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Widget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter学习笔记（二）</title>
      <link href="/2022/04/05/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/04/05/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>Flutter学习笔记（二）</h1><h2 id="1-概述"><a class="header-anchor" href="#1-概述">¶</a>1. 概述</h2><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490749945651649074994467.png" alt="" style="zoom:50%;" /><p>Flutter中其实提供很多种类的内置组件，既涉及有状态的，也涉及无状态的，使用这些组件进行组合，很快能够完成界面布局的搭建工作</p><br/><h2 id="2-容器类"><a class="header-anchor" href="#2-容器类">¶</a>2. 容器类</h2><p>容器自然是要可以将其他组件放在自己的内部的，有点像Android里面的<code>ViewGroup</code>或者HTML里面的<code>&lt;div&gt;</code></p><h3 id="2-1-Container"><a class="header-anchor" href="#2-1-Container">¶</a>2.1. Container</h3><p><code>Container</code>组件的主要作用是将其他组件<strong>打包</strong>，以便于整体进行修饰或定位</p><p>可以将这里的<code>Container</code>看做是Android里的某一种布局</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          color: Colors.greenAccent,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490838940271649083893967.png" alt=""></p><p>这里只包含一个<code>Text</code>组件，并且设置了容器的背景色，在默认情况下，<code>Container</code>的大小会根据内容的大小自适应，可以看做是Android中的<code>wrap_content</code></p><br/><p>当然，内边距的<code>padding</code>的效果也别无二致</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          color: Colors.greenAccent,</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">20.0</span>),   <span class="comment">// 添加内边距</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490841665651649084166405.png" alt=""></p><p><code>EdgeInsets.all()</code>从外表大致能猜出来是四周都设置为相同的指定边距</p><br/><p>使用<code>margin</code>属性无疑是添加组件四周的外边距的设置</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          color: Colors.greenAccent,</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">          margin: EdgeInsets.all(<span class="number">10.0</span>),    <span class="comment">// 添加外边距，当然，这里也是四周一起加了</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490843445651649084343570.png" alt=""></p><br/><p><strong>装饰器</strong>可以用来在容器内部添加一个图形</p><blockquote><p>注意：</p><p>装饰器不可与color属性共存</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">20.0</span>),</span><br><span class="line">          margin: EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">          decoration: BoxDecoration(      <span class="comment">// 添加装饰器，同时去掉color属性，否则会报错</span></span><br><span class="line">            shape: BoxShape.circle,</span><br><span class="line">            color: Colors.lightBlueAccent</span><br><span class="line">          ),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490848415681649084840871.png" alt=""></p><p>这样看起来显然不好看，<strong>装饰器的大小默认受制于整个容器的大小</strong>，而容器的大小又是被内部的子组件撑起来的，那么在有限的空间里只能允许这么大的圆</p><p>因为装饰器在<code>Container</code>内部，因此只要增加一些<code>padding</code>，这样就有更多空间“发育”</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490855485651649085547838.png" alt=""></p><br/><p><strong>对齐属性</strong>，作用于<code>Container</code>的子级组件</p><blockquote><p>注意：</p><p>该属性直接设置后当前容器会直接铺满父容器，感觉这一点很奇怪，可能是因为本身默认情况下自适应，没有办法体现该属性的效果吧，但这就改变自己用于体现这种效果吗，这个组件的表现欲也太强了😂</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          color: Colors.amber,</span><br><span class="line">          alignment: Alignment.topLeft,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490867335671649086732861.png" alt=""></p><p>当然，也可以通过指定宽高或者进行布局约束覆盖该效果</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          child: Text(<span class="string">&#x27;优雅永不过时&#x27;</span>),</span><br><span class="line">          color: Colors.amber,</span><br><span class="line">          alignment: Alignment.topLeft,</span><br><span class="line">          width: <span class="number">200</span>,</span><br><span class="line">          height: <span class="number">100</span>,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490869365741649086936336.png" alt=""></p><h3 id="2-2-Padding"><a class="header-anchor" href="#2-2-Padding">¶</a>2.2. Padding</h3><p>注意，这里的<code>Padding</code>不是一个属性，而是一个组件</p><br/><p>简单了解一下之前提到的<code>EdgeInsets</code></p><p>它是抽象类<code>EdgeInsetsGeometry</code>的子类，可以用来描述组件各个方向上的距离</p><br/><p><code>Padding</code>组件实际上与<code>Container</code>的<code>padding</code>属性差不多，但是更加<strong>专一和轻量</strong></p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491234345651649123433576.png" alt="" style="zoom:70%;" /><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Padding(</span><br><span class="line">          padding: EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">          child: Container(</span><br><span class="line">            color: Colors.deepPurple,</span><br><span class="line">            child: Text(<span class="string">&#x27;一切皆为组件&#x27;</span>),</span><br><span class="line">          )</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491233175681649123317120.png" alt=""></p><h3 id="2-3-Align"><a class="header-anchor" href="#2-3-Align">¶</a>2.3. Align</h3><p><code>Align</code>组件重点描述的是父子组件之间的关系，<strong>子组件相对于父组件的位置</strong></p><blockquote><p>注意：</p><p>这里在使用<code>Align</code>组件时和之前<code>Container</code>的<code>alignment</code>属性有相似之处，父级都会自己扩展范围</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">         color: Colors.lightBlue,</span><br><span class="line">         child: Align(</span><br><span class="line">           alignment: Alignment.topLeft,</span><br><span class="line">           child: Text(<span class="string">&#x27;一切皆组件&#x27;</span>),</span><br><span class="line">         ),</span><br><span class="line">       )</span><br></pre></td></tr></table></figure><p>这里设置文本组件位于父级组件的左上角，可以想象父级组件会默认为父级的大小，然后将子级组件放到左上角（因为没有指定大小）</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491240515661649124051139.png" alt=""></p><p>除了代码枚举的几个预设的位置，还可以通过<strong>校准值</strong>进行指定</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491242135651649124213167.png" alt="" style="zoom:50%;" /><p><code>Align</code>组件在定义中将一个组件在水平方向和垂直方向，水平方向上组件从左至划分为为-1 ~ 1，垂直方向上组件从上到下划分为-1 ~ 1</p><p>当然，范围可以超出，只是不在组件范围内了</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">          color: Colors.lightBlue,</span><br><span class="line">          child: Align(</span><br><span class="line">            alignment: Alignment(<span class="number">0.5</span>, <span class="number">0.5</span>),</span><br><span class="line">            child: Text(<span class="string">&#x27;一切皆组件&#x27;</span>),</span><br><span class="line">          )</span><br></pre></td></tr></table></figure><p>这样可以将对齐控制得更加精确</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16491253045671649125303770.png" alt="" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NDK（入门）</title>
      <link href="/2022/04/04/NDK%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/"/>
      <url>/2022/04/04/NDK%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>NDK（入门）</h1><h2 id="1-使用目的"><a class="header-anchor" href="#1-使用目的">¶</a>1. 使用目的</h2><ul><li>进一步提升设备性能，以降低延迟或运行游戏或物理模拟等计算密集型应用</li><li>重复使用您自己或其他开发者的 C 或 C++ 库</li></ul><p>Android Studio原生库编译默认使用<code>CMake</code>，同时也支持<code>ndk-build</code></p><h2 id="2-准备工作"><a class="header-anchor" href="#2-准备工作">¶</a>2. 准备工作</h2><ul><li>NDK：允许在Android中使用C/C++</li><li>CMake：外部构建工具，如果使用<code>ndk-build</code>，可以不需要</li><li>LLDB：原生代码调试工具，默认AS自带</li></ul><p>先进到<code>SDK Manager</code>准备一下对应的工具</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490380341231649038033292.png" alt="" style="zoom:70%;" /><br/><h2 id="3-添加原生代码"><a class="header-anchor" href="#3-添加原生代码">¶</a>3. 添加原生代码</h2><h3 id="3-1-创建原生源代码文件"><a class="header-anchor" href="#3-1-创建原生源代码文件">¶</a>3.1. 创建原生源代码文件</h3><p>首先，创建项目时选择<code>Native C++</code>类型</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490391141311649039113214.png" alt="" style="zoom:70%;" /><p>选择默认的工具链，这样可以使用默认的<code>CMake</code>配置</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490392661221649039265481.png" alt="" style="zoom:70%;" /><p>新的项目创建完成后，使用Android视图查看一下项目文件结构，会发现出现了一个<code>cpp</code>目录，<code>CMakeLists.txt</code>代表<code>CMake</code>的构建脚本，而另一个.cpp文件是示例代码</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490400261281649040025617.png" alt=""></p><blockquote><p><strong>简要分析示例</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_minos_nativedemo_MainActivity_stringFromJNI(</span><br><span class="line">        JNIEnv* env,</span><br><span class="line">        jobject /* this */) &#123;</span><br><span class="line">    std::string hello = &quot;Hello from C++&quot;;</span><br><span class="line">    return env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是示例.cpp的代码，可以看到顶部包含了<code>jni</code>框架的头文件，下面声明的就是<code>stringFromJNI()</code>函数，大致的意思就是将该函数对外暴露，提供给Java调用</p><br/><p>再看下<code>CMakeLists.txt</code>中的内容</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Creates and names a library, sets it as either STATIC</span><br><span class="line"># or SHARED, and provides the relative paths to its source code.</span><br><span class="line"># You can define multiple libraries, and CMake builds them for you.</span><br><span class="line"># Gradle automatically packages shared libraries with your APK.</span><br><span class="line"></span><br><span class="line">add_library( # Sets the name of the library.</span><br><span class="line">        nativedemo</span><br><span class="line"></span><br><span class="line">        # Sets the library as a shared library.</span><br><span class="line">        SHARED</span><br><span class="line"></span><br><span class="line">        # Provides a relative path to your source file(s).</span><br><span class="line">        native-lib.cpp)</span><br></pre></td></tr></table></figure><p>就像注释里描述的那样，根据源文件的路径生成库，Gradle自动打包时会一同放入apk中</p><br/><p>然后来看看使用的地方，在MainActivity中会使用到里面的方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="comment">// Used to load the &#x27;nativedemo&#x27; library on application startup.</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;nativedemo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是初始化，放在了Activity的初始化块中，这样在应用启动时就可以调用<code>System.loadLibrary()</code>方法根据库的名称将库加载进来</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A native method that is implemented by the &#x27;nativedemo&#x27; native library,</span></span><br><span class="line"><span class="comment"> * which is packaged with this application.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">external</span> <span class="function"><span class="keyword">fun</span> <span class="title">stringFromJNI</span><span class="params">()</span></span>: String</span><br></pre></td></tr></table></figure><p>这里是对于<code>JNI</code>方法的声明，在加载完库之后，就可以从中取它了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">    binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example of a call to a native method</span></span><br><span class="line">        binding.sampleText.text = stringFromJNI()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用<code>ViewBinding</code>进行布局元素的操作，调用<code>stringFromJNI()</code>返回字符串，然后将内容显示到布局上</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490541765681649054175831.png" alt="" style="zoom:50%;" /><br/><p>整体流程大致是：</p><ul><li>Gradle调用<code>CMakeLists.txt</code></li><li><code>CMake</code>按照构建脚本中的命令将.cpp编译到共享对象库中，并命名为<code>xxx.so</code>，Gradle之后会将其一同打包到apk中（包分析器可以看到）</li></ul><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490545195721649054519114.png" alt="" style="zoom:70%;" /><ul><li>运行时，MainActivity调用<code>System.loadLibrary()</code>加载原生库</li><li>在<code>onCreate()</code>中MainActivity调用<code>stringFromJNI()</code></li></ul><br/><blockquote><p>开始自定义</p></blockquote><p>首先需要在当前模块下有一个专门的cpp目录</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout@main/img/16490550415661649055041171.png" alt="" style="zoom:70%;" /><p>大概是这样的层次结构，模块 &gt; src &gt; main &gt; <strong>cpp</strong></p><br/><p>然后在该目录下放置C++的源代码文件</p><p>接下来就是代码逻辑的编写，去实现我们需要的功能</p><br/><h3 id="3-2-配置CMake"><a class="header-anchor" href="#3-2-配置CMake">¶</a>3.2. 配置CMake</h3><p><code>CMake</code>的构建脚本文件<code>CMakeLists.txt</code>是一个<strong>纯文本文件</strong>，并且使用它必须指定文件的名称为<strong>CMakeLists.txt</strong></p><br/><p>然后需要向其中添加一些需要用到的命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10.2)</span><br></pre></td></tr></table></figure><p>这个命令是设置了构建的最小版本，也就是下限</p><br/><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_library(</span><br><span class="line">  nativedemo</span><br><span class="line">  SHARED</span><br><span class="line">  native-lib.cpp)</span><br></pre></td></tr></table></figure><p>这里给出库的名称、类型、对应的源文件路径</p><blockquote><p><strong>注意</strong></p><p>so库的名称总是以lib&lt;CMake中定义的库名称&gt;.so出现，但是使用System.loadLibrary()时还是使用CMake中定义的名称</p></blockquote><br/><h3 id="3-3-提供CMake脚本文件的路径配置Gradle"><a class="header-anchor" href="#3-3-提供CMake脚本文件的路径配置Gradle">¶</a>3.3. 提供CMake脚本文件的路径配置Gradle</h3><p>实现Gradle关联<code>CMake</code>打包，需要在当前模块的<code>build.gradle</code>中进行一些配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">··android &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        externalNativeBuild &#123;</span><br><span class="line">            cmake &#123;</span><br><span class="line">                cppFlags <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            path file(<span class="string">&#x27;src/main/cpp/CMakeLists.txt&#x27;</span>)</span><br><span class="line">            version <span class="string">&#x27;3.10.2&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到需要<code>externalNativeBuild</code>块进行相关配置</p><br/><p>外层的主要用于与Gradle建立连接，而<code>defaultConfog</code>块内层的则进行一些可选的配置项</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter学习笔记（一）</title>
      <link href="/2022/04/03/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/04/03/Flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1>Flutter学习笔记（一）</h1><p>Flutter的官方文档提供了一个理念——<strong>“一切皆为Widget”</strong></p><p>由此可以看得出来<code>Widget</code>在Flutter中的重要地位</p><h2 id="1-Widget是什么？"><a class="header-anchor" href="#1-Widget是什么？">¶</a>1. Widget是什么？</h2><p><code>Widget</code>我们将其理解为<strong>组件</strong>，一个应用的界面往往都比较丰富，上面会有各式各样的组件，像图片、按钮、播放器这些都可以称为组件。</p><p>由于之前自己接触过<code>React</code>的开发，因此我认为，这里的组件就相当于程序中的一个对象，它具有<strong>专门</strong>的功能，与用户进行交互，处理相应的数据，就像你打开<code>Material Design</code>组件库一样，里面各个组件都扮演着特定的角色，为了某一种特定的功能而存在。</p><p>打个更加贴近生活的比方，我们刚搬进新家，而空荡荡的屋子就是我们原始的空白界面，然而我们的日常生活总是需要各种工具或者是家具来满足我们的需要，那么这种需要就相当于是组件所需要具备的功能，每个工具或者家具只是<strong>专门负责某一方面的功能</strong>，此时，在我看来，就可以将家具或工具理解为程序意义上的组件，同时，这些组件的摆放和搭配也形成了界面上丰富多彩的布局。</p><h2 id="2-Widget有哪些？"><a class="header-anchor" href="#2-Widget有哪些？">¶</a>2. Widget有哪些？</h2><ul><li>无状态组件（Stateless Widget）</li><li>有状态组件（Stateful Widget）</li></ul><p>可以将组件根据状态特点分为两个大类</p><h3 id="2-1-无状态组件"><a class="header-anchor" href="#2-1-无状态组件">¶</a>2.1. 无状态组件</h3><p><code>StatelessWidget</code>类直接继承于<code>Widget</code>类</p><p>无状态组件具体做些什么事呢？它的任务很简单，仅仅是将需要展示的内容进行呈现，而后就躺平了。</p><p><code>StatelessWidget</code>是一个抽象类，需要重写抽象方法<code>build()</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> TextButton(</span><br><span class="line">      onPressed: () =&gt; &#123;&#125;,</span><br><span class="line">      child: <span class="keyword">const</span> Text(<span class="string">&#x27;Flutter&#x27;</span>)</span><br><span class="line">      ,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>简单使用一个<code>TextButton</code>的内置组件构成第一个无状态组件的内容，在<code>build</code>方法中返回需要展示的<code>Widget</code>对象</p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204031715214.png" alt="image-20220403171552181" style="zoom:40%;" /><h3 id="2-2-有状态组件"><a class="header-anchor" href="#2-2-有状态组件">¶</a>2.2. 有状态组件</h3><p>无状态组件似乎看起来挺简单的，接下来关注一下有状态组件，它能够实现组件状态的切换。</p><p>有状态组件需要继承自<code>StatefulWidget</code>类，另外，由于其需要对状态进行操作，还会涉及到<code>State</code>类</p><p>首先，先定义一个继承于<code>StatefulWidget</code>类的组件，并且重写<code>createState()</code>方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnotherWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> text = <span class="string">&#x27;空空如也&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _AnotherWidgetState createState() &#123;</span><br><span class="line">    <span class="keyword">return</span> _AnotherWidgetState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给出text作为一个组件的属性，用于显示文本</p><p><code>State</code>类是一个抽象类，<code>createState()</code>需要返回一个状态，因此，专门为该组件设置一个状态类</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnotherWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnotherWidget</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> textState = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化状态</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    textState = widget.text;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定义一个函数来更新状态</span></span><br><span class="line">  <span class="keyword">void</span> _changeText(<span class="built_in">String</span> s) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      textState = s;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> TextButton(</span><br><span class="line">        onPressed: () =&gt; _changeText(<span class="string">&#x27;内有玄机&#x27;</span>),</span><br><span class="line">        child: Text(textState)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义该组件的状态，让其继承<code>State</code>类，使用泛型让它和对应的组件间建立联系</p><p>而后对应的泛型会被赋给<code>State</code>的成员<code>widget</code>上，通过该成员便可以获取之前定义的组件上的text属性</p><p>重写<code>initState()</code>方法对状态进行初始化的赋值操作，这里使用textState记录状态</p><p><code>setState()</code>则是用来更新状态的，在这里就是将变量进行修改</p><p><code>build()</code>就像之前无状态组件里的一样，用于呈现组件，利用其<code>onPressed</code>属性，监听点击，触发状态修改</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/202204032037870.png" alt="image-20220403203721828" style="zoom:50%;" /><img src="/Users/shenzhisheng/Library/Application Support/typora-user-images/image-20220403203810971.png" alt="image-20220403203810971" style="zoom:50%;" /></p><p>这样，通过对于变量textState的修改，更新了UI的文本显示</p><h2 id="3-几个重要的方法"><a class="header-anchor" href="#3-几个重要的方法">¶</a>3. 几个重要的方法</h2><h3 id="3-1-setState"><a class="header-anchor" href="#3-1-setState">¶</a>3.1. setState()</h3><p>在有状态组件中，通过数据的变更来触发UI的改变，<code>setState()</code>方法就是用来操作状态的，它所起到的作用就是<strong>触发组件树的重建，并且将新的状态数据更新到组件上</strong></p><p>基于上面的代码，也就是说，按下按钮触发<code>_changeText(String s)</code>方法，从而调用内部的`setState() 通知关联的组件进行重建，以呈现新的状态</p><h3 id="3-2-initState"><a class="header-anchor" href="#3-2-initState">¶</a>3.2. initState()</h3><p>这是组件状态对象中第一个被调用的方法，正如其名字一样，主要进行一些状态初始化的操作，属于状态生命周期里的内容</p><h2 id="3-3-dispose"><a class="header-anchor" href="#3-3-dispose">¶</a>3.3. dispose()</h2><p>与<code>initState()</code>相对应，在状态生命周期结束前调用，主要用于释放资源</p><h2 id="3-4-build"><a class="header-anchor" href="#3-4-build">¶</a>3.4. build()</h2><p>在无状态组件和有状态组件的状态类中都有它的踪影</p><p>组件通过组合往往会形成更加复杂的组件，将组件呈现出来的过程总是离不开“套娃”。其实这也是对应了<strong>组件树</strong>的概念</p><p><code>build()</code>返回的<code>Widget</code>其实是最外层的组件，因为将里面的内容相当于打了个包，这样便将整个需要显示的内容都准备好了</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>视图绑定</title>
      <link href="/2022/04/02/%E8%A7%86%E5%9B%BE%E7%BB%91%E5%AE%9A/"/>
      <url>/2022/04/02/%E8%A7%86%E5%9B%BE%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h1>ViewBinding</h1><h2 id="1-准备工作"><a class="header-anchor" href="#1-准备工作">¶</a>1. 准备工作</h2><p>首先需要在模块中启用“视图绑定”，在模块对应的<code>build.gradle</code>中添加配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdk <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    viewBinding &#123;</span><br><span class="line">        enabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后项目就下载了对应依赖</p><p><img src="https://cdn.jsdelivr.net/gh/minos-chertsfield/PicAbout/img/WechatIMG9.png" alt="WechatIMG9"></p><p>启用完成后，系统会为该模块下的所有布局XML文件生成一个<strong>与之对应的绑定类</strong></p><br/><h2 id="2-绑定类"><a class="header-anchor" href="#2-绑定类">¶</a>2. 绑定类</h2><p>布局XML中会有一些组件设置id属性，这些属性在对应的绑定类中可以直接通过id来获取，这些控件相当于类的成员，根组件和其他有id的组件的引用都包含其实例之中</p><br/><h3 id="2-1-命名方式"><a class="header-anchor" href="#2-1-命名方式">¶</a>2.1. 命名方式</h3><p>绑定类会以“Binding”结尾，采用大驼峰</p><h3 id="2-2-根视图"><a class="header-anchor" href="#2-2-根视图">¶</a>2.2. 根视图</h3><p>可以通过<code>getRoot()</code>获取对于布局文件中根视图的引用</p><br/><h2 id="3-使用"><a class="header-anchor" href="#3-使用">¶</a>3. 使用</h2><h3 id="3-1-Activity中"><a class="header-anchor" href="#3-1-Activity中">¶</a>3.1. Activity中</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="comment">// 调用绑定类的inflate静态方法，对象实例化</span></span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        <span class="comment">// 获取根布局</span></span><br><span class="line">        <span class="keyword">val</span> view = binding.root</span><br><span class="line">        setContentView(view)</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure><p>然后就可以通过绑定类的实例去操作布局文件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">binding.run &#123;</span><br><span class="line">            ivLogo.setImageResource(R.drawable.ic_launcher_background)</span><br><span class="line">            tvContent.setText(R.string.app_name)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-Fragment中"><a class="header-anchor" href="#3-2-Fragment中">¶</a>3.2. Fragment中</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: FragmentBlankBinding</span><br><span class="line"></span><br><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: View &#123;</span><br><span class="line">        binding = FragmentBlankBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> binding.root</span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure><p>同样得到了布局文件绑定类的实例，然后可以使用其中的引用去操作布局中的组件</p><p><strong>在Fragment中，由于其视图的生命周期短于Fragment自身的生命周期，因此需要在<code>onDestroyView()</code>中清除对绑定类实例的引用</strong></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/29/hello-world/"/>
      <url>/2022/03/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a class="header-anchor" href="#Quick-Start">¶</a>Quick Start</h2><h3 id="Create-a-new-post"><a class="header-anchor" href="#Create-a-new-post">¶</a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a class="header-anchor" href="#Run-server">¶</a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a class="header-anchor" href="#Generate-static-files">¶</a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a class="header-anchor" href="#Deploy-to-remote-sites">¶</a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
